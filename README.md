<h1 align="center"> Java </h1>

# Content

1. [Chapter 1: Introduction to Java and Setting Up Your Environment](#chapter1)
    - [Chapter 1 - Part 1: What is Java and Why Learn It?](#chapter1part1)
      - [Chapter 1 - Part 1.1: What is Java?](#chapter1part1.1)
      - [Chapter 1 - Part 1.2: Why Learn Java?](#chapter1part1.2)
    - [Chapter 1 - Part 2: Understanding the Java Ecosystem: JVM, JRE, JDK](#chapter1part2)
      - [Chapter 1 - Part 2.1: Compilation and Interpretation, Source Code and Object Code, Virtual Machine](#chapter1part2.1)
      - [Chapter 1 - Part 2.2: The Java Virtual Machine (JVM)](#chapter1part2.2)
      - [Chapter 1 - Part 2.3: The Java Runtime Environment (JRE)](#chapter1part2.3)
      - [Chapter 1 - Part 2.4: The Java Development Kit (JDK)](#chapter1part2.4)
      - [Chapter 1 - Part 2.5: Relationship Between JVM, JRE, and JDK](#chapter1part2.5)
      - [Chapter 1 - Part 2.6: Choosing the Right Version](#chapter1part2.6)
    - [Chapter 1 - Part 3: Installing the Java Development Kit (JDK)](#chapter1part3)
      - [Chapter 1 - Part 3.1: Understanding the JDK and its Components](#chapter1part3.1)
      - [Chapter 1 - Part 3.2: Downloading the JDK](#chapter1part3.2)
      - [Chapter 1 - Part 3.3: Installing the JDK](#chapter1part3.3)
      - [Chapter 1 - Part 3.4: Setting Environment Variables](#chapter1part3.4)
      - [Chapter 1 - Part 3.5: Verifying the Installation](#chapter1part3.5)
      - [Chapter 1 - Part 3.6: Troubleshooting Common Installation Issues](#chapter1part3.6)
    - [Chapter 1 - Part 4: Setting Up a Java Development Environment (IDE): IntelliJ IDEA or Eclipse](#chapter1part4)
      - [Chapter 1 - Part 4.1: Understanding Integrated Development Environments (IDEs)](#chapter1part4.1)
      - [Chapter 1 - Part 4.2: IntelliJ IDEA](#chapter1part4.2)
      - [Chapter 1 - Part 4.3: Eclipse](#chapter1part4.3)
    - [Chapter 1 - Part 5: Writing and Running Your First Java Program: "Hello, World!"](#chapter1part5)
      - [Chapter 1 - Part 5.1: Creating Your First Java Program: "Hello, World!"](#chapter1part5.1)
      - [Chapter 1 - Part 5.2: Understanding the Compilation Process](#chapter1part5.2)
      - [Chapter 1 - Part 5.3: Common Errors and Troubleshooting](#chapter1part5.3)
    - [Chapter 1 - Part 6: Understanding Basic Java Program Structure](#chapter1part6)
      - [Chapter 1 - Part 6.1: Anatomy of a Java Program](#chapter1part6.1)
      - [Chapter 1 - Part 6.2: Putting It All Together: A Complete Java Program](#chapter1part6.2)
      - [Chapter 1 - Part 6.3: Common Errors and How to Avoid Them](#chapter1part6.3)
2. [Chapter 2: Java Fundamentals: Data Types, Variables, and Operators](#chapter2)
    - [Chapter 2 - Part 1: Understanding Primitive Data Types: int, double, boolean, char](#chapter2part1)
      - [Chapter 2 - Part 1.1: Data Types in Java](#chapter2part1.1)
      - [Chapter 2 - Part 1.2: Integer Data Type: int](#chapter2part1.2)
      - [Chapter 2 - Part 1.3: Floating-Point Data Type: double](#chapter2part1.3)
      - [Chapter 2 - Part 1.4: Boolean Data Type: boolean](#chapter2part1.4)
      - [Chapter 2 - Part 1.5: Character Data Type: char](#chapter2part1.5)
    - [Chapter 2 - Part 2: Declaring and Initializing Variables](#chapter2part2)
      - [Chapter 2 - Part 2.1: Understanding Variable Declaration](#chapter2part2.1)
      - [Chapter 2 - Part 2.2: Understanding Variable Initialization](#chapter2part2.2)
      - [Chapter 2 - Part 2.3: Best Practices for Declaring and Initializing Variables](#chapter2part2.3)
      - [Chapter 2 - Part 2.4: Casting](#chapter2part2.4)
      - [Chapter 2 - Part 2.5: Variable Scope (Java Scope)](#chapter2part2.5)
      - [Chapter 2 - Part 2.6: Examples and Demonstrations](#chapter2part2.6)
    - [Chapter 2 - Part 3: Working with Strings](#chapter2part3)
      - [Chapter 2 - Part 3.1: Creating Strings](#chapter2part3.1)
      - [Chapter 2 - Part 3.2: String Immutability](#chapter2part3.2)
      - [Chapter 2 - Part 3.3: String Manipulation](#chapter2part3.3)
      - [Chapter 2 - Part 3.4: String Comparison](#chapter2part3.4)
      - [Chapter 2 - Part 3.5: String Methods](#chapter2part3.5)
    - [Chapter 2 - Part 4: Arithmetic Operators: +, -, *, /, %](#chapter2part4)
      - [Chapter 2 - Part 4.1: Basic Arithmetic Operators](#chapter2part4.1)
      - [Chapter 2 - Part 4.2: Operator Precedence](#chapter2part4.2)
      - [Chapter 2 - Part 4.3: Practical Examples and Demonstrations](#chapter2part4.3)
    - [Chapter 2 - Part 5: Assignment Operators: =, +=, -=, *=, /=](#chapter2part5)
      - [Chapter 2 - Part 5.1: Understanding the Basic Assignment Operator (=)](#chapter2part5.1)
      - [Chapter 2 - Part 5.2: Compound Assignment Operators (+=, -=, *=, /=)](#chapter2part5.2)
      - [Chapter 2 - Part 5.3: Practical Examples and Demonstrations](#chapter2part5.3)
    - [Chapter 2 - Part 6: Comparison Operators: ==, !=, >, <, >=, <=](#chapter2part6)
      - [Chapter 2 - Part 6.1: Understanding Comparison Operators](#chapter2part6.1)
      - [Chapter 2 - Part 6.2: Practical Examples and Demonstrations](#chapter2part6.2)
    - [Chapter 2 - Part 7: Logical Operators: &&, ||, !](#chapter2part7)
      - [Chapter 2 - Part 7.1: Understanding Logical Operators](#chapter2part7.1)
      - [Chapter 2 - Part 7.2: Combining Logical Operators](#chapter2part7.2)
      - [Chapter 2 - Part 7.3: Practical Examples](#chapter2part7.3)
    - [Chapter 2 - Part 8: Bitwise Operators](#chapter2part8)
    - [Chapter 2 - Part 9: Operator Precedence](#chapter2part9)
      - [Chapter 2 - Part 9.1: Understanding Operator Precedence in Java](#chapter2part9.1)
      - [Chapter 2 - Part 9.2: Using Parentheses to Control Precedence](#chapter2part9.2)
      - [Chapter 2 - Part 9.3: Practical Examples and Demonstrations](#chapter2part9.3)
3. [Chapter 3: Control Flow: Making Decisions and Repeating Actions](#chapter3)
    - [Chapter 3 - Part 1: Introduction to Control Flow Statements](#chapter3part1)
      - [Chapter 3 - Part 1.1: Understanding Control Flow](#chapter3part1.1)
      - [Chapter 3 - Part 1.2: Decision-Making Statements: An Overview](#chapter3part1.2)
      - [Chapter 3 - Part 1.3: Looping Statements: An Introduction](#chapter3part1.3)
      - [Chapter 3 - Part 1.4: Using break and continue Statements](#chapter3part1.4)
    - [Chapter 3 - Part 2: The `if` Statement: Conditional Execution](#chapter3part2)
      - [Chapter 3 - Part 2.1: Understanding the if Statement](#chapter3part2.1)
      - [Chapter 3 - Part 2.2: Practical Examples of the if Statement](#chapter3part2.2)
    - [Chapter 3 - Part 3: The `if-else` Statement: Choosing Between Two Options](#chapter3part3)
      - [Chapter 3 - Part 3.1: Understanding the if-else Statement](#chapter3part3.1)
      - [Chapter 3 - Part 3.2: Omitting Curly Braces](#chapter3part3.2)
      - [Chapter 3 - Part 3.3: Nested if-else Statements](#chapter3part3.3)
      - [Chapter 3 - Part 3.4: Short-Hand if-else](#chapter3part3.4)
      - [Chapter 3 - Part 3.5: Common Errors and Pitfalls](#chapter3part3.5)
    - [Chapter 3 - Part 4: The `if-else if-else` Statement: Handling Multiple Conditions](#chapter3part4)
      - [Chapter 3 - Part 4.1: Understanding the if-else if-else Statement](#chapter3part4.1)
    - [Chapter 3 - Part 5: The `switch` Statement: Selecting from Multiple Cases](#chapter3part5)
      - [Chapter 3 - Part 5.1: Understanding the switch Statement](#chapter3part5.1)
      - [Chapter 3 - Part 5.2: Practical Examples and Demonstrations](#chapter3part5.2)
    - [Chapter 3 - Part 6: The `while` Loop: Repeating Code While a Condition is True](#chapter3part6)
      - [Chapter 3 - Part 6.1: Understanding the while Loop](#chapter3part6.1)
      - [Chapter 3 - Part 6.2: Using while Loops with User Input](#chapter3part6.2)
      - [Chapter 3 - Part 6.3: Using while Loops with Boolean Flags](#chapter3part6.3)
      - [Chapter 3 - Part 6.4: Nested while Loops](#chapter3part6.4)
    - [Chapter 3 - Part 7: The `do-while` Loop: Ensuring Code Executes at Least Once](#chapter3part7)
      - [Chapter 3 - Part 7.1: Understanding the do-while Loop](#chapter3part7.1)
      - [Chapter 3 - Part 7.2: Practical Examples of do-while Loops](#chapter3part7.2)
    - [Chapter 3 - Part 8: The `for` Loop: Repeating Code a Specific Number of Times](#chapter3part8)
      - [Chapter 3 - Part 8.1: Understanding the for Loop Syntax](#chapter3part8.1)
      - [Chapter 3 - Part 8.2: How the for Loop Works](#chapter3part8.2)
      - [Chapter 3 - Part 8.3: Practical Examples of for Loops](#chapter3part8.3)
      - [Chapter 3 - Part 8.4: Variations of the for Loop](#chapter3part8.4)
      - [Chapter 3 - Part 8.5: Common Mistakes and How to Avoid Them](#chapter3part8.5)
    - [Chapter 3 - Part 9: Using `break` and `continue` Statements](#chapter3part9)
      - [Chapter 3 - Part 9.1: Understanding the break Statement](#chapter3part9.1)
      - [Chapter 3 - Part 9.2: Understanding the continue Statement](#chapter3part9.2)
      - [Chapter 3 - Part 9.3: Practical Examples and Demonstrations](#chapter3part9.3)
4. [Chapter 4: Working with Arrays and Strings](#chapter4)
    - [Chapter 4 - Part 1: Introduction to Arrays: Storing Collections of Data](#chapter4part1)
      - [Chapter 4 - Part 1.1: Declaring and Initializing Arrays](#chapter4part1.1)
      - [Chapter 4 - Part 1.2: Accessing Array Elements](#chapter4part1.2)
      - [Chapter 4 - Part 1.3: Looping Through Arrays](#chapter4part1.3)
    - [Chapter 4 - Part 2: Declaring and Initializing Arrays](#chapter4part2)
      - [Chapter 4 - Part 2.1: Declaring Arrays](#chapter4part2.1)
      - [Chapter 4 - Part 2.2: Initializing Arrays](#chapter4part2.2)
      - [Chapter 4 - Part 2.3: Accessing Array Elements](#chapter4part2.3)
      - [Chapter 4 - Part 2.4: Looping Through Arrays](#chapter4part2.4)
    - [Chapter 4 - Part 3: Accessing Array Elements](#chapter4part3)
      - [Chapter 4 - Part 3.1: Accessing Array Elements Using Indices](#chapter4part3.1)
      - [Chapter 4 - Part 3.2: ArrayIndexOutOfBoundsException](#chapter4part3.2)
      - [Chapter 4 - Part 3.3: Practical Examples and Demonstrations](#chapter4part3.3)
    - [Chapter 4 - Part 4: Looping Through Arrays](#chapter4part4)
      - [Chapter 4 - Part 4.1: Understanding the Need for Loops](#chapter4part4.1)
      - [Chapter 4 - Part 4.2: Types of Loops in Java](#chapter4part4.2)
      - [Chapter 4 - Part 4.3: The for Loop](#chapter4part4.3)
      - [Chapter 4 - Part 4.4: The Enhanced for Loop (For-Each Loop)](#chapter4part4.4)
      - [Chapter 4 - Part 4.5: The while Loop](#chapter4part4.5)
      - [Chapter 4 - Part 4.6: The do-while Loop](#chapter4part4.6)
      - [Chapter 4 - Part 4.7: Using Streams and Lambda Expressions to Loop Through Arrays](#chapter4part4.7)
    - [Chapter 4 - Part 5: Multidimensional Arrays](#chapter4part5)
      - [Chapter 4 - Part 5.1: Understanding Multidimensional Arrays](#chapter4part5.1)
      - [Chapter 4 - Part 5.2: Practical Examples and Demonstrations](#chapter4part5.2)
    - [Chapter 4 - Part 6: Introduction to Strings: Working with Text](#chapter4part6)
      - [Chapter 4 - Part 6.1: Creating Strings](#chapter4part6.1)
      - [Chapter 4 - Part 6.2: String Manipulation](#chapter4part6.2)
      - [Chapter 4 - Part 6.3: String Comparison: equals() vs. ==](#chapter4part6.3)
      - [Chapter 4 - Part 6.4: String Methods: toUpperCase(), toLowerCase(), trim()](#chapter4part6.4)
    - [Chapter 4 - Part 7: String Manipulation: Concatenation, Substrings, Length](#chapter4part7)
      - [Chapter 4 - Part 7.1: String Concatenation](#chapter4part7.1)
      - [Chapter 4 - Part 7.2: Extracting Substrings](#chapter4part7.2)
      - [Chapter 4 - Part 7.3: Determining String Length](#chapter4part7.3)
    - [Chapter 4 - Part 8: String Comparison: equals() vs. ==](#chapter4part8)
      - [Chapter 4 - Part 8.1: Understanding String Immutability and the String Pool](#chapter4part8.1)
      - [Chapter 4 - Part 8.2: The equals() Method: Comparing String Content](#chapter4part8.2)
      - [Chapter 4 - Part 8.3: The == Operator: Comparing Object References](#chapter4part8.3)
      - [Chapter 4 - Part 8.4: When to Use equals() vs. ==](#chapter4part8.4)
    - [Chapter 4 - Part 9: String Methods: toUpperCase(), toLowerCase(), trim()](#chapter4part9)
      - [Chapter 4 - Part 9.1: Understanding toUpperCase() and toLowerCase()](#chapter4part9.1)
      - [Chapter 4 - Part 9.2: Understanding trim()](#chapter4part9.2)
      - [Chapter 4 - Part 9.3: Combining String Methods](#chapter4part9.3)
5. [Chapter 5: Object-Oriented Programming (OOP) Fundamentals](#chapter5)
    - [Chapter 5 - Part 1: Introduction to Object-Oriented Programming (OOP)](#chapter5part1)
      - [Chapter 5 - Part 1.1: Understanding Classes and Objects](#chapter5part1.1)
      - [Chapter 5 - Part 1.2: Defining Classes: Attributes (Fields) and Behaviors (Methods)](#chapter5part1.2)
      - [Chapter 5 - Part 1.3: Creating Objects: Instantiating Classes](#chapter5part1.3)
      - [Chapter 5 - Part 1.4: Accessing Object Attributes and Calling Methods](#chapter5part1.4)
      - [Chapter 5 - Part 1.5: Constructors: Initializing Objects](#chapter5part1.5)
      - [Chapter 5 - Part 1.6: The this Keyword: Referring to the Current Object](#chapter5part1.6)
      - [Chapter 5 - Part 1.7: Introduction to Encapsulation: Hiding Data](#chapter5part1.7)
    - [Chapter 5 - Part 2: Understanding Classes and Objects](#chapter5part2)
      - [Chapter 5 - Part 2.1: Understanding Classes](#chapter5part2.1)
      - [Chapter 5 - Part 2.2: Creating Objects: Instantiating Classes](#chapter5part2.2)
      - [Chapter 5 - Part 2.3: Accessing Object Attributes and Calling Methods](#chapter5part2.3)
      - [Chapter 5 - Part 2.4: Constructors: Initializing Objects](#chapter5part2.4)
      - [Chapter 5 - Part 2.5: The this Keyword: Referring to the Current Object](#chapter5part2.5)
      - [Chapter 5 - Part 2.6: Introduction to Encapsulation: Hiding Data](#chapter5part2.6)
    - [Chapter 5 - Part 3: Defining Classes: Attributes (Fields) and Behaviors (Methods)](#chapter5part3)
      - [Chapter 5 - Part 3.1: Understanding Classes and Objects](#chapter5part3.1)
      - [Chapter 5 - Part 3.2: Defining Classes: Attributes (Fields)](#chapter5part3.2)
      - [Chapter 5 - Part 3.3: Defining Classes: Behaviors (Methods)](#chapter5part3.3)
      - [Chapter 5 - Part 3.4: Practical Examples and Demonstrations](#chapter5part3.4)
    - [Chapter 5 - Part 4: Creating Objects: Instantiating Classes](#chapter5part4)
      - [Chapter 5 - Part 4.1: Understanding Object Instantiation](#chapter5part4.1)
      - [Chapter 5 - Part 4.2: Practical Examples and Demonstrations](#chapter5part4.2)
    - [Chapter 5 - Part 5: Accessing Object Attributes and Calling Methods](#chapter5part5)
      - [Chapter 5 - Part 5.1: Accessing Object Attributes](#chapter5part5.1)
      - [Chapter 5 - Part 5.2: Calling Methods](#chapter5part5.2)
    - [Chapter 5 - Part 6: Constructors: Initializing Objects](#chapter5part6)
      - [Chapter 5 - Part 6.1: Understanding Constructors](#chapter5part6.1)
      - [Chapter 5 - Part 6.2: Default Constructor (No-Argument Constructor)](#chapter5part6.2)
      - [Chapter 5 - Part 6.3: Parameterized Constructor](#chapter5part6.3)
      - [Chapter 5 - Part 6.4: The this Keyword](#chapter5part6.4)
      - [Chapter 5 - Part 6.5: Practical Examples and Demonstrations](#chapter5part6.5)
      - [Chapter 5 - Part 6.8: Next Steps and Future Learning Directions](#chapter5part6.8)
    - [Chapter 5 - Part 7: The `this` Keyword: Referring to the Current Object](#chapter5part7)
      - [Chapter 5 - Part 7.1: Understanding the this Keyword](#chapter5part7.1)
      - [Chapter 5 - Part 7.2: Practical Examples and Demonstrations](#chapter5part7.2)
    - [Chapter 5 - Part 8: Introduction to Encapsulation: Hiding Data](#chapter5part8)
      - [Chapter 5 - Part 8.1: Understanding Encapsulation](#chapter5part8.1)
      - [Chapter 5 - Part 8.2: Implementing Encapsulation in Java](#chapter5part8.2)
      - [Chapter 5 - Part 8.3: Advanced Encapsulation Techniques](#chapter5part8.3)
6. [Chapter 6: Methods and Classes in Depth](#chapter6)
    - [Chapter 6 - Part 1: Method Overloading: Creating Methods with the Same Name](#chapter6part1)
      - [Chapter 6 - Part 1.1: Understanding Method Overloading](#chapter6part1.1)
      - [Chapter 6 - Part 1.2: Practical Examples and Demonstrations](#chapter6part1.2)
    - [Chapter 6 - Part 2: Method Parameters and Return Types](#chapter6part2)
      - [Chapter 6 - Part 2.1: Understanding Method Parameters](#chapter6part2.1)
      - [Chapter 6 - Part 2.2: Understanding Return Types](#chapter6part2.2)
      - [Chapter 6 - Part 2.3: Practical Examples and Demonstrations](#chapter6part2.3)
    - [Chapter 6 - Part 3: Static Variables and Methods: Class-Level Members](#chapter6part3)
      - [Chapter 6 - Part 3.1: Understanding Static Variables](#chapter6part3.1)
      - [Chapter 6 - Part 3.2: Understanding Static Methods](#chapter6part3.2)
      - [Chapter 6 - Part 3.3: Static Blocks](#chapter6part3.3)
      - [Chapter 6 - Part 3.4: Real-World Applications](#chapter6part3.4)
    - [Chapter 6 - Part 4: Understanding Access Modifiers: public, private, protected, default](#chapter6part4)
      - [Chapter 6 - Part 4.1: Understanding Access Modifiers](#chapter6part4.1)
      - [Chapter 6 - Part 4.2: Access Levels: A Summary](#chapter6part4.2)
      - [Chapter 6 - Part 4.3: Practical Examples and Demonstrations](#chapter6part4.3)
    - [Chapter 6 - Part 5: Introduction to Inheritance: Creating Hierarchies of Classes](#chapter6part5)
      - [Chapter 6 - Part 5.1: Object Class](#chapter6part5.1)
      - [Chapter 6 - Part 5.2: Understanding Inheritance](#chapter6part5.2)
      - [Chapter 6 - Part 5.3: The extends Keyword](#chapter6part5.3)
      - [Chapter 6 - Part 5.4: Method Overriding](#chapter6part5.4)
      - [Chapter 6 - Part 5.5: The super Keyword](#chapter6part5.5)
    - [Chapter 6 - Part 6: The `extends` Keyword: Inheriting from a Parent Class](#chapter6part6)
      - [Chapter 6 - Part 6.1: Understanding the extends Keyword](#chapter6part6.1)
      - [Chapter 6 - Part 6.2: Practical Examples and Demonstrations](#chapter6part6.2)
    - [Chapter 6 - Part 7: Method Overriding: Changing Inherited Behavior](#chapter6part7)
      - [Chapter 6 - Part 7.1: Understanding Method Overriding](#chapter6part7.1)
      - [Chapter 6 - Part 7.2: The super Keyword and Method Overriding](#chapter6part7.2)
      - [Chapter 6 - Part 7.3: Method Overriding vs. Method Overloading](#chapter6part7.3)
      - [Chapter 6 - Part 7.4: Practical Examples and Demonstrations](#chapter6part7.4)
    - [Chapter 6 - Part 8: The `super` Keyword: Accessing Parent Class Members](#chapter6part8)
      - [Chapter 6 - Part 8.1: Understanding the super Keyword](#chapter6part8.1)
    - [Chapter 6 - Part 9: Class Composition and Polymorphism](#chapter6part9)
      - [Chapter 6 - Part 9.1: Modifiers in Java](#chapter6part9.1)
      - [Chapter 6 - Part 9.2: Encapsulation in Java](#chapter6part9.2)
      - [Chapter 6 - Part 9.3: Classes Composition in Java](#chapter6part9.3)
      - [Chapter 6 - Part 9.4: Inheritance in Java](#chapter6part9.4)
      - [Chapter 6 - Part 9.5: Polymorphism in Java](#chapter6part9.5)
      - [Chapter 6 - Part 9.6: Abstraction Class and methods](#chapter6part9.6)
7. [Chapter 7: Exception Handling and Basic Input/Output](#chapter7)
    - [Chapter 7 - Part 1: Introduction to Exception Handling: Dealing with Errors](#chapter7part1)
      - [Chapter 7 - Part 1.1: Understanding Exceptions](#chapter7part1.1)
      - [Chapter 7 - Part 1.2: The try-catch Block: Handling Exceptions](#chapter7part1.2)
      - [Chapter 7 - Part 1.3: Common Exception Types](#chapter7part1.3)
      - [Chapter 7 - Part 1.4: Best Practices for Exception Handling](#chapter7part1.4)
    - [Chapter 7 - Part 2: The `try-catch` Block: Handling Exceptions](#chapter7part2)
      - [Chapter 7 - Part 2.1: Understanding Exceptions](#chapter7part2.1)
      - [Chapter 7 - Part 2.2: The try-catch Block: A Detailed Explanation](#chapter7part2.2)
      - [Chapter 7 - Part 2.3: Best Practices for Using try-catch Blocks](#chapter7part2.3)
    - [Chapter 7 - Part 3: The `finally` Block: Ensuring Code Executes](#chapter7part3)
      - [Chapter 7 - Part 3.1: Understanding the finally Block](#chapter7part3.1)
      - [Chapter 7 - Part 3.2: Practical Examples of Using finally](#chapter7part3.2)
      - [Chapter 7 - Part 3.3: Best Practices and Considerations](#chapter7part3.3)
    - [Chapter 7 - Part 4: Common Exception Types: NullPointerException, ArrayIndexOutOfBoundsException](#chapter7part4)
      - [Chapter 7 - Part 4.1: Understanding Exceptions](#chapter7part4.1)
      - [Chapter 7 - Part 4.2: The NullPointerException](#chapter7part4.2)
      - [Chapter 7 - Part 4.3: The ArrayIndexOutOfBoundsException](#chapter7part4.3)
    - [Chapter 7 - Part 5: Custom Exceptions](#chapter7part5)
      - [Chapter 7 - Part 5.1: What is Custom Exception](#chapter7part5.1)
      - [Chapter 7 - Part 5.2: Creating Custom Exceptions](#chapter7part5.2)
    - [Chapter 7 - Part 6: Reading Input from the Console: Using the `Scanner` Class](#chapter7part6)
      - [Chapter 7 - Part 6.1: Introduction to the Scanner Class](#chapter7part6.1)
      - [Chapter 7 - Part 6.2: Reading Different Data Types](#chapter7part6.2)
      - [Chapter 7 - Part 6.3: Handling Input Mismatch Exceptions](#chapter7part6.3)
      - [Chapter 7 - Part 6.4: Practical Examples and Demonstrations](#chapter7part6.4)
    - [Chapter 7 - Part 7: Writing Output to the Console: Using `System.out.println()`](#chapter7part7)
      - [Chapter 7 - Part 7.1: Understanding System.out.println()](#chapter7part7.1)
      - [Chapter 7 - Part 7.2: Practical Examples and Demonstrations](#chapter7part7.2)
    - [Chapter 7 - Part 8: Introduction to File Input/Output: Reading and Writing Text Files](#chapter7part8)
      - [Chapter 7 - Part 8.1: Understanding File Input/Output (I/O)](#chapter7part8.1)
      - [Chapter 7 - Part 8.2: Reading Text Files](#chapter7part8.2)
      - [Chapter 7 - Part 8.3: Writing Text Files](#chapter7part8.3)
8. [Chapter 8: Java Date and Time](#chapter8)
    - [Chapter 8 - Part 1: Java Date and Time](#chapter8part1)
9. [Chapter 9: Java Enums](#chapter9)
    - [Chapter 9 - Part 1: Java Enums](#chapter9part1)
10. [Chapter 10: Reference Type vs. Value Types, Garbage Collector, Boxing, unboxing and wrapper classes](#chapter10)
    - [Chapter 10 - Part 1: Reference Type vs. Value Types](#chapter8part1)
    - [Chapter 10 - Part 2: Garbage Collector](#chapter8part2)
    - [Chapter 10 - Part 3:  Boxing, unboxing and wrapper classes](#chapter8part3)
    - [Chapter 10 - Part 4:  hashCode and equals](#chapter8part4)
11. [Chapter 11: Java Interfaces](#chapter14)
    - [Chapter 11 - Part 1: Java Interfaces](#chapter11part1)
    - [Chapter 11 - Part 2: Dependency Injection and Inversion of Control](#chapter11part2)
    - [Chapter 11 - Part 3: Inheritance vs Interfaces](#chapter11part3)
    - [Chapter 11 - Part 4: Multiple Inheritance and Interfaces](#chapter11part4)
    - [Chapter 11 - Part 5: Comparable Interface](#chapter11part5)
    - [Chapter 11 - Part 6: Default methods](#chapter11part6)
12. [Chapter 12: Collections](#chapter12)
    - [Chapter 12 - Part 1: ArrayList](#chapter12part1)
    - [Chapter 12 - Part 2: HashMap](#chapter12part2)
    - [Chapter 12 - Part 3: HashSet](#chapter12part3)
13. [Chapter 13: Java Lambda Expression](#chapter13)
    - [Chapter 13 - Part 1: Java Lambda Expression](#chapter13part1)
   
|               |                 |                 |                 |                 |                 |                 |                 |                 | 
| :-----------: | :-------------: | :-------------: | :-------------: | :-------------: | :-------------: | :-------------: | :-------------: | :-------------: |
|               |                 |                 |                 |                 |                 |                 |                 |                 |
|               |                 |                 |                 |                 |                 |                 |                 |                 |
|               |                 |                 |                 |                 |                 |                 |                 |                 |
|               |                 |                 |                 |                 |                 |                 |                 |                 |

## <a name="chapter1"></a>Chapter 1: Introduction to Java and Setting Up Your Environment

#### <a name="chapter1part1"></a>Chapter 1 - Part 1: What is Java and Why Learn It?

Java's enduring presence in the software development landscape makes it a crucial language to learn, especially for aspiring programmers. Its versatility, platform independence, and vast ecosystem contribute to its widespread use in enterprise applications, mobile development (Android), web applications, and more. Understanding the core principles of Java and its advantages will provide a solid foundation for building robust and scalable software solutions. This lesson will explore what Java is, its key features, and the reasons why it remains a relevant and valuable skill in today's technology-driven world.

#### <a name="chapter1part1.1"></a>Chapter 1 - Part 1.1: What is Java?

Java is a high-level, class-based, object-oriented programming language that is designed to have as few implementation dependencies as possible. It is a general-purpose programming language intended to let application developers write once, run anywhere (WORA), meaning that compiled Java code can run on all platforms that support Java without the need for recompilation. Java applications are typically compiled to bytecode that can run on any Java Virtual Machine (JVM) regardless of the underlying computer architecture.

**Key Features of Java**

- **Object-Oriented**: Java is built around the concepts of objects, classes, inheritance, and polymorphism. This allows for modular, reusable, and maintainable code.
- **Platform Independent**: The "write once, run anywhere" principle is a cornerstone of Java. Java achieves this through the JVM, which acts as an intermediary between the Java code and the underlying operating system.
- **Robust**: Java has strong memory management and automatic garbage collection, preventing memory leaks and improving application stability. It also incorporates exception handling to manage runtime errors gracefully.
- **Secure**: Java provides built-in security features, such as bytecode verification and security managers, to protect against malicious code.
- **Multithreaded**: Java supports multithreading, allowing multiple threads of execution to run concurrently within a single program. This enables the development of responsive and scalable applications.
- **High Performance**: Java's performance has improved significantly over the years with advancements in JVM technology and just-in-time (JIT) compilers.
- **Dynamic**: Java is a dynamic language that supports dynamic class loading and reflection, allowing programs to load and inspect classes at runtime.

**Java Editions**

Java is available in different editions to cater to various development needs:

- **Java Standard Edition (Java SE)**: The foundation of the Java platform, providing the core libraries and APIs for developing general-purpose applications. This is what we will be focusing on in this course.
- **Java Enterprise Edition (Java EE)**: Built on top of Java SE, providing additional APIs and runtime environments for developing enterprise-level applications, such as web applications and distributed systems.
- **Java Micro Edition (Java ME)**: Designed for developing applications for embedded systems and mobile devices.

#### <a name="chapter1part1.2"></a>Chapter 1 - Part 1.2: Why Learn Java?

Java's widespread adoption and rich ecosystem make it a valuable skill for software developers. Here are some compelling reasons to learn Java:

**High Demand in the Job Market**

Java developers are in high demand across various industries. Many companies rely on Java for building and maintaining their enterprise applications, web applications, and Android mobile apps. Learning Java can open doors to numerous job opportunities with competitive salaries.

**Versatility and Portability**

Java's platform independence allows developers to write code once and run it on any platform that supports the JVM. This versatility makes Java suitable for developing a wide range of applications, from desktop applications to web applications to mobile apps.

**Large and Active Community**

Java has a large and active community of developers who contribute to its growth and provide support to fellow developers. This community offers a wealth of resources, including online forums, tutorials, and open-source libraries, making it easier to learn and use Java.

**Extensive Libraries and Frameworks**

Java boasts a rich collection of libraries and frameworks that simplify the development process and provide pre-built components for common tasks. Some popular Java frameworks include Spring, Hibernate, and Struts.

**Android App Development**

Java is the primary language for developing Android mobile apps. Learning Java is essential for anyone who wants to build apps for the Android platform, which has a massive user base worldwide.

**Enterprise Application Development**

Java is widely used in enterprise application development due to its scalability, reliability, and security features. Many large organizations rely on Java for building their mission-critical systems.

**Real-World Examples**

- **Enterprise Applications**: Large financial institutions and e-commerce companies use Java to build their backend systems, handle transactions, and manage customer data.
- **Android Mobile Apps**: Popular apps like Spotify, Twitter, and many games are built using Java (or Kotlin, which is fully interoperable with Java) for the Android platform.
- **Web Applications**: Many web applications, including those used for online banking, e-learning platforms, and social media, are built using Java frameworks like Spring.

#### <a name="chapter1part2"></a>Chapter 1 - Part 2: Understanding the Java Ecosystem: JVM, JRE, JDK

The Java ecosystem is a crucial foundation for understanding how Java code runs and interacts with your computer. It's comprised of three core components: the Java Virtual Machine (JVM), the Java Runtime Environment (JRE), and the Java Development Kit (JDK). Each plays a distinct role in the development and execution of Java applications. Understanding these components is essential for any Java developer, as it allows you to troubleshoot issues, optimize performance, and choose the right tools for your projects. This lesson will provide a comprehensive overview of each component, their relationships, and their significance in the Java development process.

#### <a name="chapter1part2.1"></a>Chapter 1 - Part 2.1: Compilation and Interpretation, Source Code and Object Code, Virtual Machine

The Basic operations of a computer is Input of Data, Processing of Data and the output of the result or data.

The processing is made by the CPU

<br>

<div align="center"><img src="img/basic-operations-computer-w562-h190.gif" width=562 height=190><br><sub>Fig 15 -Basic Operations of a Computer - (<a href='http://cs.sru.edu/~mullins/cpsc100book/module02_introduction/module02-04_introduction.html'>Work by Paul Mullins</a>) </sub></div>

<br>

**Source Code**: is the code written by the programmer in a programming language

Ex:

```java
package application;

import java.util.Scanner;
import java.util.Locale;

public class Program {

	public static void main(String[] args) {
		
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
        	double x, y, media;
        
		System.out.print("Enter the First Number: ");
        	x = sc.nextDouble(); //input: 2
        	System.out.print("Enter the Second Number: ");
        	y = sc.nextDouble(); //input: 4
        
        	media = (x + y)/2.0;
        
       		System.out.println("Media = " + media);
        	sc.close();
	}
}

/*
Console

----input---
Enter the First Number: 2.0
Enter the First Number: 4.0

----output---
Media = 3.0
*/
```
<br>

<div align="center"><img src="img/compilation-interpretation-w1353-h638.png" width=1000 height=500><br><sub>Fig 1 - Compilation and Interpretation Process</sub></div>

<br>

<div align="center"><img src="img/hybrid-w1079-h395.png" width=1300 height=500><br><sub>Fig 2 - Hybrid Process</sub></div>

<br>

- **Compilation**:
	- Program Speed
	- Compiler Assistance Before Execution
	- Disadvantage: Platform dependence of the generated binary code

- **Interpretation**:
	- Flexibility of Maintaining the Application in Production
	- Expressiveness of Language
	- Source Code does not need to be Recompiled to run on different platform
	- Disadvantage: Execution speed compared to compiled languages.

- **Hybrid**:
	- Compiler Assistance Before Execution
	- Source Code does not need to be Recompiled to run on different platform

#### <a name="chapter1part2.2"></a>Chapter 1 - Part 2.2: The Java Virtual Machine (JVM)

JVM is the Java Virtual Machine to execute Java Programs in your system.

Java take the advantages of compilation and interpretation and create the hybrid interpretation with JVM.

Below, there some of compilation process examples in Java:

<br>

<div align="center"><img src="img/java-compiler-process-w700-h676.png" width=700 height=676><br><sub>Fig 3 - Compilation Process in Java - (<a href='https://medium.com/@PrayagBhakar/lesson-2-behind-the-scenes-4df6a461f31f'>Work by Prayag Bhakar</a>) </sub></div>

<br>

<div align="center"><img src="img/java-compiler-process2-w487-h317.png" width=487 height=317><br><sub>Fig 4 - Compilation Process in Java - (<a href='https://www3.ntu.edu.sg/home/ehchua/programming/java/J1a_Introduction.html'>Work by Chua Hock-Chuan</a>) </sub></div>

<br>

<div align="center"><img src="img/java-compiler-process3-w612-h242.png" width=612 height=242><br><sub>Fig 5 - Compilation Process in Java - (<a href='https://www.w3schools.in/java-tutorial/compile-java-file-using-javac/'>Work by  w3schools</a>) </sub></div>

<br>

The process to execute the bytecode is called JIT (Just in Time) Compilation. Is more faster than interpretation because the compiler revise before the run time, if the bytecode is lexical and syntactical correct.

<br>

<div align="center"><img src="img/java-compiler-process4-w557-h617.png" width=557 height=617><br><sub>Fig 6 - Compilation Process in Java - (<a href='http://javaeesupportpatterns.blogspot.com/2013/07/java-just-in-time-compilation-more-than.html'>Work by javaeesupportpatterns</a>) </sub></div>

<br>

The Java Virtual Machine (JVM) is the heart of the Java platform. It's an abstract computing machine, meaning it's a specification that can be implemented in different ways by different vendors. The JVM's primary role is to execute Java bytecode.

**What is Bytecode?**

When you write Java code, it's saved in .java files. These files are then compiled by the Java compiler (javac) into .class files. These .class files contain bytecode, which is a platform-independent set of instructions that the JVM can understand and execute.

Example:

Let's say you have a simple Java program:

```java
public class Example {
    public static void main(String[] args) {
        int x = 10;
        int y = 5;
        int sum = x + y;
        System.out.println("Sum: " + sum);
    }
}
```

After compiling this code, the Example.class file will contain bytecode instructions that tell the JVM how to perform the addition and print the result. You can inspect the bytecode using the javap command-line tool (part of the JDK): javap -c Example. The output will be assembly-like instructions.

**Key Functions of the JVM**

- **Loading Bytecode**: The JVM loads .class files containing bytecode into memory.
- **Bytecode Verification**: Before executing bytecode, the JVM verifies that it's valid and doesn't violate any security constraints. This helps prevent malicious code from harming the system.
- **Execution**: The JVM executes the bytecode instructions. This can be done through interpretation or just-in-time (JIT) compilation.
- **Just-in-Time (JIT) Compilation**: The JIT compiler is a part of the JVM that translates bytecode into native machine code during runtime. This significantly improves performance because native code executes much faster than interpreted bytecode. The JIT compiler analyzes the bytecode and identifies frequently executed sections (hotspots) to optimize.
- **Memory Management**: The JVM automatically manages memory through garbage collection. It allocates memory for objects and reclaims memory that is no longer in use, preventing memory leaks.

**JVM Implementations**

Different vendors provide their own implementations of the JVM specification. Some popular JVM implementations include:

- **HotSpot**: Developed by Oracle, HotSpot is the most widely used JVM. It's known for its advanced JIT compilation and garbage collection capabilities.
- **OpenJ9**: Developed by Eclipse, OpenJ9 is another high-performance JVM that's designed for cloud environments.
- **GraalVM**: A polyglot VM that supports multiple languages, including Java. GraalVM can also compile Java code ahead-of-time (AOT) for faster startup times.

**Platform Independence**

The JVM is what makes Java platform-independent. Because the bytecode is executed by the JVM, the same Java code can run on any operating system that has a JVM implementation. This "write once, run anywhere" (WORA) capability is a key advantage of Java.

Example:

You can compile your Java code on a Windows machine and then run the resulting .class files on a Linux server, as long as both machines have a compatible JVM installed.

**Hypothetical Scenario**

Imagine a company developing a cross-platform application that needs to run on Windows, macOS, and Linux. By using Java, they can write the application once and deploy it to all three platforms without having to rewrite the code for each operating system. The JVM handles the platform-specific details, allowing the developers to focus on the application logic.

#### <a name="chapter1part2.3"></a>Chapter 1 - Part 2.3: The Java Runtime Environment (JRE)

The Java Runtime Environment (JRE) provides the necessary resources to run Java applications. It includes the JVM, along with libraries and other components needed to execute Java bytecode.

**Components of the JRE**

- **JVM**: As mentioned earlier, the JVM is the core component of the JRE.
- **Java Class Libraries**: The JRE includes a set of standard Java class libraries that provide pre-built functionality for common tasks, such as input/output, networking, and data structures. These libraries are essential for developing Java applications.
- **Other Supporting Files**: The JRE also includes other supporting files, such as configuration files and security policies.

**JRE vs. JVM**

It's important to understand the difference between the JRE and the JVM. The JVM is the abstract specification for executing bytecode, while the JRE is a concrete implementation of that specification, along with the necessary libraries and supporting files. You can think of the JRE as a package that contains the JVM and everything else needed to run Java applications.

Analogy:

Think of the JVM as an engine and the JRE as the entire car. The engine (JVM) is responsible for running the car, but the car (JRE) also includes the wheels, seats, and other components needed to make it functional.

**Using the JRE**

When you want to run a Java application, you need to have the JRE installed on your system. The JRE provides the java command, which you use to launch Java applications.

Example:

To run a Java application named MyApp.class, you would use the following command:

```
java MyApp
```

This command tells the JRE to load the MyApp.class file, start the JVM, and execute the bytecode in the file.

**Real-World Example**

Consider a web server that hosts Java-based web applications. The server needs to have the JRE installed to run these applications. When a user accesses a web page that requires Java code to be executed, the JRE on the server handles the execution of that code.

**Hypothetical Scenario**

A small business uses a Java-based accounting application. Each employee who needs to use the application must have the JRE installed on their computer. The JRE allows them to run the application and access the company's financial data.

#### <a name="chapter1part2.4"></a>Chapter 1 - Part 2.4: The Java Development Kit (JDK)

The Java Development Kit (JDK) is a superset of the JRE. It includes everything in the JRE, plus additional tools and utilities needed for developing Java applications.

**Components of the JDK**

- **JRE**: The JDK includes the complete JRE.
- **Java Compiler (javac)**: The javac compiler translates Java source code (.java files) into bytecode (.class files).
- **Java Debugger (jdb)**: The jdb debugger allows you to debug Java code by stepping through the code, inspecting variables, and setting breakpoints.
- **Java Archive (jar)**: The jar tool allows you to package Java class files and resources into a single archive file (.jar file).
- **Java Documentation Generator (javadoc)**: The javadoc tool generates HTML documentation from Java source code comments.
- **Other Development Tools**: The JDK also includes other development tools, such as jconsole (for monitoring JVM performance) and jprofiler (for profiling Java applications).

**JDK vs. JRE**

The key difference between the JDK and the JRE is that the JDK is for developers, while the JRE is for users who just want to run Java applications. If you want to write, compile, and debug Java code, you need the JDK. If you just want to run Java applications, you only need the JRE.

Analogy:

Think of the JDK as a mechanic's toolkit and the JRE as the car itself. The mechanic (developer) needs the toolkit (JDK) to build and repair cars, while the driver (user) only needs the car (JRE) to drive.

**Using the JDK**

When you install the JDK, you get access to the javac compiler, which you use to compile your Java code.

Example:

To compile the Example.java file, you would use the following command:

```
javac Example.java
```

This command creates the Example.class file containing the bytecode.

**Real-World Example**

A software development company uses the JDK to develop and maintain its Java-based applications. The developers use the javac compiler to compile the code, the jdb debugger to debug the code, and the jar tool to package the applications for deployment.

**Hypothetical Scenario**

A student learning Java needs to install the JDK on their computer to write and run Java programs. The JDK provides the necessary tools for compiling, debugging, and testing their code.

#### <a name="chapter1part2.5"></a>Chapter 1 - Part 2.5: Relationship Between JVM, JRE, and JDK

The JVM, JRE, and JDK are closely related. The JDK includes the JRE, and the JRE includes the JVM.

```
JDK (Java Development Kit)
  |
  +-- JRE (Java Runtime Environment)
      |
      +-- JVM (Java Virtual Machine)
```

- The JDK is the complete development environment for Java applications.
- The JRE is the runtime environment for executing Java applications.
- The JVM is the virtual machine that executes Java bytecode.

#### <a name="chapter1part2.6"></a>Chapter 1 - Part 2.6: Choosing the Right Version

When installing the JDK or JRE, you'll need to choose a version. Oracle releases new versions of Java regularly, and each version may include new features, performance improvements, and security updates. It's generally recommended to use the latest stable version of the JDK or JRE, unless you have a specific reason to use an older version.

**Long-Term Support (LTS) Versions**

Oracle designates certain Java versions as Long-Term Support (LTS) versions. LTS versions receive extended support and security updates, making them a good choice for production environments. As of this writing, Java 11 and Java 17 are LTS versions.

**Considerations**

- **Compatibility**: Make sure that the version of the JDK or JRE you choose is compatible with your applications and libraries.
- **New Features**: Consider whether you need the new features and improvements offered by the latest version.
- **Support**: Choose an LTS version for long-term stability and support.

#### <a name="chapter1part3"></a>Chapter 1 - Part 3: Installing the Java Development Kit (JDK)

Installing the Java Development Kit (JDK) is the first crucial step in your journey to becoming a Java programmer. The JDK provides the necessary tools to compile, run, and debug Java code. Without it, you won't be able to execute the programs you write. This lesson will guide you through the process of downloading and installing the JDK on your system, ensuring you have a solid foundation for the rest of the course.

#### <a name="chapter1part3.1"></a>Chapter 1 - Part 3.1: Understanding the JDK and its Components

The Java JDK come with some of most used packages to help the developer like awt, beans, io, lang, math, net, nio, sql, util and each package have a class or a interface.

<br>

<div align="center"><img src="img/packages-jdk-w646-h292.png" width=646 height=292><br><sub>Fig 8 -Java Packages - (<a href='http://www.wellnwill.com/tutorial/core-java/package/package'>Work by Well N Will</a>) </sub></div>

<br>

Oracle have a documentation about all his packages: https://docs.oracle.com/javase/8/docs/api/

<br>

<div align="center"><img src="img/packages-jdk2-w788-h483.png" width=788 height=483><br><sub>Fig 9 -Java Packages - (<a href='https://docs.oracle.com/javase/8/docs/technotes/guides/desc_jdk_structure.html'>Work by Oracle</a>) </sub></div>

<br>

One of the most famous used packages is java.util.collections and java.util.map

<br>

<div align="center"><img src="img/packages-jdk4-w1512-h1252.png" width=500 height=400><br><sub>Fig 10 -Java Packages - (<a href='https://ukode.es/colecciones-i-introduccion-y-conceptos-basicos/'>Work by Jose Antonio Simón</a>) </sub></div>

<br>

<div align="center"><img src="img/packages-jdk3-w1720-h693.png" width=700 height=300><br><sub>Fig 11 -Java Packages - (<a href='https://ukode.es/colecciones-i-introduccion-y-conceptos-basicos/'>Work by Jose Antonio Simón</a>) </sub></div>

<br>

<div align="center"><img src="img/packages-jdk5-w854-h715.png" width=854 height=715><br><sub>Fig 12 -Java Packages - (<a href='https://www.javatpoint.com/collections-in-java'>Work by JavaPoint</a>) </sub></div>

<br>

The Java Development Kit (JDK) is a software development environment used for developing Java applications. It includes the Java Runtime Environment (JRE), compilers, debuggers, and other tools necessary for developing, testing, and running Java programs.

**Key Components of the JDK**

- **Java Runtime Environment (JRE)**: The JRE provides the runtime environment in which Java programs can execute. It includes the Java Virtual Machine (JVM), core classes, and supporting files. You encountered the JRE in the previous lesson when learning about the Java ecosystem.
- **Java Compiler (javac)**: This tool compiles Java source code (.java files) into bytecode (.class files) that can be executed by the JVM.
- **Java Debugger (jdb)**: This tool helps you find and fix errors in your Java code.
- **Java Archive (jar)**: This tool packages Java class files and related resources into a single archive file.
- **Other Tools**: The JDK also includes other useful tools such as javadoc (for generating API documentation) and jps (for listing running Java processes).

**Why is the JDK Necessary?**

The JDK is essential because it provides the tools needed to translate human-readable Java code into machine-executable bytecode. Without the JDK, you can't compile your code, and therefore, you can't run it. The JRE alone is sufficient for running pre-compiled Java applications, but the JDK is required for developing them.

#### <a name="chapter1part3.2"></a>Chapter 1 - Part 3.2: Downloading the JDK

The JDK can be downloaded from several sources, but the most common and recommended source is Oracle. Alternatively, you can use OpenJDK builds from vendors like Adoptium (Eclipse Temurin).

**Downloading from Oracle**

- **Visit the Oracle Website**: Go to the Oracle Java SE Downloads page.
- **Choose the Appropriate Version**: Select the latest Long-Term Support (LTS) version of Java. LTS versions are supported for a longer period, making them a stable choice for development.
- **Select Your Operating System**: Choose the appropriate installer for your operating system (Windows, macOS, or Linux).
- **Download the Installer**: Download the installer file. You may need to create an Oracle account to proceed with the download.

**Downloading from Adoptium (Eclipse Temurin)**

- **Visit the Adoptium Website**: Go to the Adoptium website.
- **Choose the Appropriate Version**: Select the latest LTS version of Java.
- **Select Your Operating System**: Choose the appropriate installer for your operating system (Windows, macOS, or Linux).
- **Download the Installer**: Download the installer file.

#### <a name="chapter1part3.3"></a>Chapter 1 - Part 3.3: Installing the JDK

The installation process varies slightly depending on your operating system.

**Installing on Windows**

- **Run the Installer**: Double-click the downloaded installer file to start the installation process.

- **Follow the Prompts**: Follow the on-screen instructions. You'll typically be prompted to choose an installation directory. The default location is usually fine.

- **Set the JAVA_HOME Environment Variable**:
  - Open the System Properties window (search for "environment variables" in the Start menu).
  - Click "Environment Variables".
  - Under "System variables", click "New".
  - Enter JAVA_HOME as the variable name.
  - Enter the installation directory of the JDK as the variable value (e.g., C:\Program Files\Java\jdk-17).
  - Click "OK" to close all windows.
 
- **Update the Path Environment Variable**:
  - In the System Variables section, find the Path variable and select it, then click "Edit".
  - Click "New" and add %JAVA_HOME%\bin to the list.
  - Click "OK" to close all windows.
 
- **Verify the Installation**: Open a new command prompt window and type java -version. You should see the version information for the installed JDK.

**Installing on macOS**

- **Run the Installer**: Double-click the downloaded .dmg file to mount it.

- **Open the Package**: Double-click the .pkg file to start the installation process.

- **Follow the Prompts**: Follow the on-screen instructions. The JDK will typically be installed in /Library/Java/JavaVirtualMachines/.

- **Set the JAVA_HOME Environment Variable (Optional)**: While macOS doesn't strictly require setting JAVA_HOME, some tools might rely on it. You can set it in your .bash_profile or .zshrc file:
  - Open Terminal.
  - Type nano ~/.zshrc (or nano ~/.bash_profile if you're using Bash).
  - Add the following lines:

```
export JAVA_HOME=$(/usr/libexec/java_home)
export PATH=$JAVA_HOME/bin:$PATH
```

  - Press Ctrl+X, then Y, then Enter to save and exit.
  - Type source ~/.zshrc (or source ~/.bash_profile) to apply the changes.

- **Verify the Installation**: Open a new Terminal window and type java -version. You should see the version information for the installed JDK.

**Installing on Linux**

The installation process on Linux varies depending on the distribution. Here are instructions for Debian/Ubuntu and Fedora/CentOS.

**Debian/Ubuntu**

- **Download the .deb Package**: Download the .deb package for your architecture.

- **Install the Package**: Open a terminal and navigate to the directory where you downloaded the package. Then, run the following command:

```
sudo apt install ./<package_name>.deb
```

Replace <package_name>.deb with the actual name of the downloaded file.

- **Set the JAVA_HOME Environment Variable**:
  - Open the /etc/environment file with root privileges:
 
```
sudo nano /etc/environment
```

  - Add the following line, replacing /usr/lib/jvm/java-17-openjdk-amd64 with the actual path to your JDK installation:

```
JAVA_HOME="/usr/lib/jvm/java-17-openjdk-amd64"
```

  - Save the file and exit.
  - Apply the changes by running:

```
source /etc/environment
```

- **Update the Path Environment Variable**:

  - Edit the ~/.bashrc or ~/.zshrc file:
 
```
nano ~/.bashrc
```

  - Add the following lines:

```
export PATH="$JAVA_HOME/bin:$PATH"
```

- Save the file and exit.
- Apply the changes by running:

```
source ~/.bashrc
```

- **Verify the Installation**: Open a new terminal window and type java -version. You should see the version information for the installed JDK.

**Fedora/CentOS**

- **Download the .rpm Package**: Download the .rpm package for your architecture.

- **Install the Package**: Open a terminal and navigate to the directory where you downloaded the package. Then, run the following command:

```
sudo rpm -i <package_name>.rpm
```

Replace <package_name>.rpm with the actual name of the downloaded file.

- **Set the JAVA_HOME Environment Variable**:
  
  - Open the /etc/environment file with root privileges:
 
```
sudo nano /etc/environment
```

  - Add the following line, replacing /usr/lib/jvm/java-17-openjdk-amd64 with the actual path to your JDK installation:

```
JAVA_HOME="/usr/lib/jvm/java-17-openjdk-amd64"
```

- Save the file and exit.
- Apply the changes by running:

```
source /etc/environment
```

- **Update the Path Environment Variable**:
  - Edit the ~/.bashrc or ~/.zshrc file:
 
```
nano ~/.bashrc
```

  - Add the following lines:

```
export PATH="$JAVA_HOME/bin:$PATH"
```

- Save the file and exit.
- Apply the changes by running:

```
source ~/.bashrc
```

- **Verify the Installation**: Open a new terminal window and type java -version. You should see the version information for the installed JDK.

#### <a name="chapter1part3.4"></a>Chapter 1 - Part 3.4: Setting Environment Variables

Setting environment variables is a crucial step in the installation process. These variables tell your operating system where to find the Java executables.

**Why are Environment Variables Important?**

Environment variables allow you to run Java commands from any directory in your terminal or command prompt. Without them, you would have to navigate to the JDK's bin directory every time you want to compile or run a Java program.

```**JAVA_HOME**```

The JAVA_HOME variable points to the installation directory of the JDK. This variable is used by many Java-based tools and applications to locate the JDK.

```**Path**```

The Path variable is a list of directories that the operating system searches when you execute a command. By adding the JDK's bin directory to the Path, you can run Java commands like java and javac from any directory.

#### <a name="chapter1part3.5"></a>Chapter 1 - Part 3.5: Verifying the Installation

After installing the JDK and setting the environment variables, it's important to verify that the installation was successful.

**Using the Command Line**

Open a new command prompt or terminal window and type the following command:

```
java -version
```

If the JDK is installed correctly, you should see output similar to the following:

```
java 17.0.2 2022-01-18 LTS
Java(TM) SE Runtime Environment (build 17.0.2+8-LTS-86)
Java HotSpot(TM) 64-Bit Server VM (build 17.0.2+8-LTS-86, mixed mode, sharing)
```

This output confirms that the Java runtime environment is installed and accessible.

Next, type the following command:

```
javac -version
```

If the JDK is installed correctly, you should see output similar to the following:

```
javac 17.0.2
```

This output confirms that the Java compiler is installed and accessible.

If you don't see this output, double-check that you have set the JAVA_HOME and Path environment variables correctly and that you have opened a new command prompt or terminal window after setting them.

#### <a name="chapter1part3.6"></a>Chapter 1 - Part 3.6: Troubleshooting Common Installation Issues

Even with careful instructions, installation issues can arise. Here are some common problems and their solutions:

**```java``` or ```javac``` Command Not Found**

This usually indicates that the Path environment variable is not set correctly. Double-check that you have added the JDK's bin directory to the Path and that you have opened a new command prompt or terminal window.

**Incorrect Java Version**

If you have multiple versions of Java installed on your system, the java -version command might show the wrong version. Ensure that the JAVA_HOME variable points to the correct JDK installation directory.

**Installation Errors**

If you encounter errors during the installation process, consult the JDK documentation or search online for solutions specific to your operating system and the error message you received.

#### <a name="chapter1part4"></a>Chapter 1 - Part 4: Setting Up a Java Development Environment (IDE): IntelliJ IDEA or Eclipse

Setting up a Java Development Environment (IDE) is a crucial step for any aspiring Java programmer. An IDE provides a comprehensive suite of tools that streamline the coding process, making it easier to write, debug, and run Java applications. This lesson will guide you through the process of setting up two popular IDEs: IntelliJ IDEA and Eclipse. We'll explore their key features, installation procedures, and basic configurations to get you ready to write your first Java programs.

#### <a name="chapter1part4.1"></a>Chapter 1 - Part 4.1: Understanding Integrated Development Environments (IDEs)

An Integrated Development Environment (IDE) is a software application that provides comprehensive facilities to computer programmers for software development. An IDE normally consists of at least a source code editor, build automation tools, and a debugger.

**Key Features of an IDE**

- **Source Code Editor**: A text editor designed specifically for writing and editing code, with features like syntax highlighting, code completion, and code formatting.
- **Build Automation Tools**: Tools that automate the process of compiling, linking, and packaging code into executable programs.
- **Debugger**: A tool that allows developers to step through code, inspect variables, and identify and fix errors.
- **Compiler**: Translates human-readable code into machine-executable code.
- **Interpreter**: Executes code line by line.
- **Version Control Integration**: Integration with version control systems like Git, allowing developers to track changes to their code and collaborate with others.
- **Testing Tools**: Tools for writing and running unit tests and integration tests.
- **Refactoring Tools**: Tools for restructuring code without changing its behavior, making it easier to maintain and improve.

**Why Use an IDE?**

Using an IDE offers several advantages over using a simple text editor and command-line tools:

- **Increased Productivity**: IDEs automate many common tasks, such as compiling code, running tests, and debugging, which can save developers a significant amount of time.
- **Improved Code Quality**: IDEs provide features like syntax highlighting, code completion, and code formatting, which can help developers write cleaner, more readable code.
- **Easier Debugging**: IDEs provide powerful debugging tools that allow developers to step through code, inspect variables, and identify and fix errors more easily.
- **Better Collaboration**: IDEs integrate with version control systems, making it easier for developers to collaborate on projects.

#### <a name="chapter1part4.2"></a>Chapter 1 - Part 4.2: IntelliJ IDEA

IntelliJ IDEA is a popular Java IDE known for its intelligent code assistance, comprehensive feature set, and user-friendly interface. It is developed by JetBrains and is available in two editions: Community (free and open-source) and Ultimate (commercial). For beginners, the Community Edition is sufficient.

**Installing IntelliJ IDEA**

- **Download IntelliJ IDEA**: Go to the JetBrains website (https://www.jetbrains.com/idea/download/) and download the Community Edition for your operating system (Windows, macOS, or Linux).

- **Run the Installer**: Once the download is complete, run the installer and follow the on-screen instructions.

- **Installation Options**: During the installation process, you may be prompted to configure some options, such as:
  - **Installation Location**: Choose the directory where you want to install IntelliJ IDEA.
  - **Create Desktop Shortcut**: Create a shortcut on your desktop for easy access to IntelliJ IDEA.
  - **Update PATH variable (restart needed)**: Add IntelliJ IDEA's bin folder to your system's PATH variable, allowing you to run IntelliJ IDEA from the command line.
  - **Associate .java**: Associate .java files with IntelliJ IDEA, so that double-clicking a .java file will open it in IntelliJ IDEA.
 
- **Complete the Installation**: Once you have configured the options, click "Install" to begin the installation process.

- **Run IntelliJ IDEA**: After the installation is complete, you can run IntelliJ IDEA from the Start menu (Windows) or the Applications folder (macOS).

**Configuring IntelliJ IDEA**

- **Import Settings (Optional)**: If you have used IntelliJ IDEA before, you can import your settings from a previous installation. Otherwise, choose "Do not import settings."
- **UI Theme**: Choose a UI theme (e.g., Light or Dark).
- **Featured Plugins**: IntelliJ IDEA suggests installing some featured plugins. You can install them now or later.
- **Start Using IntelliJ IDEA**: Click "Start using IntelliJ IDEA" to open the IDE.

**Creating a New Java Project in IntelliJ IDEA**

- **Open IntelliJ IDEA**: Launch IntelliJ IDEA.
- **Create New Project**: On the Welcome screen, click "New Project."
- **Choose Project Type**: In the "New Project" dialog, select "Java" from the left-hand menu.
- **Project SDK**: Ensure that the Project SDK is set to the JDK you installed in the previous lesson. If it's not, click "Install JDK" or select the correct JDK from the dropdown menu.
- **Project Template**: You can choose a template or create an empty project. For a simple project, select "Create project from template" and choose "Command Line App".
- **Project Name and Location**: Enter a name for your project (e.g., "HelloWorld") and choose a location to save the project files.
- **Finish**: Click "Finish" to create the project.

**IntelliJ IDEA Interface Overview**

- **Project Tool Window**: Displays the project structure, including source files, libraries, and other resources.
- **Editor Window**: Where you write and edit your code.
- **Navigation Bar**: Located at the top of the editor window, it shows the current file path and allows you to navigate to other files.
- **Run/Debug Tool Window**: Displays the output of your program and allows you to debug your code.
- **Terminal Tool Window**: Provides a command-line interface for running commands and scripts.

#### <a name="chapter1part4.3"></a>Chapter 1 - Part 4.3: Eclipse

Eclipse is another popular open-source IDE widely used for Java development. It's known for its flexibility, extensive plugin ecosystem, and strong community support.

**Installing Eclipse**

- **Download Eclipse**: Go to the Eclipse website (https://www.eclipse.org/downloads/) and download the Eclipse IDE for Java Developers for your operating system.
- **Run the Installer**: Run the installer and follow the on-screen instructions.
- **Choose Installation Folder**: Select the directory where you want to install Eclipse.
- **Launch Eclipse**: Once the installation is complete, you can launch Eclipse from the Start menu (Windows) or the Applications folder (macOS).

**Configuring Eclipse**

- **Workspace**: When you first launch Eclipse, you will be prompted to choose a workspace. A workspace is a directory where Eclipse stores your project files and settings. Choose a location for your workspace and click "Launch."
- **Welcome Screen**: The Eclipse Welcome screen provides links to tutorials, documentation, and other resources. You can close the Welcome screen to start using Eclipse.

**Creating a New Java Project in Eclipse**

- **Open Eclipse**: Launch Eclipse.
- **Create New Project**: Go to File > New > Java Project.
- **Project Name**: Enter a name for your project (e.g., "HelloWorld").
- **Use default location**: You can either use the default location or specify a custom location for your project.
- **JRE**: Ensure that the JRE is set to the JDK you installed in the previous lesson. If it's not, click "Configure JREs" and add the correct JDK.
- **Layout**: Keep the default project layout.
- **Finish**: Click "Finish" to create the project.

**Eclipse Interface Overview**

- **Package Explorer**: Displays the project structure, including source files, libraries, and other resources.
- **Editor Area**: Where you write and edit your code.
- **Outline View**: Displays the structure of the current file, including classes, methods, and fields.
- **Console View**: Displays the output of your program.
- **Problems View**: Displays errors and warnings in your code.

#### <a name="chapter1part5"></a>Chapter 1 - Part 5: Writing and Running Your First Java Program: "Hello, World!"

Let's embark on the journey of writing and running your very first Java program. This is a pivotal step in becoming a Java programmer. We'll create the classic "Hello, World!" program, which serves as a fundamental introduction to the structure and execution of Java code. This exercise will solidify your understanding of the Java Development Kit (JDK) and the Integrated Development Environment (IDE) you set up in the previous lessons. By the end of this lesson, you'll have a tangible result – a working Java program – and a foundational understanding of how to build upon it.

#### <a name="chapter1part5.1"></a>Chapter 1 - Part 5.1: Creating Your First Java Program: "Hello, World!"

The "Hello, World!" program is a time-honored tradition in programming. It's a simple program that displays the text "Hello, World!" on the console. Creating this program in Java involves a few key steps: writing the code, saving the file, compiling the code, and running the compiled code.

**Step 1: Writing the Code**

Open your chosen IDE (IntelliJ IDEA or Eclipse). Create a new Java file. The name of the file should match the name of the class you'll define within it, and it should end with the .java extension. For this example, let's name the file HelloWorld.java.

Now, enter the following code into the HelloWorld.java file:

```java
public class HelloWorld { // Declares a class named HelloWorld
    public static void main(String[] args) { // Declares the main method
        System.out.println("Hello, World!"); // Prints "Hello, World!" to the console
    }
}
```

Let's break down this code:

- ```**public class HelloWorld { ... }**```: This line declares a class named HelloWorld. In Java, everything resides within a class. The public keyword means that this class can be accessed from anywhere in your program. Classes are the fundamental building blocks of Java programs, and we'll delve deeper into them in Module 5.

- ```**public static void main(String[] args) { ... }**```: This is the main method. It's the entry point of your program – the code that the Java Virtual Machine (JVM) executes first.
  - ```**public**```: Similar to the class, public means this method can be accessed from anywhere.
  - ```**static**```: This keyword means that the method belongs to the HelloWorld class itself, rather than to an instance of the HelloWorld class. We'll explore static methods in more detail in Module 6.
  - ```**void**```: This indicates that the method doesn't return any value. Methods can perform actions and optionally return a result.
  - ```**main(String[] args)**```: This is the name of the method (main) and its parameters. String[] args is an array of strings that can be used to pass arguments to the program from the command line. We won't use command-line arguments in this simple program, but they can be useful for more complex applications.
 
- ```**System.out.println("Hello, World!");**```: This line is the heart of the program. It prints the text "Hello, World!" to the console.
  - ```**System.out**```: This is a standard output stream in Java. It represents the console (your terminal or command prompt).
  - ```**println()**```: This is a method of the System.out object that prints a line of text to the console. The text to be printed is enclosed in double quotes " ".
 
**Step 2: Saving the File**

Save the file as HelloWorld.java in a directory of your choice. Make sure the file name matches the class name exactly (including capitalization).

**Step 3: Compiling the Code**

Before you can run the program, you need to compile it. Compilation is the process of translating the human-readable Java code into bytecode, which the JVM can understand and execute.

- **Using IntelliJ IDEA**: IntelliJ IDEA usually compiles your code automatically as you type. However, you can also manually compile the code by going to Build > Build Project.
- **Using Eclipse**: Eclipse also typically compiles your code automatically. If not, you can compile it by going to Project > Build Project.

If the compilation is successful, you won't see any error messages. If there are errors, the IDE will highlight them and provide descriptions to help you fix them. Common errors include typos, missing semicolons, and incorrect syntax.

**Step 4: Running the Code**

Once the code is compiled successfully, you can run it.

- **Using IntelliJ IDEA**: Right-click in the code editor and select Run 'HelloWorld.main()'. Alternatively, you can click the green "play" button in the gutter next to the main method declaration.
- **Using Eclipse**: Right-click in the code editor and select Run As > Java Application.

If everything is set up correctly, you should see the text "Hello, World!" printed on the console in your IDE.

#### <a name="chapter1part5.2"></a>Chapter 1 - Part 5.2: Understanding the Compilation Process

The compilation process is a crucial step in Java development. When you compile a Java program, the Java compiler (javac) takes your .java file as input and produces a .class file. This .class file contains the bytecode representation of your program. Bytecode is a platform-independent intermediate language that the JVM can execute.

The JVM then interprets or compiles this bytecode into machine code that is specific to the underlying operating system and hardware. This is what makes Java platform-independent – the same bytecode can run on any system that has a JVM.

#### <a name="chapter1part5.3"></a>Chapter 1 - Part 5.3: Common Errors and Troubleshooting

| Compile-time                                                                                                              | Runtime                                                                                                                              | 
| :------------------------------------------------------------------------------------------------------------------------ | :-----------------------------------------------------------------------------------------------------------------------------------:|
| The compile-time errors are the errors which are produced at the compile-time, and they are detected by the compiler.     | The runtime errors are the errors which are not generated by the compiler and produce an unpredictable result at the execution time. |
| In this case, the compiler prevents the code from execution if it detects an error in the program.]                       | In this case, the compiler does not detect the error, so it cannot prevent the code from the execution.                              |
| It contains the syntax and semantic errors such as missing semicolon at the end of the statement.                         | It contains the errors such as division by zero, determining the square root of a negative number.                                   |

Even with a simple program like "Hello, World!", you might encounter errors. Here are some common errors and how to fix them:

- ```**ClassNotFoundException**```: This error usually means that the JVM can't find the .class file for your program. Make sure that the file is in the correct directory and that the class name matches the file name. Also, ensure that the code has been compiled.
- ```**NoSuchMethodError**```: main: This error indicates that the JVM can't find the main method in your class. Double-check that the main method is declared exactly as public static void main(String[] args).
- ```**Syntax errors**```: These errors are usually caused by typos, missing semicolons, or incorrect syntax. The IDE will typically highlight these errors and provide descriptions to help you fix them. Pay close attention to the error messages and carefully review your code.

#### <a name="chapter1part6"></a>Chapter 1 - Part 6: Understanding Basic Java Program Structure

Understanding the basic structure of a Java program is crucial for writing any Java code. It's like learning the alphabet before writing sentences. This lesson will break down the essential components of a Java program, explaining each part in detail and providing examples to illustrate how they work together. By the end of this lesson, you'll be able to read, understand, and write simple Java programs with confidence, setting a solid foundation for more advanced topics.

Java is an object-oriented language and your base unit is the class.  Every Code in Java have to be in a class.

The classes is organize in packages and the packages is organize in modules. A Java application is a set of modules with packages.

Bellow, there is a example of a Java application:

<br>

<div align="center"><img src="img/application-structure-in-java-w1449-h810.png" width=1000 height=500><br><sub>Fig 7 - Application Structure in Java Application </sub></div>

<br>

#### <a name="chapter1part6.1"></a>Chapter 1 - Part 6.1: Anatomy of a Java Program

Every Java program has a specific structure that the Java compiler expects. Understanding this structure is essential for writing code that compiles and runs correctly. The basic structure consists of the following key elements:

- **Class Declaration**: This is the foundation of any Java program. Everything in Java resides inside a class.
- **main Method**: This is the entry point of your program. When you run a Java program, the Java Virtual Machine (JVM) starts executing code from the main method.
- **Statements**: These are the instructions that the program executes. They perform actions such as calculations, printing output, or making decisions.
- **Comments**: These are explanatory notes that you can add to your code to make it more readable. They are ignored by the compiler.

Let's examine each of these elements in detail.

**Class Declaration**

In Java, everything is an object, and every piece of code must reside inside a class. A class is a blueprint for creating objects. The basic syntax for declaring a class is:

```java
public class ClassName {
    // Class body (fields and methods)
}
```

- ```**public**```: This is an access modifier that determines the visibility of the class. public means that the class can be accessed from anywhere. We'll delve deeper into access modifiers in a later module.
- ```**class**```: This keyword is used to declare a class.
- ```**ClassName**```: This is the name of the class. Class names should start with an uppercase letter and follow the camel case naming convention (e.g., MyFirstClass, StudentDetails).
- ```**{}**```: The curly braces enclose the body of the class, which contains fields (variables) and methods (functions).

**Example**

```java
public class MyFirstProgram {
    // Class body will go here
}
```

In this example, we've declared a class named MyFirstProgram. Currently, the class body is empty, but we'll add more to it in the following sections.

**The main Method**

The main method is the entry point of any Java program. It's where the execution begins. Every standalone Java program must have a main method. The syntax for the main method is:

```java
public static void main(String[] args) {
    // Statements to be executed
}
```

Let's break down each part of this declaration:

- ```**public**```: As with the class declaration, public means that the main method can be accessed from anywhere.
- ```**static**```: This keyword means that the main method belongs to the class itself, rather than to an instance of the class. This allows the JVM to call the main method without creating an object of the class. We'll discuss static in more detail in Module 6.
- ```**void**```: This indicates that the main method does not return any value.
- ```**main**```: This is the name of the method. It's a special name that the JVM recognizes as the entry point of the program.
- ```**String[] args**```: This is the parameter list of the main method. It's an array of strings that can be used to pass command-line arguments to the program. We'll cover arrays in Module 4. For now, you can think of it as a way to provide input to your program when you run it from the command line.

**Example:**

```java
public class MyFirstProgram {
    public static void main(String[] args) {
        // Statements to be executed
    }
}
```

In this example, we've added the main method to our MyFirstProgram class. Now, we can add statements inside the main method to make our program do something.

**Statements**

Statements are the instructions that the program executes. They can be simple assignments, calculations, method calls, or control flow statements (which we'll cover in Module 3). Every statement in Java must end with a semicolon (;).

**Example:**

```java
public class MyFirstProgram {
    public static void main(String[] args) {
        System.out.println("Hello, World!"); // This is a statement
    }
}
```

In this example, we've added a statement that prints the text "Hello, World!" to the console.

- ```**System.out.println()**```: This is a method call that prints a line of text to the console. System.out is an object that represents the standard output stream (usually the console), and println() is a method of that object. We'll discuss methods in detail in Module 6.
- ```**"Hello, World!"**```: This is a string literal, which is a sequence of characters enclosed in double quotes.

**Comments**

Comments are explanatory notes that you can add to your code to make it more readable. They are ignored by the compiler. Java supports two types of comments:

- **Single-line comments**: These start with // and continue until the end of the line.
- **Multi-line comments**: These start with /* and end with */. They can span multiple lines.

**Example**:

```java
public class MyFirstProgram {
    public static void main(String[] args) {
        // This is a single-line comment
        /*
         * This is a multi-line comment.
         * It can span multiple lines.
         */
        System.out.println("Hello, World!"); // This statement prints "Hello, World!" to the console
    }
}
```

Comments are extremely useful for explaining what your code does, especially when it's complex. They can also be used to temporarily disable code by "commenting it out."

#### <a name="chapter1part6.2"></a>Chapter 1 - Part 6.2: Putting It All Together: A Complete Java Program

Let's combine all the elements we've discussed to create a complete Java program that calculates the sum of two numbers and prints the result to the console.

```java
public class SumCalculator { // Class declaration
    public static void main(String[] args) { // Main method
        int num1 = 10; // Declare and initialize the first number
        int num2 = 20; // Declare and initialize the second number
        int sum = num1 + num2; // Calculate the sum
        System.out.println("The sum of " + num1 + " and " + num2 + " is: " + sum); // Print the result
    }
}
```

In this program:

- We declare a class named SumCalculator.
- We define the main method, which is the entry point of the program.
- Inside the main method, we declare two integer variables, num1 and num2, and initialize them with the values 10 and 20, respectively. We'll learn more about variables and data types in Module 2.
- We calculate the sum of num1 and num2 and store the result in a variable named sum.
- We print the result to the console using System.out.println(). The + operator is used to concatenate strings and variables.

#### <a name="chapter1part6.3"></a>Chapter 1 - Part 6.3: Common Errors and How to Avoid Them

When you're starting out with Java, it's common to make mistakes. Here are some common errors related to program structure and how to avoid them:

- **Missing semicolon**: Every statement in Java must end with a semicolon. Forgetting the semicolon is a very common error.
  - **Example**: int x = 10 (missing semicolon)
  - **Solution**: int x = 10;
 
- **Incorrect class name**: The class name must match the name of the file (with the .java extension). For example, if your class is named MyClass, the file must be named MyClass.java.
  - **Example**: Class name is MyClass, but the file is named Myclass.java.
  - **Solution**: Ensure the class name and file name match exactly, including capitalization.
 
- **Missing main method**: If your program doesn't have a main method with the correct signature (public static void main(String[] args)), the JVM won't be able to find the entry point of your program.

  - **Example**: public void main(String[] args) (missing static)
  - **Solution**: Double-check the signature of the main method to make sure it's exactly public static void main(String[] args).
 
- **Mismatched curly braces**: Every opening curly brace ({) must have a corresponding closing curly brace (}). Mismatched curly braces can lead to syntax errors that are difficult to debug.

**Example:**

```java
public class MyClass {
    public static void main(String[] args) {
        System.out.println("Hello");
    // Missing closing curly brace for the main method
} // Closing curly brace for the class
```

- **Solution**: Use an IDE like IntelliJ IDEA or Eclipse, which can automatically match curly braces and highlight errors.

## <a name="chapter2"></a>Chapter 2: Java Fundamentals: Data Types, Variables, and Operators

#### <a name="chapter2part1"></a>Chapter 2 - Part 1: Understanding Primitive Data Types: int, double, boolean, char

Primitive data types are the fundamental building blocks for representing data in Java. Understanding them is crucial because they dictate the kind of values a variable can hold and the operations that can be performed on it. This lesson will provide a comprehensive overview of four essential primitive data types: int, double, boolean, and char. We'll explore their characteristics, how to declare and use them, and their significance in Java programming.

#### <a name="chapter2part1.1"></a>Chapter 2 - Part 1.1: Data Types in Java

In Java, we have the 8 primitive data types. Other types are Non-primitive like the diagram below:

<br>

<div align="center"><img src="img/data-types-w8000-h4500.png" width=600 height=350><br><sub>Fig 13 -Java Data Types - (<a href='https://getkt.com/blog/reintroduction-to-java-data-types/'>Work by neotam</a>) </sub></div>

<br>

<div align="center"><img src="img/data-types2-w1920-h1080.jpg" width=600 height=300><br><sub>Fig 14 -Java Data Primitive Types - (<a href='https://getkt.com/blog/reintroduction-to-java-data-types/'>Work by neotam</a>) </sub></div>

<br>

The size of a data (bits) is the number of the values this variable can store: The byte type can store 8 bits. Each bit store 1 or 0.

So: 2x2x2x2x2x2x2x2x2 = 2^8 = 256 possible values (-128 to 127)


To see the range of max and min of a type of variable do:

```java
int myMinIntValue = Integer.MIN_VALUE;
int myMaxIntValue = Integer.MAX_VALUE;
System.out.println("Integer Minimum Value = " + myMinIntValue);
System.out.println("Integer Maximum Value = " + myMaxIntValue);

int myMaxIntTest = 2_147_483_647; // another form to express

byte myMinByteValue = Byte.MIN_VALUE;
byte myMaxByteValue = Byte.MAX_VALUE;
System.out.println("Byte Minimum Value = " + myMinByteValue);
System.out.println("Byte Maximum Value = " + myMaxByteValue);

short myMinShortValue = Short.MIN_VALUE;
short myMaxShortValue = Short.MAX_VALUE;
System.out.println("Short Minimum Value = " + myMinShortValue);
System.out.println("Short Maximum Value = " + myMaxShortValue);
        
long myLongValue = 100; // Wrong -> Use L
long myMinLongValue = Long.MIN_VALUE;
long myMaxLongValue = Long.MAX_VALUE;
System.out.println("Long Minimum Value = " + myMinLongValue);
System.out.println("Long Maximum Value = " + myMaxLongValue);
long bigLongLiteralValue = 2_147_483_647_234L;
System.out.println(bigLongLiteralValue);

short bigShortLiteralValue = 32767;

/*

Output

Integer Minimum Value = -2147483648
Integer Maximum Value = 2147483647
Byte Minimum Value = -128
Byte Maximum Value = 127
Short Minimum Value = -32768
Short Maximum Value = 32767
Long Minimum Value = -9223372036854775808
Long Maximum Value = 9223372036854775807
2147483647234
*/
```

If you try to add a value in a Maximun or Minimun Value, will occur a overflow in a Maximun and underflow in Minimun. The Computer will convert the maximun to minimun and vice-versa

```java
int myMinIntValue = Integer.MIN_VALUE;
int myMaxIntValue = Integer.MAX_VALUE;
System.out.println("Integer Minimum Value = " + myMinIntValue);
System.out.println("Integer Maximum Value = " + myMaxIntValue);
System.out.println("Busted MAX value = " + (myMaxIntValue + 1)); // overflow
System.out.println("Busted MIN value = " + (myMinIntValue - 1)); // underflow

/*
Output

Integer Minimum Value = -2147483648
Integer Maximum Value = 2147483647
Busted MAX value = -2147483648
Busted MIN value = 2147483647
*/
```


Wrapper types(Reference Types) provided by java for corresponding Primitive Types

| Primitive Types  | Wrapper types(Reference Types) |
| :--------------: | :-----------------------------:|
| boolean          | Boolean                        | 
| byte             | Byte                           |
| character        | Character                      |
| short            | Short                          |
| int              | Int                            | 
| long             | Long                           |
| float            | Float                          |
| double           | double                         |

**Variables Name -> Camel Case** Ex: myVariable

**Class Name -> Pascal Case** Ex: MyClass


#### <a name="chapter2part1.2"></a>Chapter 2 - Part 1.2: Integer Data Type: int

The int data type is used to store whole numbers (integers) without any fractional part. It's one of the most commonly used data types in Java.

**Characteristics of int**

- **Size**: int occupies 4 bytes (32 bits) of memory.
- **Range**: The range of values that an int can hold is from -2,147,483,648 (-231) to 2,147,483,647 (231 - 1).
- **Usage**: Suitable for representing counts, indices, quantities, and other whole number values.

**Declaring and Initializing int Variables**

To declare an int variable, you use the int keyword followed by the variable name. To initialize it, you assign a value to it using the assignment operator =.

```java
int age; // Declaration
age = 30; // Initialization

int count = 100; // Declaration and initialization in one line
```

**Examples of int Usage**

```java
int numberOfStudents = 25;
int temperature = 72;
int score = 1000;
int negativeNumber = -5;
```

**int Operations**

You can perform various arithmetic operations on int variables, such as addition, subtraction, multiplication, and division.

```java
int x = 10;
int y = 5;

int sum = x + y; // sum is 15
int difference = x - y; // difference is 5
int product = x * y; // product is 50
int quotient = x / y; // quotient is 2
int remainder = x % y; // remainder is 0
```

**When to Use int**

Use int when you need to represent whole numbers within the specified range and when you don't need to store fractional parts. For example, representing the number of items in a shopping cart, the age of a person, or the score in a game.

#### <a name="chapter2part1.3"></a>Chapter 2 - Part 1.3: Floating-Point Data Type: double

The double data type is used to store floating-point numbers, which are numbers with a fractional part (decimal numbers).

**Characteristics of double**

**Size**: double occupies 8 bytes (64 bits) of memory.
**Range**: double can represent a wide range of values, both positive and negative, including very large and very small numbers. It uses the IEEE 754 standard for representing floating-point numbers.
**Precision**: double provides approximately 15-17 decimal digits of precision.
**Usage**: Suitable for representing measurements, scientific calculations, financial values, and other values that require fractional precision.

**Declaring and Initializing double Variables**

To declare a double variable, you use the double keyword followed by the variable name. To initialize it, you assign a floating-point value to it.

```java
double price; // Declaration
price = 19.99; // Initialization

double temperature = 98.6; // Declaration and initialization in one line
```

**Examples of double Usage**

```java
double pi = 3.14159;
double gravity = 9.81;
double bankBalance = 1234.56;
double percentage = 0.75;
```

**double Operations**

You can perform arithmetic operations on double variables, similar to int.

```java
double x = 10.5;
double y = 3.2;

double sum = x + y; // sum is 13.7
double difference = x - y; // difference is 7.3
double product = x * y; // product is 33.6
double quotient = x / y; // quotient is 3.28125
```

**When to Use double**

Use double when you need to represent numbers with fractional parts or when you require a wider range and higher precision than int can provide. For example, representing the price of an item, the temperature of a room, or the result of a scientific calculation.

#### <a name="chapter2part1.4"></a>Chapter 2 - Part 1.4: Boolean Data Type: boolean

The boolean data type represents a logical value that can be either true or false. It's used to represent conditions and make decisions in your code.

**Characteristics of boolean**

- **Size**: The size of a boolean is not precisely defined in the Java specification, but it's typically considered to be 1 bit, although it might occupy more memory depending on the JVM implementation.
- **Values**: boolean can only hold two values: true or false.
- **Usage**: Used to represent conditions, flags, and logical states.

**Declaring and Initializing boolean Variables**

To declare a boolean variable, you use the boolean keyword followed by the variable name. To initialize it, you assign either true or false to it.

```java
boolean isRaining; // Declaration
isRaining = true; // Initialization

boolean isLoggedIn = false; // Declaration and initialization in one line
```

**Examples of boolean Usage**

```java
boolean hasPermission = true;
boolean isFinished = false;
boolean isValidInput = true;
```

**boolean Operations**

boolean variables are primarily used with logical operators to create complex conditions. These operators will be covered in detail in a later lesson, but here's a brief overview:

- ```&&``` (AND): Returns true if both operands are true.
- ```||``` (OR): Returns true if at least one operand is true.
- ```!``` (NOT): Inverts the value of the operand.

```java
boolean x = true;
boolean y = false;

boolean andResult = x && y; // andResult is false
boolean orResult = x || y; // orResult is true
boolean notX = !x; // notX is false
```

**When to Use boolean**

Use boolean when you need to represent a binary state or a condition that can be either true or false. For example, representing whether a user is logged in, whether a file exists, or whether a certain condition is met.

#### <a name="chapter2part1.5"></a>Chapter 2 - Part 1.5: Character Data Type: char

The char data type is used to store a single character. It represents characters using the Unicode character set.

**Characteristics of char**

- **Size**: char occupies 2 bytes (16 bits) of memory.
- **Range**: char can represent characters from the Unicode character set, which includes letters, digits, symbols, and special characters from various languages.
- **Usage**: Used to represent individual characters, such as letters, digits, or symbols.

**Declaring and Initializing char Variables**

To declare a char variable, you use the char keyword followed by the variable name. To initialize it, you assign a character literal to it, enclosed in single quotes.

```java
char initial; // Declaration
initial = 'J'; // Initialization

char grade = 'A'; // Declaration and initialization in one line
```

**Examples of char Usage**

```java
char letter = 'a';
char digit = '5';
char symbol = '$';
char unicodeChar = '\u0041'; // Unicode for 'A'
```

**char Operations**

You can perform some arithmetic operations on char variables, as they are represented by numerical Unicode values. However, it's more common to use them for character manipulation and comparison.

```java
char letterA = 'A';
char letterB = 'B';

int difference = letterB - letterA; // difference is 1 (Unicode value of 'B' - Unicode value of 'A')
```

**Escape Sequences**

char also supports escape sequences, which are special character combinations that represent characters that are difficult or impossible to type directly.

- ```\n```: Newline
- ```\t```: Tab
- ```\'```: Single quote
- ```\"```: Double quote
- ```\\```: Backslash

```java
char newline = '\n';
char tab = '\t';
char singleQuote = '\'';
char doubleQuote = '\"';
char backslash = '\\';

System.out.println("This is a line" + newline + "This is a new line");
System.out.println("Column 1" + tab + "Column 2");
System.out.println("He said, " + singleQuote + "Hello" + singleQuote);
```

**When to Use char**

Use char when you need to represent a single character. For example, representing a letter in a name, a digit in a code, or a symbol in a password.

#### <a name="chapter2part2"></a>Chapter 2 - Part 2: Declaring and Initializing Variables

Declaring and initializing variables are fundamental concepts in Java programming. They are the building blocks for storing and manipulating data within your programs. Understanding how to properly declare and initialize variables is crucial for writing correct and efficient code. This lesson will cover the different ways to declare and initialize variables, best practices, and common pitfalls to avoid.

#### <a name="chapter2part2.1"></a>Chapter 2 - Part 2.1: Understanding Variable Declaration

In Java, before you can use a variable, you must declare it. Declaring a variable means specifying its data type and giving it a name. The syntax for declaring a variable is:

```java
dataType variableName;
```

- **dataType**: This specifies the type of data the variable will hold (e.g., int, double, boolean, char, String). We covered primitive data types in the previous lesson.
- **variableName**: This is the name you choose for the variable. Variable names must follow certain rules:
  - They must start with a letter, underscore (_), or dollar sign ($).
  - They can contain letters, digits, underscores, and dollar signs.
  - They cannot be a Java keyword (e.g., class, public, static, void, int).
  - They are case-sensitive (e.g., myVariable and myvariable are different variables).
  - By convention, variable names should start with a lowercase letter and use camelCase for multi-word names (e.g., numberOfStudents).
 
Here are some examples of variable declarations:

```java
int age;          // Declares an integer variable named 'age'
double salary;     // Declares a double variable named 'salary'
boolean isEmployed; // Declares a boolean variable named 'isEmployed'
char initial;       // Declares a character variable named 'initial'
String name;       // Declares a String variable named 'name'
```

**Multiple Declarations**

You can declare multiple variables of the same data type in a single line, separated by commas:

```java
int x, y, z; // Declares three integer variables: x, y, and z
```

However, it's generally recommended to declare each variable on a separate line for better readability, especially when initializing them.

#### <a name="chapter2part2.2"></a>Chapter 2 - Part 2.2: Understanding Variable Initialization

Initialization is the process of assigning an initial value to a variable. In Java, you can initialize a variable at the time of declaration or later in your code.

**Initialization at Declaration**

The most common and recommended way to initialize a variable is at the time of declaration:

```java
dataType variableName = value;
```

Here are some examples:

```java
int age = 25;             // Declares an integer variable 'age' and initializes it to 25
double salary = 50000.0;    // Declares a double variable 'salary' and initializes it to 50000.0
boolean isEmployed = true;  // Declares a boolean variable 'isEmployed' and initializes it to true
char initial = 'J';          // Declares a character variable 'initial' and initializes it to 'J'
String name = "John Doe";   // Declares a String variable 'name' and initializes it to "John Doe"
```

**Initialization After Declaration**

You can also declare a variable first and then initialize it later:

```java
int age;     // Declares an integer variable 'age'
age = 25;    // Initializes the variable 'age' to 25
```

However, it's generally better to initialize variables at the time of declaration whenever possible. This makes your code more readable and reduces the risk of using a variable before it has been assigned a value.

**Default Values**

If you declare a variable without initializing it, Java assigns a default value to it. These default values depend on the data type:

- ```int```: 0
- ```double```: 0.0
- ```boolean```: false
- ```char```: \u0000 (null character)
- ```String```: null

However, it's important to note that local variables (variables declared inside a method) must be initialized before they are used. The compiler will generate an error if you try to use an uninitialized local variable. Instance variables (variables declared within a class but outside any method) are automatically initialized with default values. We will cover classes and methods in later modules.

```java
public class Example {
    int instanceVariable; // Automatically initialized to 0

    public void myMethod() {
        int localVariable; // Not automatically initialized
        // System.out.println(localVariable); // Error: variable 'localVariable' might not have been initialized
    }
}
```

#### <a name="chapter2part2.3"></a>Chapter 2 - Part 2.3: Best Practices for Declaring and Initializing Variables

Initialize variables at the time of declaration: This makes your code more readable and prevents errors caused by using uninitialized variables.

- **Choose meaningful variable names**: Use names that clearly indicate the purpose of the variable.

- **Use appropriate data types**: Select the data type that best represents the type of data the variable will hold.

- **Follow naming conventions**: Use camelCase for variable names (e.g., numberOfStudents, firstName).

- **Avoid using uninitialized local variables**: Always initialize local variables before using them.

- **Consider using final for constants**: If a variable's value should not change after initialization, declare it as final. This makes your code more robust and easier to understand.

```java
final double PI = 3.14159;
// PI = 3.14; // Error: cannot assign a value to final variable PI
```

#### <a name="chapter2part2.4"></a>Chapter 2 - Part 2.4: Casting

It is the explicit conversion from one type to another.

It is necessary when the compiler is not able to “guess” that the result of an expression must be of another type.

```java
int x3, y3;
		
double resultado;
		
x3 = 5;
y3 = 2;
resultado = x3 / y3; // result a int -> 2.0 and not 2.5
		
System.out.println(resultado);
		
resultado = (double) x3 / y3; // casting
		
System.out.println(resultado);
		
double x4;
int y4;
		
x4 = 5.0;
y4 = (int) x4; // -> You can convert double to int - make a casting
		
System.out.println(y4);

int myIntValue = 100;
byte myByteValue = 100;
short myShortValue = 100;
		
int myIntTotal = (myIntValue)/2;
byte myByteTotal = (byte) ((myByteValue)/2);
short myShortTotal = (short) ((myShortValue)/2);



/*
Console

----output---
2.0
2.5
5

*/
```

#### <a name="chapter2part2.5"></a>Chapter 2 - Part 2.5: Variable Scope (Java Scope)

In Java, variables are only accessible inside the region they are created. This is called **scope**.

Scope of a variable: is the region of the program where the variable is valid, that is, where it can be referenced.

Variables declared directly inside a method are available anywhere in the method following the line of code in which they were declared:

**Method Scope**

Variables declared directly inside a method are available anywhere in the method following the line of code in which they were declared:

```java

public class Main {
  public static void main(String[] args) {

    // Code here CANNOT use x

    int x = 100;

    // Code here can use x
    System.out.println(x);
  }
}

```

**Block Scope**

A block of code refers to all of the code between curly braces ```{}```.

Variables declared inside blocks of code are only accessible by the code between the curly braces, which follows the line in which the variable was declared:

```java

public class Main {
  public static void main(String[] args) {

    // Code here CANNOT use x

    { // This is a block

      // Code here CANNOT use x

      int x = 100;

      // Code here CAN use x
      System.out.println(x);

   } // The block ends here

  // Code here CANNOT use x

  }
}

```

OBS: A block of code may exist on its own or it can belong to an ```if```, ```while``` or ```for``` statement. In the case of ```for``` statements, variables declared in the statement itself are also available inside the block's scope.

```java

double price = sc.nextDouble();

if (price > 100.0) {

double discount = price * 0.1;

// Code here CAN use variable discount

}

// Code here CANNOT use variable discount

```

#### <a name="chapter2part2.6"></a>Chapter 2 - Part 2.6: Examples and Demonstrations

Let's look at some more detailed examples of declaring and initializing variables in Java.

**Example 1: Calculating the Area of a Rectangle**

```java
public class RectangleArea {
    public static void main(String[] args) {
        // Declare and initialize the length and width of the rectangle
        double length = 10.5;
        double width = 5.0;

        // Calculate the area
        double area = length * width;

        // Print the area to the console
        System.out.println("The area of the rectangle is: " + area);
    }
}
```

In this example, we declare and initialize the length and width variables with double values. We then calculate the area and store it in the area variable, also a double. Finally, we print the result to the console.

**Example 2: Determining if a Number is Even**

```java
public class EvenNumber {
    public static void main(String[] args) {
        // Declare and initialize an integer variable
        int number = 20;

        // Check if the number is even
        boolean isEven = (number % 2 == 0);

        // Print whether the number is even or not
        System.out.println("Is the number even? " + isEven);
    }
}
```

Here, we declare an int variable number and initialize it. We then use the modulo operator (%) to check if the number is even. The result is stored in a boolean variable isEven, which is then printed to the console.

**Example 3: Storing a User's Name**

```java
import java.util.Scanner;

public class UserGreeting {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter their name
        System.out.print("Enter your name: ");

        // Declare and initialize a String variable to store the user's name
        String name = scanner.nextLine();

        // Print a greeting to the user
        System.out.println("Hello, " + name + "!");

        // Close the scanner
        scanner.close();
    }
}
```

In this example, we use the Scanner class (which we will cover in more detail in a later module) to read input from the console. We declare a String variable name and initialize it with the user's input. Then, we print a personalized greeting to the user.

#### <a name="chapter2part3"></a>Chapter 2 - Part 3: Working with Strings

Strings are fundamental to programming, representing text and enabling interaction with users and data. In Java, strings are objects, not primitive data types, which means they have associated methods that allow for powerful manipulation and analysis. Understanding how to work with strings is crucial for tasks ranging from simple text output to complex data processing. This lesson will cover the essentials of working with strings in Java, including their creation, manipulation, and comparison.

#### <a name="chapter2part3.1"></a>Chapter 2 - Part 3.1: Creating Strings

In Java, strings are objects of the String class. There are several ways to create string objects.

**String Literals**

The most common way to create a string is by using a string literal, which is a sequence of characters enclosed in double quotes.

```java
String message = "Hello, world!"; // Creating a string literal
System.out.println(message); // Output: Hello, world!
```

When you use a string literal, Java checks if a string with the same content already exists in the string pool. If it does, the new variable will refer to the existing string in the pool. If not, a new string object is created in the string pool. The string pool is a special memory area in the Java heap that stores string literals to optimize memory usage.

**Using the new Keyword**

You can also create a string using the new keyword, which explicitly creates a new String object in the heap, regardless of whether an identical string already exists in the string pool.

```java
String anotherMessage = new String("Hello, world!"); // Creating a string object using 'new'
System.out.println(anotherMessage); // Output: Hello, world!
```

While both methods achieve the same result, using string literals is generally preferred for efficiency because it leverages the string pool. Using new creates a new object even if an identical string exists, which can be less memory-efficient.

**Creating Strings from Character Arrays**

You can create a string from an array of characters using the String constructor.

```java
char[] charArray = {'J', 'a', 'v', 'a'};
String fromCharArray = new String(charArray);
System.out.println(fromCharArray); // Output: Java
```

This method is useful when you need to convert character data into a string format.

#### <a name="chapter2part3.2"></a>Chapter 2 - Part 3.2: String Immutability

A crucial concept to understand about strings in Java is that they are immutable. This means that once a String object is created, its value cannot be changed. Any operation that appears to modify a string actually creates a new String object.

```java
String text = "Hello";
text = text + " world!"; // A new String object is created
System.out.println(text); // Output: Hello world!
```

In the example above, the original "Hello" string is not modified. Instead, a new string "Hello world!" is created, and the text variable is updated to refer to this new string. The old "Hello" string might eventually be garbage collected if it's no longer referenced.

**Implications of Immutability**

Immutability has several important implications:

- **Thread Safety**: Immutable objects are inherently thread-safe, as their state cannot be modified after creation. This makes them safe to use in concurrent environments without the need for synchronization.
- **Caching**: Immutable strings can be safely cached and reused, as their value will never change. This is the basis for the string pool optimization.
- **Predictability**: Immutability makes code more predictable and easier to reason about, as you can be confident that a string's value will not change unexpectedly.

#### <a name="chapter2part3.3"></a>Chapter 2 - Part 3.3: String Manipulation

While strings are immutable, Java provides a rich set of methods for manipulating strings and creating new strings based on existing ones.

**Concatenation**

String concatenation is the process of combining two or more strings into a single string. In Java, you can use the + operator or the concat() method to concatenate strings.

**Using the + Operator**

The + operator is the most common and convenient way to concatenate strings.

```java
String firstName = "John";
String lastName = "Doe";
String fullName = firstName + " " + lastName;
System.out.println(fullName); // Output: John Doe
```

When you use the + operator with a string and another data type (e.g., an integer), Java automatically converts the other data type to a string and concatenates them.

```java
String age = "Age: ";
int personAge = 30;
String ageString = age + personAge;
System.out.println(ageString); // Output: Age: 30
```

**Using the concat() Method**

The concat() method is another way to concatenate strings. It takes a string as an argument and returns a new string that is the concatenation of the original string and the argument.

```java
String greeting = "Hello";
String name = " Alice";
String fullGreeting = greeting.concat(name);
System.out.println(fullGreeting); // Output: Hello Alice
```

While both methods achieve the same result, the + operator is generally preferred for its simplicity and readability.

**Substrings**

A substring is a contiguous sequence of characters within a string. Java provides the substring() method to extract substrings from a string.

```java
String message = "This is a test message";
String sub = message.substring(5, 12); // Extracts characters from index 5 (inclusive) to 12 (exclusive)
System.out.println(sub); // Output: is a te
```

The substring() method takes two arguments: the starting index (inclusive) and the ending index (exclusive). You can also use a single argument, which specifies the starting index, and the substring will extend to the end of the string.

```java
String message = "This is a test message";
String sub2 = message.substring(8); // Extracts characters from index 8 to the end of the string
System.out.println(sub2); // Output: a test message
```

**Length**

The length() method returns the number of characters in a string.

```java
String text = "Java";
int len = text.length();
System.out.println(len); // Output: 4
```

The length of a string includes all characters, including spaces and special characters.

**Adding Numbers and Strings**


WARNING!

Java uses the ```+``` operator for both addition and concatenation.

Numbers are added. Strings are concatenated.

If you add two numbers, the result will be a number:

```java

int x = 10;
int y = 20;
int z = x + y;  // z will be 30 (an integer/number)

```

If you add two strings, the result will be a string concatenation:

```java

String x = "10";
String y = "20";
String z = x + y;  // z will be 1020 (a String)

```

If you add a number and a string, the result will be a string concatenation:

```java

String x = "10";
int y = 20;
String z = x + y;  // z will be 1020 (a String)

```

**Strings - Special Characters**

Because strings must be written within quotes, Java will misunderstand this string, and generate an error:

```java

Because strings must be written within quotes, Java will misunderstand this string, and generate an error:

```

The solution to avoid this problem, is to use the **backslash escape character**.

The backslash (```\```) escape character turns special characters into string characters:

| Escape character | Result   |Description   |
| :---------------:| :-------:|:-----------: |
| \'               | '        | Single quote |
| \"               | "        | Double quote |
| \\               | \        | Backslash    |


The sequence ```\"```  inserts a double quote in a string:

```java

String txt = "We are the so-called \"Vikings\" from the north.";

```

The sequence ```\'```  inserts a single quote in a string:

```java

String txt = "It\'s alright.";

```

The sequence ```\\```  inserts a single backslash in a string:

```java

String txt = "The character \\ is called backslash.";

```

| Code | Result          |
| :---:| :--------------:|
| \n   | New Line        |
| \r   | Carriage Return | 
| \t   | Tab             |
| \b   | Backspace       |
| \f   | Form Feed       |

#### <a name="chapter2part3.4"></a>Chapter 2 - Part 3.4: String Comparison

Comparing strings is a common task in programming. Java provides several ways to compare strings, each with its own nuances.

**```equals()``` vs. ```==```**

It's crucial to understand the difference between the equals() method and the == operator when comparing strings.

- The equals() method compares the content of two strings. It returns true if the strings have the same sequence of characters, and false otherwise.

- The == operator compares the references of two strings. It returns true if the two variables refer to the same String object in memory, and false otherwise.

```java
String str1 = "Hello";
String str2 = "Hello";
String str3 = new String("Hello");

System.out.println(str1.equals(str2)); // Output: true (same content)
System.out.println(str1 == str2);    // Output: true (same object from string pool)
System.out.println(str1.equals(str3)); // Output: true (same content)
System.out.println(str1 == str3);    // Output: false (different objects)
```

In the example above, str1 and str2 refer to the same string in the string pool, so == returns true. However, str3 is a new String object created using new, so == returns false even though the content is the same.

**Always use the equals() method to compare the content of strings**. Using == can lead to unexpected results, especially when dealing with strings created using new or strings obtained from external sources.

**```equalsIgnoreCase()```**

The equalsIgnoreCase() method compares the content of two strings, ignoring case differences.

```java
String str1 = "Hello";
String str2 = "hello";

System.out.println(str1.equals(str2));          // Output: false (case-sensitive comparison)
System.out.println(str1.equalsIgnoreCase(str2)); // Output: true (case-insensitive comparison)
```

This method is useful when you want to compare strings without regard to case.

**```compareTo()```**

The compareTo() method compares two strings lexicographically (based on the Unicode values of their characters). It returns:

- A negative value if the first string is lexicographically less than the second string.
- A positive value if the first string is lexicographically greater than the second string.
- Zero if the strings are equal.

```java
String str1 = "apple";
String str2 = "banana";
String str3 = "apple";

System.out.println(str1.compareTo(str2)); // Output: Negative value (apple comes before banana)
System.out.println(str2.compareTo(str1)); // Output: Positive value (banana comes after apple)
System.out.println(str1.compareTo(str3)); // Output: 0 (strings are equal)
```

The compareTo() method is useful for sorting strings or determining their relative order.

#### <a name="chapter2part3.5"></a>Chapter 2 - Part 3.5: String Methods

Java's String class provides a wide range of methods for manipulating and analyzing strings. Here are some commonly used methods:

**```toUpperCase()``` and ```toLowerCase()```**

These methods convert a string to uppercase or lowercase, respectively.

```java
String text = "Java is Fun";
String upper = text.toUpperCase();
String lower = text.toLowerCase();

System.out.println(upper); // Output: JAVA IS FUN
System.out.println(lower); // Output: java is fun
```

These methods are useful for normalizing strings or performing case-insensitive comparisons.

**```trim()```**

The trim() method removes leading and trailing whitespace from a string.

```java
String text = "   Hello World   ";
String trimmed = text.trim();

System.out.println(text);    // Output:    Hello World
System.out.println(trimmed); // Output: Hello World
```

Whitespace includes spaces, tabs, and newline characters. The trim() method is useful for cleaning up user input or data from external sources.

**```replace()```**

The replace() method replaces all occurrences of a specified character or substring with another character or substring.

```java
String text = "This is a test";
String replaced = text.replace("test", "sample");
System.out.println(replaced); // Output: This is a sample

String replacedChar = text.replace('i', 'a');
System.out.println(replacedChar); // Output: Thas as a tast
```

**```indexOf()``` and ```lastIndexOf()```**

The indexOf() method returns the index of the first occurrence of a specified character or substring within a string. The lastIndexOf() method returns the index of the last occurrence. If the character or substring is not found, both methods return -1.

```java
String text = "This is a test";
int firstIndex = text.indexOf("is");
int lastIndex = text.lastIndexOf("is");

System.out.println(firstIndex); // Output: 2
System.out.println(lastIndex);  // Output: 5

int notFound = text.indexOf("xyz");
System.out.println(notFound);   // Output: -1
```

**```startsWith()``` and ```endsWith()```**

The startsWith() method checks if a string starts with a specified prefix. The endsWith() method checks if a string ends with a specified suffix. Both methods return a boolean value.

```java
String text = "Hello World";
boolean startsWithHello = text.startsWith("Hello");
boolean endsWithWorld = text.endsWith("World");

System.out.println(startsWithHello); // Output: true
System.out.println(endsWithWorld);   // Output: true
```

#### <a name="chapter2part4"></a>Chapter 2 - Part 4: Arithmetic Operators: +, -, *, /, %

Arithmetic operators are fundamental building blocks in Java, allowing you to perform mathematical calculations within your programs. Understanding how these operators work is crucial for manipulating numerical data and creating dynamic applications. This lesson will cover the five basic arithmetic operators in Java: addition, subtraction, multiplication, division, and modulus. We'll explore their syntax, usage, and potential pitfalls, equipping you with the knowledge to confidently perform arithmetic operations in your Java code.

#### <a name="chapter2part4.1"></a>Chapter 2 - Part 4.1: Basic Arithmetic Operators

Java provides five primary arithmetic operators:

- **Addition (+)**: Adds two operands.
- **Subtraction (-)**: Subtracts the second operand from the first.
- **Multiplication (*)**: Multiplies two operands.
- **Division (/)**: Divides the first operand by the second.
- **Modulus (%)**: Returns the remainder of a division operation.

**Addition (+)**

The addition operator (+) is used to sum two numerical values.

```java
int a = 10;
int b = 5;
int sum = a + b; // sum will be 15
System.out.println("Sum: " + sum);
```

In this example, the + operator adds the values of a and b, storing the result in the sum variable. The System.out.println() statement then prints the value of sum to the console.

String Concatenation: The + operator also performs string concatenation. If one of the operands is a string, Java treats the + operator as a string concatenation operator, converting the other operand to a string and joining them together.

```java
String firstName = "John";
String lastName = "Doe";
String fullName = firstName + " " + lastName; // fullName will be "John Doe"
System.out.println("Full Name: " + fullName);
```

Here, the + operator concatenates the firstName, a space (" "), and the lastName strings to create the fullName string.

**Subtraction (-)**

The subtraction operator (-) is used to find the difference between two numerical values.

```java
int a = 10;
int b = 5;
int difference = a - b; // difference will be 5
System.out.println("Difference: " + difference);
```

In this example, the - operator subtracts the value of b from a, storing the result in the difference variable.

Unary Minus: The - operator can also be used as a unary operator to negate a single operand.

```java
int a = 10;
int negativeA = -a; // negativeA will be -10
System.out.println("Negative A: " + negativeA);
```

**Multiplication (*)**

The multiplication operator (*) is used to find the product of two numerical values.

```java
int a = 10;
int b = 5;
int product = a * b; // product will be 50
System.out.println("Product: " + product);
```

In this example, the * operator multiplies the values of a and b, storing the result in the product variable.

**Division (/)**

The division operator (/) is used to divide the first operand by the second.

```java
int a = 10;
int b = 5;
int quotient = a / b; // quotient will be 2
System.out.println("Quotient: " + quotient);
```

In this example, the / operator divides the value of a by b, storing the result in the quotient variable.

Integer Division: When both operands are integers, the / operator performs integer division, which truncates the decimal part of the result.

```java
int a = 11;
int b = 5;
int quotient = a / b; // quotient will be 2 (not 2.2)
System.out.println("Quotient: " + quotient);
```

To obtain a floating-point result, at least one of the operands must be a floating-point number (e.g., double or float).

```java
double a = 11.0;
int b = 5;
double quotient = a / b; // quotient will be 2.2
System.out.println("Quotient: " + quotient);
```

Division by Zero: Dividing by zero results in an ArithmeticException at runtime. It's crucial to avoid division by zero in your code.

```java
int a = 10;
int b = 0;
// int quotient = a / b; // This will throw an ArithmeticException
```

**Modulus (%)**

The modulus operator (%) returns the remainder of a division operation.

```java
int a = 10;
int b = 3;
int remainder = a % b; // remainder will be 1
System.out.println("Remainder: " + remainder);
```

In this example, the % operator divides a by b and returns the remainder, which is 1.

Use Cases: The modulus operator is useful for various tasks, such as:

- Determining if a number is even or odd: number % 2 == 0 indicates an even number.
- Wrapping around a range: index = (index + 1) % arrayLength ensures that the index stays within the bounds of the array.
- Extracting digits from a number: lastDigit = number % 10 extracts the last digit of the number.

#### <a name="chapter2part4.2"></a>Chapter 2 - Part 4.2: Operator Precedence

Arithmetic operators have a specific order of precedence, which determines the order in which they are evaluated in an expression. The precedence of arithmetic operators in Java is as follows (from highest to lowest):

- **1**: Multiplication (*), Division (/), Modulus (%)
- **2**: Addition (+), Subtraction (-)

Operators with higher precedence are evaluated before operators with lower precedence. When operators have the same precedence, they are evaluated from left to right.

```java
int result = 10 + 5 * 2; // Multiplication is performed before addition
System.out.println("Result: " + result); // Output: 20
```

In this example, the multiplication 5 * 2 is performed first, resulting in 10. Then, the addition 10 + 10 is performed, resulting in 20.

Using Parentheses: You can use parentheses () to override the default operator precedence and explicitly specify the order of evaluation.

```java
int result = (10 + 5) * 2; // Addition is performed before multiplication due to parentheses
System.out.println("Result: " + result); // Output: 30
```

In this example, the addition 10 + 5 is performed first because it is enclosed in parentheses, resulting in 15. Then, the multiplication 15 * 2 is performed, resulting in 30.

#### <a name="chapter2part4.3"></a>Chapter 2 - Part 4.3: Practical Examples and Demonstrations

Let's explore some practical examples of using arithmetic operators in Java.

**Calculating the Area of a Rectangle**

```java
double length = 10.5;
double width = 5.0;
double area = length * width; // Calculate the area
System.out.println("Area of the rectangle: " + area);
```

This example calculates the area of a rectangle by multiplying its length and width.

**Calculating the Average of Three Numbers**

```java
double num1 = 85.0;
double num2 = 90.0;
double num3 = 78.0;
double average = (num1 + num2 + num3) / 3; // Calculate the average
System.out.println("Average: " + average);
```

This example calculates the average of three numbers by summing them and dividing by 3.

**Converting Celsius to Fahrenheit**

```java
double celsius = 25.0;
double fahrenheit = (celsius * 9 / 5) + 32; // Convert Celsius to Fahrenheit
System.out.println("Fahrenheit: " + fahrenheit);
```

This example converts a temperature from Celsius to Fahrenheit using the standard conversion formula.

**Calculating the Remaining Seats**

Imagine a scenario where you are managing seats for an event. You have a total number of seats and a certain number of seats have been booked. You can use subtraction to calculate the remaining seats.

```java
int totalSeats = 200;
int bookedSeats = 120;
int remainingSeats = totalSeats - bookedSeats;
System.out.println("Remaining seats: " + remainingSeats);
```

#### <a name="chapter2part5"></a>Chapter 2 - Part 5: Assignment Operators: =, +=, -=, *=, /=

Assignment operators are fundamental to programming in Java. They provide a concise way to assign values to variables and perform arithmetic operations simultaneously. Understanding these operators is crucial for writing efficient and readable code. This lesson will cover the basic assignment operator (=) and the compound assignment operators (+=, -=, *=, /=), explaining their functionality and demonstrating their usage with examples.

#### <a name="chapter2part5.1"></a>Chapter 2 - Part 5.1: Understanding the Basic Assignment Operator (=)

The most basic assignment operator in Java is the equals sign (=). It assigns the value on the right-hand side of the operator to the variable on the left-hand side.

**Syntax**

```java
variable = expression;
```

**Explanation**

- ```variable```: This is the name of the variable that will store the value.
- ```=```: The assignment operator.
- ```expression```: This is any valid Java expression that evaluates to a value. The value must be compatible with the data type of the variable.

**Examples**

```java
int age = 25; // Assigns the integer value 25 to the variable 'age'
double price = 19.99; // Assigns the double value 19.99 to the variable 'price'
String name = "Alice"; // Assigns the String value "Alice" to the variable 'name'
boolean isValid = true; // Assigns the boolean value true to the variable 'isValid'
```

**Important Notes**

- The assignment operator assigns the value of the expression to the variable. If the expression involves other variables, their current values are used.
- Assignment is right-associative, meaning that in an expression like a = b = c;, the value of c is first assigned to b, and then the value of b is assigned to a. It's generally better to avoid chaining assignments like this for readability.
- The variable on the left-hand side must be declared before it can be used in an assignment.

#### <a name="chapter2part5.2"></a>Chapter 2 - Part 5.2: Compound Assignment Operators (+=, -=, *=, /=)

Compound assignment operators combine an arithmetic operation with assignment. They provide a shorthand way to update the value of a variable.

**The += Operator (Addition Assignment)**

The += operator adds the value of the right-hand operand to the value of the left-hand operand and assigns the result to the left-hand operand.

**Syntax**

```java
variable += expression; // Equivalent to: variable = variable + expression;
```

**Example**

```java
int x = 10;
x += 5; // Equivalent to x = x + 5;
System.out.println(x); // Output: 15
```

**The -= Operator (Subtraction Assignment)**

The -= operator subtracts the value of the right-hand operand from the value of the left-hand operand and assigns the result to the left-hand operand.

**Syntax**

```java
variable -= expression; // Equivalent to: variable = variable - expression;
```

**Example**

```java
int y = 20;
y -= 7; // Equivalent to y = y - 7;
System.out.println(y); // Output: 13
```

**The ```*=``` Operator (Multiplication Assignment)**

The *= operator multiplies the value of the left-hand operand by the value of the right-hand operand and assigns the result to the left-hand operand.

**Syntax**

```java
variable *= expression; // Equivalent to: variable = variable * expression;
```

**Example**

```java
int z = 5;
z *= 4; // Equivalent to z = z * 4;
System.out.println(z); // Output: 20
```

**The /= Operator (Division Assignment)**

The /= operator divides the value of the left-hand operand by the value of the right-hand operand and assigns the result to the left-hand operand.

**Syntax**

```java
variable /= expression; // Equivalent to: variable = variable / expression;
```

**Example**

```java
double a = 100.0;
a /= 2.5; // Equivalent to a = a / 2.5;
System.out.println(a); // Output: 40.0
```

**Implicit Casting with Compound Assignment Operators**

Compound assignment operators perform an implicit cast if necessary. This means that if the result of the operation is of a different type than the variable, Java will automatically convert the result to the variable's type. This can be useful, but it's important to be aware of potential loss of precision.

**Example**

```java
int num = 5;
num += 2.5; // Equivalent to num = (int)(num + 2.5);
System.out.println(num); // Output: 7 (2.5 is truncated to 2)
```

In this example, num + 2.5 would normally result in a double. However, because we're using the += operator, the result is implicitly cast back to an int, truncating the decimal part. If we had used num = num + 2.5; directly, it would have resulted in a compile-time error because you can't directly assign a double to an int without explicit casting.

#### <a name="chapter2part5.3"></a>Chapter 2 - Part 5.3: Practical Examples and Demonstrations

Let's look at some more practical examples of how assignment operators can be used in Java programs.

**Example 1: Calculating the Sum of Numbers**

```java
public class SumCalculator {
    public static void main(String[] args) {
        int sum = 0; // Initialize the sum to 0
        sum += 10; // Add 10 to the sum
        sum += 25; // Add 25 to the sum
        sum += 5; // Add 5 to the sum

        System.out.println("The sum is: " + sum); // Output: The sum is: 40
    }
}
```

**Example 2: Updating a Product Price**

```java
public class PriceUpdater {
    public static void main(String[] args) {
        double price = 99.99; // Initial price
        double discount = 0.20; // 20% discount

        price -= price * discount; // Apply the discount
        System.out.println("The discounted price is: " + price); // Output: The discounted price is: 79.992
    }
}
```

**Example 3: Incrementing a Counter**

```java
public class Counter {
    public static void main(String[] args) {
        int count = 0; // Initialize the counter
        count++; // Increment the counter (covered in the next lesson, but shown here for context)
        count += 1; // Increment the counter using +=

        System.out.println("The count is: " + count); // Output: The count is: 2
    }
}
```

**Example 4: Accumulating Values in a Loop**

```java
public class LoopAccumulator {
    public static void main(String[] args) {
        int total = 0;
        for (int i = 1; i <= 5; i++) {
            total += i; // Add the current value of i to the total
        }
        System.out.println("The total is: " + total); // Output: The total is: 15
    }
}
```

#### <a name="chapter2part6"></a>Chapter 2 - Part 6: Comparison Operators: ==, !=, >, <, >=, <=

Comparison operators are fundamental building blocks in Java, allowing you to create logic that makes decisions based on the relationship between values. They are essential for controlling the flow of your program and performing different actions based on specific conditions. Understanding how to use comparison operators correctly is crucial for writing effective and bug-free Java code. This lesson will provide a comprehensive overview of each comparison operator, along with practical examples and exercises to solidify your understanding.

#### <a name="chapter2part6.1"></a>Chapter 2 - Part 6.1: Understanding Comparison Operators

Comparison operators are used to compare two values. The result of a comparison operation is always a boolean value: true or false. Java provides six comparison operators:

- ```==``` (equal to)
- ```!=``` (not equal to)
- ```>``` (greater than)
- ```<``` (less than)
- ```>=``` (greater than or equal to)
- ```<=``` (less than or equal to)

These operators can be used to compare primitive data types (like int, double, char, boolean) and, with some caveats, objects (specifically using == and !=).

**The == (Equal To) Operator**

The == operator checks if two values are equal. If they are, it returns true; otherwise, it returns false.

**Example with Integers**:

```java
int x = 5;
int y = 5;
int z = 10;

System.out.println(x == y); // Output: true
System.out.println(x == z); // Output: false
```

**Example with Doubles:**

```java
double a = 3.14;
double b = 3.14;
double c = 2.71;

System.out.println(a == b); // Output: true
System.out.println(a == c); // Output: false
```

**Example with Characters:**

```java
char p = 'A';
char q = 'A';
char r = 'B';

System.out.println(p == q); // Output: true
System.out.println(p == r); // Output: false
```

**Important Note Regarding Objects**:

When using == with objects (like Strings, or custom objects you'll learn to create later), it checks if the two variables refer to the same object in memory, not whether the objects have the same value. This is a crucial distinction.

```java
String str1 = new String("Hello");
String str2 = new String("Hello");
String str3 = str1;

System.out.println(str1 == str2); // Output: false (different objects)
System.out.println(str1 == str3); // Output: true (same object)
```

To compare the content of objects (like Strings), you should use the .equals() method, which will be covered in a later module.

**The != (Not Equal To) Operator**

The != operator checks if two values are not equal. It returns true if they are different, and false if they are the same.

**Example with Integers**:

```java
int x = 5;
int y = 5;
int z = 10;

System.out.println(x != y); // Output: false
System.out.println(x != z); // Output: true
```

**Example with Doubles**:

```java
double a = 3.14;
double b = 3.14;
double c = 2.71;

System.out.println(a != b); // Output: false
System.out.println(a != c); // Output: true
```

**Example with Characters**:

```java
char p = 'A';
char q = 'A';
char r = 'B';

System.out.println(p != q); // Output: false
System.out.println(p != r); // Output: true
```

**Important Note Regarding Objects**:

Similar to ==, when using != with objects, it checks if the two variables refer to different objects in memory.

```java
String str1 = new String("Hello");
String str2 = new String("Hello");

System.out.println(str1 != str2); // Output: true (different objects)
```

**The ```>``` (Greater Than) Operator**:

The > operator checks if the value on the left is greater than the value on the right. It returns true if it is, and false otherwise. This operator is typically used with numerical data types.

**Example with Integers**:

```java
int x = 10;
int y = 5;
int z = 10;

System.out.println(x > y); // Output: true
System.out.println(y > x); // Output: false
System.out.println(x > z); // Output: false
```

**Example with Doubles**:

```java
double a = 3.14;
double b = 2.71;
double c = 3.14;

System.out.println(a > b); // Output: true
System.out.println(b > a); // Output: false
System.out.println(a > c); // Output: false
```

**Example with Characters**:

Characters can also be compared using >, as they have underlying numerical (Unicode) values.

```java
char p = 'C'; // Unicode value 67
char q = 'A'; // Unicode value 65

System.out.println(p > q); // Output: true (67 > 65)
```

**The ```<``` (Less Than) Operator**:

The < operator checks if the value on the left is less than the value on the right. It returns true if it is, and false otherwise. This operator is also typically used with numerical data types.

**Example with Integers**:

```java
int x = 5;
int y = 10;
int z = 5;

System.out.println(x < y); // Output: true
System.out.println(y < x); // Output: false
System.out.println(x < z); // Output: false
```

**Example with Doubles**:

```java
double a = 2.71;
double b = 3.14;
double c = 2.71;

System.out.println(a < b); // Output: true
System.out.println(b < a); // Output: false
System.out.println(a < c); // Output: false
```

**Example with Characters**:

```java
char p = 'A'; // Unicode value 65
char q = 'C'; // Unicode value 67

System.out.println(p < q); // Output: true (65 < 67)
```

**The ```>=``` (Greater Than or Equal To) Operator**:

The >= operator checks if the value on the left is greater than or equal to the value on the right. It returns true if it is, and false otherwise.

**Example with Integers**:

```java
int x = 10;
int y = 5;
int z = 10;

System.out.println(x >= y); // Output: true
System.out.println(x >= z); // Output: true
System.out.println(y >= x); // Output: false
```

**Example with Doubles**:

```java
double a = 3.14;
double b = 2.71;
double c = 3.14;

System.out.println(a >= b); // Output: true
System.out.println(a >= c); // Output: true
System.out.println(b >= a); // Output: false
```

**Example with Characters**:

```java
char p = 'C'; // Unicode value 67
char q = 'A'; // Unicode value 65
char r = 'C'; // Unicode value 67

System.out.println(p >= q); // Output: true (67 >= 65)
System.out.println(p >= r); // Output: true (67 >= 67)
```

**The ```<=``` (Less Than or Equal To) Operator**:

The <= operator checks if the value on the left is less than or equal to the value on the right. It returns true if it is, and false otherwise.

**Example with Integers**:

```java
int x = 5;
int y = 10;
int z = 5;

System.out.println(x <= y); // Output: true
System.out.println(x <= z); // Output: true
System.out.println(y <= x); // Output: false
```

**Example with Doubles**:

```java
double a = 2.71;
double b = 3.14;
double c = 2.71;

System.out.println(a <= b); // Output: true
System.out.println(a <= c); // Output: true
System.out.println(b <= a); // Output: false
```

**Example with Characters**:

```java
char p = 'A'; // Unicode value 65
char q = 'C'; // Unicode value 67
char r = 'A'; // Unicode value 65

System.out.println(p <= q); // Output: true (65 <= 67)
System.out.println(p <= r); // Output: true (65 <= 65)
```

#### <a name="chapter2part6.2"></a>Chapter 2 - Part 6.2: Practical Examples and Demonstrations

Let's look at some more practical examples of how comparison operators can be used in Java programs.

**Example 1: Checking if a number is within a range**

```java
int age = 25;
int votingAge = 18;

boolean isEligibleToVote = age >= votingAge;

System.out.println("Is eligible to vote: " + isEligibleToVote); // Output: true
```

**Example 2: Comparing two double values with a tolerance**

Due to the way floating-point numbers are represented in computers, direct comparison using == can sometimes be unreliable. It's often better to check if the difference between two doubles is within a small tolerance.

```java
double value1 = 0.1 + 0.2;
double value2 = 0.3;
double tolerance = 0.00001;

boolean areEqual = Math.abs(value1 - value2) < tolerance;

System.out.println("Are equal: " + areEqual); // Output: true
```

**Example 3: Comparing characters to determine alphabetical order**

```java
char char1 = 'M';
char char2 = 'P';

if (char1 < char2) {
    System.out.println(char1 + " comes before " + char2 + " in the alphabet.");
} else {
    System.out.println(char2 + " comes before " + char1 + " in the alphabet.");
}
// Output: M comes before P in the alphabet.
```

#### <a name="chapter2part7"></a>Chapter 2 - Part 7: Logical Operators: &&, ||, !

Logical operators are fundamental building blocks in Java, allowing you to create more complex and nuanced conditions in your code. They enable you to combine multiple boolean expressions, creating powerful decision-making capabilities within your programs. Understanding and effectively using logical operators is crucial for controlling the flow of execution and implementing sophisticated logic.

#### <a name="chapter2part7.1"></a>Chapter 2 - Part 7.1: Understanding Logical Operators

Logical operators are used to combine two or more boolean expressions into a single boolean result. Java provides three main logical operators:

- **```&&```  (Logical AND)**: Returns true if both operands are true. Otherwise, it returns false.

- **```||``` (Logical OR)**: Returns true if at least one of the operands is true. It returns false only if both operands are false.

- **```!``` (Logical NOT)**: This is a unary operator that inverts the boolean value of its operand. If the operand is true, ! returns false, and vice versa.

**Logical AND ```(&&)```**:

The logical AND operator (&&) evaluates to true only when both operands are true. Think of it as requiring both conditions to be met.

|Operand 1	|Operand 2	|Result|
| :-----------: | :-------------: | :-------------: |
|true	|true	|true|
|true	|false	|false|
|false	|true	|false|
|false	|false	|false|

**Example**

```java
int age = 25;
boolean isStudent = true;

// Check if the person is both older than 18 AND a student
boolean isEligibleForDiscount = age > 18 && isStudent;
System.out.println("Eligible for discount: " + isEligibleForDiscount); // Output: true

age = 16;
isEligibleForDiscount = age > 18 && isStudent;
System.out.println("Eligible for discount: " + isEligibleForDiscount); // Output: false
```

In the first case, both conditions (age > 18 and isStudent) are true, so the result is true. In the second case, age > 18 is false, so the entire expression becomes false.

**Short-circuiting**: The && operator exhibits short-circuiting behavior. This means that if the left-hand operand evaluates to false, the right-hand operand is not evaluated. This is because the result of the entire expression will be false regardless of the value of the right-hand operand. This can improve performance and prevent potential errors.

```java
int x = 5;
int y = 0;

// The second condition (y != 0 && x / y > 2) will not be evaluated because x > 10 is false.
if (x > 10 && x / y > 2) {
    System.out.println("This will not be printed.");
} else {
    System.out.println("Short-circuiting occurred."); // Output: Short-circuiting occurred.
}
```

In this example, if the right-hand operand was evaluated, it would result in a division by zero error. However, because of short-circuiting, this error is avoided.

**Logical OR ```(||)```**:

The logical OR operator (||) evaluates to true if at least one of the operands is true. It only evaluates to false if both operands are false.

|Operand 1|	Operand 2|	Result|
| :-----------: | :-------------: | :-------------: |
|true	|true	|true|
|true	|false	|true|
|false|	true	|true|
|false	|false	|false|

**Example**:

```java
int temperature = 28;
boolean isRaining = false;

// Check if it's either hot OR raining
boolean shouldWearJacket = temperature < 15 || isRaining;
System.out.println("Should wear a jacket: " + shouldWearJacket); // Output: false

temperature = 10;
shouldWearJacket = temperature < 15 || isRaining;
System.out.println("Should wear a jacket: " + shouldWearJacket); // Output: true
```

In the first case, both conditions (temperature < 15 and isRaining) are false, so the result is false. In the second case, temperature < 15 is true, so the entire expression becomes true.

**Short-circuiting**: Similar to &&, the || operator also exhibits short-circuiting. If the left-hand operand evaluates to true, the right-hand operand is not evaluated. This is because the result of the entire expression will be true regardless of the value of the right-hand operand.

```java
String name = null;

// The second condition (name.length() > 5) will not be evaluated because name == null is true.
if (name == null || name.length() > 5) {
    System.out.println("Name is null or longer than 5 characters."); // Output: Name is null or longer than 5 characters.
}
```

In this example, if the right-hand operand was evaluated, it would result in a NullPointerException. However, because of short-circuiting, this exception is avoided.

**Logical NOT ```(!)```**:

The logical NOT operator (!) is a unary operator that inverts the boolean value of its operand. If the operand is true, ! returns false, and if the operand is false, ! returns true.

|Operand	|Result|
| :-----------: | :-------------: |
|true	|false|
|false	|true|

**Example**:

```java
boolean isLoggedIn = false;

// Check if the user is NOT logged in
boolean isLoggedOut = !isLoggedIn;
System.out.println("Is logged out: " + isLoggedOut); // Output: true

isLoggedIn = true;
isLoggedOut = !isLoggedIn;
System.out.println("Is logged out: " + isLoggedOut); // Output: false
```

In the first case, isLoggedIn is false, so !isLoggedIn is true. In the second case, isLoggedIn is true, so !isLoggedIn is false.

**Using NOT to simplify conditions**: The NOT operator can sometimes be used to make conditions more readable or to express them in a different way.

```java
int score = 75;
boolean isPassing = score >= 60;
boolean isFailing = !isPassing; // Equivalent to score < 60

System.out.println("Is passing: " + isPassing); // Output: true
System.out.println("Is failing: " + isFailing); // Output: false
```

#### <a name="chapter2part7.2"></a>Chapter 2 - Part 7.2: Combining Logical Operators

You can combine multiple logical operators to create more complex conditions. When combining operators, it's important to understand operator precedence (which will be covered in the next lesson) and to use parentheses to ensure that the expression is evaluated in the order you intend.

**Example**:

```java
int age = 20;
boolean hasLicense = true;
boolean isInsured = false;

// Check if the person is of legal age AND has a license AND is insured
boolean canDrive = age >= 18 && hasLicense && isInsured;
System.out.println("Can drive: " + canDrive); // Output: false

// Check if the person is of legal age AND (has a license OR is insured)
canDrive = age >= 18 && (hasLicense || isInsured);
System.out.println("Can drive: " + canDrive); // Output: true
```

In the first case, all three conditions must be true for canDrive to be true. In the second case, the person must be of legal age, and they must have either a license or insurance (or both). The parentheses ensure that the || operation is performed before the && operation.

#### <a name="chapter2part7.3"></a>Chapter 2 - Part 7.3: Practical Examples

Let's consider a scenario where you're building a simple e-commerce application. You might use logical operators to determine whether a user is eligible for a discount based on their membership status and purchase amount.

```java
boolean isMember = true;
double purchaseAmount = 120.0;

// Check if the user is a member OR if their purchase amount is greater than $100
boolean isEligibleForDiscount = isMember || purchaseAmount > 100.0;

if (isEligibleForDiscount) {
    System.out.println("User is eligible for a discount."); // Output: User is eligible for a discount.
} else {
    System.out.println("User is not eligible for a discount.");
}

// Check if the user is a member AND their purchase amount is greater than $50
boolean isEligibleForFreeShipping = isMember && purchaseAmount > 50.0;

if (isEligibleForFreeShipping) {
    System.out.println("User is eligible for free shipping."); // Output: User is eligible for free shipping.
} else {
    System.out.println("User is not eligible for free shipping.");
}
```

In this example, the || operator is used to check if the user is either a member or has a purchase amount greater than $100. The && operator is used to check if the user is both a member and has a purchase amount greater than $50.

#### <a name="chapter7part8"></a>Chapter 7 - Part 8: Bitwise Operators

The Bitwise operators are used to perform a bit manipulation on numbers. This Operator can be used with any integral type(char, int, short, etc) but it cannot be applied to double and float.

<br>

<div align="center"><img src="img/bitwise-w582-h400.png" width=582 height=400><br><sub>Fig 24 - Bitwise Operators used in Java - (<a href='https://www.javastudypoint.com/2019/12/bitwise-operators-in-java.html'>Work by javastudypoint</a>) </sub></div>

<br>

**Types of Bitwise Operators in Java**

1. **Bitwise AND (&) Operator:** This operator returns 1 if both the operands are also 1 else it returns 0.

2. **Bitwise OR (|) Operator:** This operator returns 1 if either of the bits in the operand is 1, else it returns 0.

3. **Bitwise Complement (~) Operator:** This operator inverts all of the bits of its operands.

4. **Bitwise Exclusive OR (^) Operator:** This operator returns 1 if the corresponding bits are different, else it returns 0.

5. **Bitwise Shift Left (<<) Operator:** This operator shifts the bits of the number to the left and fills 0 in the void spaces that are left as a result.

6. **Bitwise Shift Right (>>) Operator:** This operator shifts the bits of the number to the right and fills 0 in the void spaces that are left as a result.

7. **Shift Right Zero Fill (>>>), Operator:** This operator shifts the bits of the number to the right and fills 0 in the void spaces that are left as a result. The leftmost bit is set to be 0.

<br>

<div align="center"><img src="img/bitwise_truth_table-w1291-h472.png" width=1291 height=472><br><sub>Fig 25 - Bitwise Operators Truth Table - (<a href='https://www.javastudypoint.com/2019/12/bitwise-operators-in-java.html'>Work by  freeCodeCamp</a>) </sub></div>

<br>

```java

public class BitwiseOperator {
    public static void main(String[] args)
    {
        //Initial values
        int a = 6;
        int b = 7;

        // bitwise and
        // 0110 & 0111=0110 = 6
        System.out.println("a&b = " + (a & b));

        // bitwise or
        // 0110 | 0111=0111 = 7
        System.out.println("a|b = " + (a | b));

        // bitwise xor
        // 0110 ^ 0111=0001 = 1
        System.out.println("a^b = " + (a ^ b));

        // bitwise and
        // ~0110=1001
        // will give 2's complement of 1001 = -7
        System.out.println("~a = " + ~a);

		// bitwise left shift
		System.out.println("a << 2 = " +(a << 2));

		// bitwise right shift
		System.out.println("a >> 2 = " +(a >> 2));

		// bitwise shift right zero fill
		System.out.println("b >>> 2 = " +(b >>> 2));
	}

}

```

```java


    int a = 60;	      /* 60 = 0011 1100 represents 60 in binary*/
    int b = 13;	      /* 13 = 0000 1101 */
    int c = 0;
    
    c = a & b;        /* 12 = 0000 1100 */
    c = a | b;        /* 61 = 0011 1101 */
    c = a ^ b;        /* 49 = 0011 0001 */
    c = ~a;           /*-61 = 1100 0011  :Invert all bits */
    
    // shift operators : zeros are shifted in to replace the discarded bits
    c = a << 2;       /* 240 = 1111 0000 : Shift left 2 bits*/
    c = a >> 2;       /* 15 = 1111 */
    c = a >>> 2;      /* 15 = 0000 1111 : Zero fill right shift*/

```

```java

import java.util.Scanner;

public class Program {
	
	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		
		int mask = 0b100000; //binary number declared in Java, in this case, 32
		System.out.println(mask);
		int n = sc.nextInt();
		
		if ((n & mask) != 0) {
			System.out.println("6th bit is true!");
		} else {
			System.out.println("6th bit is false");
		}
		sc.close();
	}
}

```


#### <a name="chapter2part9"></a>Chapter 2 - Part 9: Operator Precedence

Operator precedence dictates the order in which operators are evaluated in a Java expression. Understanding operator precedence is crucial for writing correct and predictable code. Without this knowledge, the results of calculations might be unexpected, leading to bugs that are difficult to find. This lesson will cover the rules of operator precedence in Java, providing examples and exercises to solidify your understanding.

#### <a name="chapter2part9.1"></a>Chapter 2 - Part 9.1: Understanding Operator Precedence in Java

Operator precedence determines which operations are performed first in an expression. Operators with higher precedence are evaluated before operators with lower precedence. When operators have the same precedence, their associativity determines the order of evaluation (left-to-right or right-to-left).

Here's a table summarizing the precedence of common Java operators, from highest to lowest:

|Precedence	|Operator(s)	|Associativity|
| :-----------: | :-------------: | :-------------: |
|1	|```[]```, ```.```, ```()``` (method call)|	Left-to-right|
|2	|```++```, ```--``` (postfix)|	Left-to-right|
|3	|```++```, ```--``` (prefix), ```+```, ```-```, ```!```, ```~```|	Right-to-left|
|4	|```*```, ```/```, ```%```|	Left-to-right|
|5	|```+```, ```-```|	Left-to-right|
|6	|```<<```, ```>>```, ```>>>```|	Left-to-right|
|7	|```<```, ```<=```, ```>```, ```>=```, instanceof|	Left-to-right|
|8	|```==```, ```!=```|	Left-to-right|
|9	|```&```|	Left-to-right|
|10	|```^```|	Left-to-right|
|11	|&&|	Left-to-right|
|12	|```? :```|	Right-to-left|
|13	|```=```, ```+=```, ```-=```, ```*=```, ```/=```, ```%=```, ```&=```, ```^=```|	```=```, ```<<=```, ```>>=```, ```>>>=```|

**Arithmetic Operators**

Arithmetic operators (```*```, ```/```, ```%```, ```+```, ```-```) follow the standard mathematical order of operations. Multiplication, division, and modulus have higher precedence than addition and subtraction.

**Example 1**:

```java
int result = 5 + 3 * 2; // Multiplication is performed before addition
System.out.println(result); // Output: 11
```

In this example, 3 * 2 is evaluated first, resulting in 6. Then, 5 + 6 is evaluated, resulting in 11.

**Example 2**:

```java
int result = (5 + 3) * 2; // Parentheses change the order of operations
System.out.println(result); // Output: 16
```

Here, the parentheses force 5 + 3 to be evaluated first, resulting in 8. Then, 8 * 2 is evaluated, resulting in 16.

**Increment and Decrement Operators**

Increment (```++```) and decrement (```--```) operators can be used in prefix or postfix form. The precedence differs depending on the form.

Postfix: The value is used before it is incremented/decremented. Prefix: The value is incremented/decremented before it is used.

Example 1 (Postfix):

```java
int x = 5;
int y = x++; // y = 5, then x = 6
System.out.println("x = " + x + ", y = " + y); // Output: x = 6, y = 5
```

**Example 2 (Prefix)**:

```java
int x = 5;
int y = ++x; // x = 6, then y = 6
System.out.println("x = " + x + ", y = " + y); // Output: x = 6, y = 6
```

**Example 3 (Precedence with other operators)**:

```java
int x = 5;
int y = 10;
int result = ++x + y--; // x becomes 6, then 6 + 10 is evaluated, then y becomes 9
System.out.println("x = " + x + ", y = " + y + ", result = " + result); // Output: x = 6, y = 9, result = 16
```

In this example, the prefix increment ++x has higher precedence than the addition + and the postfix decrement y--. Therefore, x is incremented to 6 first. Then, 6 + y is evaluated (using the original value of y, which is 10), resulting in 16. Finally, y is decremented to 9.

**Comparison Operators**

Comparison operators (```==```, ```!=```, ```>```, ```<```, ```>=```, ```<=```) are used to compare values. They have lower precedence than arithmetic operators.

Example:

```java
int x = 5;
int y = 10;
boolean result = x + 5 > y - 2; // Arithmetic operations are performed before comparison
System.out.println(result); // Output: false (10 > 8 is false)
```

Here, x + 5 is evaluated to 10, and y - 2 is evaluated to 8. Then, 10 > 8 is evaluated, resulting in false.

**Logical Operators**

Logical operators (&&, ||, !) are used to combine boolean expressions. ! (logical NOT) has the highest precedence among logical operators, followed by && (logical AND), and then || (logical OR).

**Example 1**:

```java
boolean a = true;
boolean b = false;
boolean result = a || b && false; // AND is performed before OR
System.out.println(result); // Output: true (true || (false && false) -> true || false -> true)
```

In this example, b && false is evaluated first, resulting in false. Then, a || false is evaluated, resulting in true.

**Example 2**:

```java
boolean a = true;
boolean b = false;
boolean result = (a || b) && false; // Parentheses change the order of operations
System.out.println(result); // Output: false ((true || false) && false -> true && false -> false)
```

Here, the parentheses force a || b to be evaluated first, resulting in true. Then, true && false is evaluated, resulting in false.

**Example 3**:

```java
boolean a = true;
boolean b = false;
boolean result = !b && a; // NOT is performed before AND
System.out.println(result); // Output: true ((!false) && true -> true && true -> true)
```

In this example, !b is evaluated first, resulting in true. Then, true && a is evaluated, resulting in true.

**Assignment Operators**

Assignment operators (=, +=, -=, *=, /=, %=) have the lowest precedence. They are evaluated after all other operations in the expression.

**Example**:

```java
int x = 5;
int y = 10;
x += y * 2; // Multiplication is performed before addition and assignment
System.out.println(x); // Output: 25 (x = x + (y * 2) -> x = 5 + (10 * 2) -> x = 5 + 20 -> x = 25)
```

Here, y * 2 is evaluated to 20. Then, x + 20 is evaluated to 25. Finally, x is assigned the value 25.

#### <a name="chapter2part9.2"></a>Chapter 2 - Part 9.2: Using Parentheses to Control Precedence

Parentheses () can be used to override the default operator precedence. Expressions within parentheses are always evaluated first. This can improve code readability and prevent unexpected results.

**Example 1**:

```java
int result = 10 - 2 * 3; // Multiplication is performed before subtraction
System.out.println(result); // Output: 4
```

**Example 2**:

```java
int result = (10 - 2) * 3; // Parentheses change the order of operations
System.out.println(result); // Output: 24
```

In the first example, 2 * 3 is evaluated first, resulting in 6. Then, 10 - 6 is evaluated, resulting in 4. In the second example, 10 - 2 is evaluated first due to the parentheses, resulting in 8. Then, 8 * 3 is evaluated, resulting in 24.

#### <a name="chapter2part9.3"></a>Chapter 2 - Part 9.3: Practical Examples and Demonstrations

Let's consider a more complex example that combines multiple operators:

```java
int a = 5;
int b = 3;
int c = 10;
int result = a++ + b * 2 - c / 3;
System.out.println("Initial values: a = 5, b = 3, c = 10");
// a++ (postfix increment): a is used as 5, then incremented to 6
// b * 2: 3 * 2 = 6
// c / 3: 10 / 3 = 3 (integer division)
// 5 + 6 - 3 = 8
System.out.println("a = " + a + ", b = " + b + ", c = " + c + ", result = " + result); // Output: a = 6, b = 3, c = 10, result = 8
```

Here's a breakdown of the evaluation:

- a++ is evaluated. The current value of a (which is 5) is used in the expression, and then a is incremented to 6.
- b * 2 is evaluated, resulting in 6.
- c / 3 is evaluated, resulting in 3 (integer division).
- 5 + 6 - 3 is evaluated from left to right, resulting in 8.
- The value 8 is assigned to result.

## <a name="chapter3"></a>Chapter 3: Control Flow: Making Decisions and Repeating Actions

Control flow statements are the fundamental building blocks that allow programs to make decisions and repeat actions. Without control flow, a program would execute sequentially, line by line, offering no flexibility or adaptability. This lesson introduces the core concepts of control flow and sets the stage for understanding how to write more complex and dynamic Java programs. We'll explore the different types of control flow statements available in Java and how they alter the execution path of your code.

#### <a name="chapter3part1"></a>Chapter 3 - Part 1: Introduction to Control Flow Statements

Control flow refers to the order in which individual statements, instructions or function calls of an imperative program are executed or evaluated. In simple terms, it's the path your code takes as it runs. By default, Java executes code sequentially, from top to bottom, within a method. Control flow statements allow you to deviate from this linear execution, enabling your program to respond to different conditions and perform repetitive tasks.

#### <a name="chapter3part1.1"></a>Chapter 3 - Part 1.1: Understanding Control Flow

Control flow refers to the order in which individual statements, instructions or function calls of an imperative program are executed or evaluated. In simple terms, it's the path your code takes as it runs. By default, Java executes code sequentially, from top to bottom, within a method. Control flow statements allow you to deviate from this linear execution, enabling your program to respond to different conditions and perform repetitive tasks.

**Types of Control Flow Statements**

- **Decision-Making Statements**: These statements allow your program to choose between different paths of execution based on certain conditions. The primary decision-making statements in Java are:
  - ```if``` statement
  - ```if-else``` statement
  - ```if-else if-else``` statement
  - ```switch``` statement
 
- **Looping Statements**: These statements allow you to repeat a block of code multiple times. The looping statements in Java are:
  - ```while``` loop
  - ```do-while``` loop
  - ```for``` loop
  - ```for-each``` loop
 
**Importance of Control Flow**

Control flow statements are essential for creating programs that can:

- **React to User Input**: A program can take different actions based on what the user enters.
- **Process Data Conditionally**: A program can perform different calculations or operations depending on the data it receives.
- **Automate Repetitive Tasks**: A program can repeat a set of instructions multiple times, saving time and effort.
- **Implement Complex Algorithms**: Many algorithms rely on conditional execution and repetition to solve problems.

#### <a name="chapter3part1.2"></a>Chapter 3 - Part 1.2: Decision-Making Statements: An Overview

Decision-making statements allow a program to execute specific blocks of code only when certain conditions are met. These conditions are evaluated as boolean expressions (i.e., they result in either true or false).

**The ```if``` Statement**

The if statement is the simplest form of decision-making. It executes a block of code only if a specified condition is true.

```java
if (condition) {
    // Code to be executed if the condition is true
}
```

**Example**:

```java
int age = 20;

if (age >= 18) {
    System.out.println("You are eligible to vote.");
}
```

In this example, the message "You are eligible to vote." will be printed to the console only if the value of the age variable is greater than or equal to 18.

**The ```if-else``` Statement**

The if-else statement provides an alternative block of code to execute when the condition in the if statement is false.

**Syntax**:

```java
if (condition) {
    // Code to be executed if the condition is true
} else {
    // Code to be executed if the condition is false
}
```

**Example**:

```java
int age = 16;

if (age >= 18) {
    System.out.println("You are eligible to vote.");
} else {
    System.out.println("You are not eligible to vote yet.");
}
```

In this example, since age is 16 (less than 18), the message "You are not eligible to vote yet." will be printed.

**The ```if-else if-else``` Statement**

The if-else if-else statement allows you to check multiple conditions in sequence. It provides a way to handle more complex decision-making scenarios where you have several possible outcomes.

**Syntax**:

```java
if (condition1) {
    // Code to be executed if condition1 is true
} else if (condition2) {
    // Code to be executed if condition1 is false AND condition2 is true
} else if (condition3) {
    // Code to be executed if condition1 and condition2 are false AND condition3 is true
} else {
    // Code to be executed if all conditions are false
}
```

**Example**:

```java
int score = 75;

if (score >= 90) {
    System.out.println("Grade: A");
} else if (score >= 80) {
    System.out.println("Grade: B");
} else if (score >= 70) {
    System.out.println("Grade: C");
} else if (score >= 60) {
    System.out.println("Grade: D");
} else {
    System.out.println("Grade: F");
}
```

In this example, the program checks the value of the score variable against a series of conditions. Since score is 75, the message "Grade: C" will be printed.

**The ```switch``` Statement**

The switch statement provides a more efficient way to select one block of code to execute from a set of possible cases, based on the value of a single variable or expression. It's particularly useful when you have multiple possible values to check against.

**Syntax**:

```java
switch (expression) {
    case value1:
        // Code to be executed if expression equals value1
        break;
    case value2:
        // Code to be executed if expression equals value2
        break;
    case value3:
        // Code to be executed if expression equals value3
        break;
    default:
        // Code to be executed if expression doesn't match any of the cases
}
```

**Explanation**:

- The switch statement evaluates the expression.
- The case labels specify the different possible values of the expression.
- If the value of the expression matches a case label, the code within that case block is executed.
- The break statement is crucial. It terminates the switch statement and prevents the execution of subsequent case blocks. If you omit the break statement, the program will "fall through" to the next case block, even if the value of the expression doesn't match that case.
- The default case is optional. It provides a block of code to execute if the value of the expression doesn't match any of the case labels.

**Example**:

```java
int dayOfWeek = 3;

switch (dayOfWeek) {
    case 1:
        System.out.println("Monday");
        break;
    case 2:
        System.out.println("Tuesday");
        break;
    case 3:
        System.out.println("Wednesday");
        break;
    case 4:
        System.out.println("Thursday");
        break;
    case 5:
        System.out.println("Friday");
        break;
    case 6:
        System.out.println("Saturday");
        break;
    case 7:
        System.out.println("Sunday");
        break;
    default:
        System.out.println("Invalid day");
}
```

In this example, since dayOfWeek is 3, the message "Wednesday" will be printed.

#### <a name="chapter3part1.3"></a>Chapter 3 - Part 1.3: Looping Statements: An Introduction

Looping statements allow you to execute a block of code repeatedly, as long as a certain condition remains true. This is incredibly useful for automating tasks that need to be performed multiple times.

**The ```while``` Loop**

The while loop executes a block of code repeatedly as long as a specified condition is true. The condition is checked before each iteration of the loop.

**Syntax**:

```java
while (condition) {
    // Code to be executed repeatedly as long as the condition is true
}
```

**Example**:

```java
int count = 1;

while (count <= 5) {
    System.out.println("Count: " + count);
    count++; // Increment the counter
}
```

In this example, the loop will execute as long as the value of count is less than or equal to 5. The message "Count: " followed by the current value of count will be printed in each iteration. The count++ statement increments the value of count by 1 after each iteration. Without this increment, the loop would run indefinitely (an infinite loop).

**The ```do-while``` Loop**

The do-while loop is similar to the while loop, but with one key difference: the condition is checked after each iteration of the loop. This means that the code block inside the do-while loop will always be executed at least once, even if the condition is initially false.

**Syntax**:

```java
do {
    // Code to be executed repeatedly as long as the condition is true
} while (condition);
```

**Example**:

```java
int count = 6;

do {
    System.out.println("Count: " + count);
    count++;
} while (count <= 5);
```

In this example, even though count is initially 6 (which is greater than 5), the code inside the do block will be executed once. The message "Count: 6" will be printed. Then, the condition count <= 5 will be checked. Since it's false, the loop will terminate.

**The ```for``` Loop**

The for loop provides a more concise way to write loops that iterate a specific number of times. It combines the initialization, condition checking, and increment/decrement steps into a single statement.

**Syntax**:

```java
for (initialization; condition; increment/decrement) {
    // Code to be executed repeatedly as long as the condition is true
}
```

**Explanation**:

- **Initialization**: This part is executed only once, at the beginning of the loop. It's typically used to declare and initialize a loop counter variable.
- **Condition**: This condition is checked before each iteration of the loop. If it's true, the loop body is executed. If it's false, the loop terminates.
- **Increment/Decrement**: This part is executed after each iteration of the loop. It's typically used to update the loop counter variable.

**Example**:

```java
for (int i = 1; i <= 5; i++) {
    System.out.println("Iteration: " + i);
}
```

In this example, the loop will execute 5 times. The variable i is initialized to 1. The loop continues as long as i is less than or equal to 5. After each iteration, i is incremented by 1.

**The ```for-each``` Loop**

The for-each loop automatically handles the iteration process, so you don't need to worry about index variables or incrementing counters. It iterates through each element in the array or collection, one at a time, and makes the element available to you within the loop's body.

```java
for (dataType element : arrayOrCollection) {
    // Code to be executed for each element
    // You can use the 'element' variable to access the current element
}
```

**Explanation**:

- **dataType**: The data type of the elements in the array or collection.
- **element**: A variable that will hold the current element during each iteration.
- **arrayOrCollection**: The array or collection you want to iterate through.

**Example with Arrays**:

```java
public class ForEachArrayExample {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};

        // Using a for-each loop to print each element in the array
        for (int number : numbers) {
            System.out.println(number);
        }
    }
}
```

```
1
2
3
4
5
```

#### <a name="chapter3part1.4"></a>Chapter 3 - Part 1.4: Using break and continue Statements

The break and continue statements provide additional control over the execution of loops.

**The ```break``` Statement**

The break statement is used to terminate a loop prematurely. When a break statement is encountered inside a loop, the loop is immediately exited, and the program continues with the next statement after the loop.

**Example**:

```java
for (int i = 1; i <= 10; i++) {
    if (i == 5) {
        break; // Exit the loop when i is 5
    }
    System.out.println("Iteration: " + i);
}
```

In this example, the loop is intended to iterate from 1 to 10. However, when i becomes 5, the break statement is executed, and the loop terminates. The output will be:

```
Iteration: 1
Iteration: 2
Iteration: 3
Iteration: 4
```

**The ```continue``` Statement**

The continue statement is used to skip the current iteration of a loop and proceed to the next iteration. When a continue statement is encountered inside a loop, the remaining code in the current iteration is skipped, and the loop proceeds to the next iteration.

**Example**:

```java
for (int i = 1; i <= 10; i++) {
    if (i % 2 == 0) {
        continue; // Skip even numbers
    }
    System.out.println("Iteration: " + i);
}
```

In this example, the loop iterates from 1 to 10. However, when i is an even number (i.e., i % 2 == 0 is true), the continue statement is executed, and the remaining code in the current iteration (the System.out.println() statement) is skipped. The output will be:

```
Iteration: 1
Iteration: 3
Iteration: 5
Iteration: 7
Iteration: 9
```

#### <a name="chapter3part2"></a>Chapter 3 - Part 2: The `if` Statement: Conditional Execution

The if statement is a fundamental building block of control flow in Java, allowing programs to make decisions and execute different code paths based on whether a condition is true or false. It enables programs to respond dynamically to different inputs and situations, making them more versatile and intelligent. Understanding the if statement is crucial for writing programs that can solve real-world problems.

#### <a name="chapter3part2.1"></a>Chapter 3 - Part 2.1: Understanding the if Statement

The if statement in Java allows you to execute a block of code only if a specified condition is true. The basic syntax is as follows:

```java
if (condition) {
    // Code to be executed if the condition is true
}
```

The condition is a boolean expression that evaluates to either true or false. If the condition is true, the code within the curly braces {} is executed. If the condition is false, the code block is skipped, and the program continues with the next statement after the if block.

**Anatomy of an if Statement**

Let's break down the components of an if statement:

- **```if``` Keyword**: This keyword signals the start of the conditional statement.
- **Condition**: This is a boolean expression enclosed in parentheses (). It can be a simple comparison (e.g., x > 5) or a more complex logical expression (e.g., (x > 5) && (y < 10)).
- **Code Block**: This is a block of code enclosed in curly braces {}. This code is executed only if the condition evaluates to true. If the code block contains only one statement, the curly braces can be omitted, but it's generally recommended to always use them for clarity and to avoid potential errors when adding more statements later.

**Boolean Expressions**

The condition within the if statement must be a boolean expression. This means it must evaluate to either true or false. Boolean expressions are typically constructed using:

- **Comparison Operators**: == (equal to), != (not equal to), > (greater than), < (less than), >= (greater than or equal to), <= (less than or equal to).
- **Logical Operators**: && (logical AND), || (logical OR), ! (logical NOT).

For example:

```java
int age = 20;
boolean isAdult = age >= 18; // isAdult will be true

if (isAdult) {
    System.out.println("You are an adult.");
}
```

#### <a name="chapter3part2.2"></a>Chapter 3 - Part 2.2: Practical Examples of the if Statement

Let's explore some practical examples to illustrate how the if statement can be used in Java programs.

**Example 1: Checking if a Number is Positive**

This example demonstrates how to use an if statement to check if a number is positive.

```java
int number = 10;

if (number > 0) {
    System.out.println("The number is positive.");
}
```

In this case, the condition number > 0 evaluates to true because number is 10, which is greater than 0. Therefore, the message "The number is positive." is printed to the console.

**Example 2: Determining if a User is Eligible to Vote**

This example builds upon the previous one and incorporates user input.

```java
import java.util.Scanner;

public class VotingEligibility {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print("Enter your age: ");
        int age = input.nextInt();

        if (age >= 18) {
            System.out.println("You are eligible to vote.");
        }
    }
}
```

This program prompts the user to enter their age. It then uses an if statement to check if the age is greater than or equal to 18. If it is, the program prints "You are eligible to vote."

**Example 3: Checking for Even or Odd Numbers**

This example demonstrates the use of the modulo operator (%) to determine if a number is even or odd.

```java
int number = 7;

if (number % 2 == 0) {
    System.out.println("The number is even.");
}
```

In this case, the condition number % 2 == 0 evaluates to false because 7 divided by 2 has a remainder of 1, which is not equal to 0. Therefore, nothing is printed to the console. To handle the case where the number is odd, you would typically use an if-else statement, which will be covered in the next lesson.

**Example 4: Validating User Input**

This example shows how to use an if statement to validate user input and ensure it falls within a specific range.

```java
import java.util.Scanner;

public class InputValidation {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print("Enter a number between 1 and 100: ");
        int number = input.nextInt();

        if (number >= 1 && number <= 100) {
            System.out.println("You entered a valid number: " + number);
        }
    }
}
```

This program prompts the user to enter a number between 1 and 100. It then uses an if statement with a compound condition (number >= 1 && number <= 100) to check if the number is within the valid range. If it is, the program prints a confirmation message.

**Example 5: Simulating a Simple Login**

This example demonstrates how to use an if statement to simulate a simple login process by comparing a user-entered password with a stored password.

```java
import java.util.Scanner;

public class SimpleLogin {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        String storedPassword = "password123"; // In real applications, passwords should be stored securely
        System.out.print("Enter your password: ");
        String enteredPassword = input.nextLine();

        if (enteredPassword.equals(storedPassword)) {
            System.out.println("Login successful!");
        }
    }
}
```

This program prompts the user to enter their password. It then uses the equals() method to compare the entered password with the stored password. If they match, the program prints "Login successful!". Note that in real-world applications, passwords should be stored securely using hashing and salting techniques.

#### <a name="chapter3part3"></a>Chapter 3 - Part 3: The `if-else` Statement: Choosing Between Two Options

The if-else statement is a fundamental control flow structure in Java (and many other programming languages). It allows your program to execute different blocks of code based on whether a specified condition is true or false. This ability to make decisions is crucial for creating programs that can handle different inputs and situations, making them more versatile and useful. Without conditional statements like if-else, programs would simply execute the same sequence of instructions every time, regardless of the data they are processing.

#### <a name="chapter3part3.1"></a>Chapter 3 - Part 3.1: Understanding the if-else Statement

The if-else statement provides a way to execute one block of code if a condition is true and another block of code if the condition is false. The basic syntax is as follows:

```java
if (condition) {
    // Code to execute if the condition is true
} else {
    // Code to execute if the condition is false
}
```

- **```if``` keyword**: This signals the start of the conditional statement.
- **```condition```**: This is a boolean expression (an expression that evaluates to either true or false). The condition is enclosed in parentheses ().
- **```{}``` (curly braces)**: These define the blocks of code that will be executed based on the condition. The code within the first set of curly braces is executed if the condition is true. The code within the second set of curly braces (following the else keyword) is executed if the condition is false.
- **```else``` keyword**: This keyword introduces the block of code that will be executed when the if condition is false.

**How it Works**

- The program evaluates the condition inside the parentheses of the if statement.
- If the condition evaluates to true, the code block immediately following the if statement (the code within the first set of curly braces) is executed. The code block following the else statement is skipped.
- If the condition evaluates to false, the code block immediately following the if statement is skipped. The code block following the else statement (the code within the second set of curly braces) is executed.
- After either the if block or the else block is executed, the program continues with the next statement after the if-else statement.

**Example 1: Checking if a Number is Positive or Negative**

```java
public class IfElseExample {
    public static void main(String[] args) {
        int number = -10;

        if (number > 0) {
            System.out.println("The number is positive.");
        } else {
            System.out.println("The number is not positive.");
        }
    }
}
```

In this example:

- We declare an integer variable number and initialize it to -10.
- The if statement checks if number > 0. Since -10 is not greater than 0, the condition is false.
- Therefore, the code inside the else block is executed, and the output is "The number is not positive."

**Example 2: Determining Even or Odd**

```java
public class EvenOdd {
    public static void main(String[] args) {
        int number = 7;

        if (number % 2 == 0) {
            System.out.println("The number is even.");
        } else {
            System.out.println("The number is odd.");
        }
    }
}
```

In this example:

- We declare an integer variable number and initialize it to 7.
- The if statement checks if number % 2 == 0. The % operator gives the remainder of a division. If the remainder when number is divided by 2 is 0, then the number is even.
- Since 7 % 2 equals 1 (not 0), the condition is false.
- Therefore, the code inside the else block is executed, and the output is "The number is odd."

**Example 3: Comparing Two Numbers**

```java
public class CompareNumbers {
    public static void main(String[] args) {
        int num1 = 25;
        int num2 = 15;

        if (num1 > num2) {
            System.out.println("num1 is greater than num2");
        } else {
            System.out.println("num1 is not greater than num2");
        }
    }
}
```

In this example:

- We declare two integer variables, num1 and num2.
- The if statement checks if num1 > num2. Since 25 is greater than 15, the condition is true.
- Therefore, the code inside the if block is executed, and the output is "num1 is greater than num2".

#### <a name="chapter3part3.2"></a>Chapter 3 - Part 3.2: Omitting Curly Braces

If the code block within the if or else statement consists of only a single statement, you can omit the curly braces. However, it is generally considered good practice to always include the curly braces, even for single-line blocks, as it improves code readability and reduces the risk of errors when modifying the code later.

**Example (Not Recommended)**:

```java
public class NoBraces {
    public static void main(String[] args) {
        int age = 15;

        if (age >= 18)
            System.out.println("You are an adult.");
        else
            System.out.println("You are a minor.");
    }
}
```

While this code is syntactically correct, it's better to write it as:

```java
public class WithBraces {
    public static void main(String[] args) {
        int age = 15;

        if (age >= 18) {
            System.out.println("You are an adult.");
        } else {
            System.out.println("You are a minor.");
        }
    }
}
```

#### <a name="chapter3part3.3"></a>Chapter 3 - Part 3.3: Nested ```if-else``` Statements

You can nest if-else statements inside other if-else statements to create more complex decision-making logic. This means placing an if-else statement within the code block of another if or else statement.

```java
public class NestedIfElse {
    public static void main(String[] args) {
        int num = 10;

        if (num > 0) {
            System.out.println("The number is positive.");
            if (num % 2 == 0) {
                System.out.println("The number is also even.");
            } else {
                System.out.println("The number is odd.");
            }
        } else {
            System.out.println("The number is not positive.");
        }
    }
}
```

In this example:

- The outer if statement checks if num > 0. Since 10 is greater than 0, the condition is true.
- The code inside the outer if block is executed.
- Inside the outer if block, there is another if-else statement (nested if-else). This inner if statement checks if num % 2 == 0. Since 10 % 2 equals 0, the condition is true.
- Therefore, the code inside the inner if block is executed, and the output is "The number is also even."
- If num was not greater than 0, the else block of the outer if-else statement would have been executed.

#### <a name="chapter3part3.4"></a>Chapter 3 - Part 3.4: Short-Hand if-else

Optional structure to ```if-else``` when you want to decide a **VALUE** based on a condition.

**The Short Hand If...Else Statement**

```java

variable = (condition) ? expressionTrue :  expressionFalse;

```

Instead of writing:

```java

int time = 20;
if (time < 18) {
  System.out.println("Good day.");
} else {
  System.out.println("Good evening.");
}

```

You can simply write:

```java

int time = 20;
String result = (time < 18) ? "Good day." : "Good evening.";
System.out.println(result);

```

#### <a name="chapter3part3.5"></a>Chapter 3 - Part 3.5: Common Errors and Pitfalls

- **Using = instead of ==**: A common mistake is to use the assignment operator = instead of the equality operator == in the condition. This will lead to unexpected behavior and potentially a compilation error.

```java
int x = 5;
if (x = 10) { // Incorrect: assignment operator
    System.out.println("x is 10");
}
```

The correct way to write this is:

```java
int x = 5;
if (x == 10) { // Correct: equality operator
    System.out.println("x is 10");
}
```

- **Missing curly braces**: Forgetting to include curly braces for multi-line code blocks can lead to logical errors. Only the first statement after the if or else will be conditionally executed.

- **Incorrectly nested if-else statements**: Ensure that nested if-else statements are properly aligned and that each if has a corresponding else (if needed) to avoid confusion and logical errors.

#### <a name="chapter3part4"></a>Chapter 3 - Part 4: The `if-else if-else` Statement: Handling Multiple Conditions

The if-else if-else statement is a powerful tool in Java for handling multiple conditions. It allows your program to execute different blocks of code based on which condition evaluates to true. This is essential for creating flexible and responsive applications that can adapt to various inputs and scenarios. Understanding how to use this statement effectively is crucial for building more complex and logical programs.

#### <a name="chapter3part4.1"></a>Chapter 3 - Part 4.1: Understanding the if-else if-else Statement

The if-else if-else statement is an extension of the if and if-else statements. It provides a way to check multiple conditions sequentially. The basic structure is as follows:

```java
if (condition1) {
    // Code to execute if condition1 is true
} else if (condition2) {
    // Code to execute if condition1 is false AND condition2 is true
} else if (condition3) {
    // Code to execute if condition1 and condition2 are false AND condition3 is true
} else {
    // Code to execute if all conditions are false
}
```

**Explanation**:

- The if statement evaluates condition1. If it's true, the code block within the first set of curly braces {} is executed, and the rest of the if-else if-else statement is skipped.
- If condition1 is false, the program moves to the first else if statement and evaluates condition2. If condition2 is true, its corresponding code block is executed, and the rest of the statement is skipped.
- This process continues for each else if statement. The program evaluates each condition in order until it finds one that is true.
- If none of the conditions are true, the code block within the else statement is executed. The else block is optional, but it's good practice to include it to handle cases where none of the specified conditions are met.

**Key Principles**:

- **Order Matters**: The order of the conditions is important. The conditions are evaluated from top to bottom, and the first condition that evaluates to true will have its corresponding code block executed.
- **Mutual Exclusivity**: The if-else if-else statement ensures that only one code block is executed. Once a condition is met, the remaining conditions are not evaluated.
- **Optional else Block**: The else block is optional, but it provides a default action to take when none of the if or else if conditions are met.

**Example 1: Grading System**

Let's create a simple grading system based on a student's score:

```java
public class GradingSystem {
    public static void main(String[] args) {
        int score = 85; // Example score
        char grade;

        if (score >= 90) {
            grade = 'A';
        } else if (score >= 80) {
            grade = 'B';
        } else if (score >= 70) {
            grade = 'C';
        } else if (score >= 60) {
            grade = 'D';
        } else {
            grade = 'F';
        }

        System.out.println("Score: " + score);
        System.out.println("Grade: " + grade);
    }
}
```

**Explanation**:

- The code checks the score against different ranges.
- If the score is 90 or above, the grade is set to 'A'.
- If the score is not 90 or above, but it is 80 or above, the grade is set to 'B'.
- This continues until a condition is met, or the else block is reached, setting the grade to 'F' if the score is below 60.

**Example 2: Determining the Sign of a Number**

This example demonstrates how to use if-else if-else to determine if a number is positive, negative, or zero:

```java
public class SignChecker {
    public static void main(String[] args) {
        int number = -5; // Example number

        if (number > 0) {
            System.out.println("The number is positive.");
        } else if (number < 0) {
            System.out.println("The number is negative.");
        } else {
            System.out.println("The number is zero.");
        }
    }
}
```

**Explanation**:

- The code first checks if the number is greater than 0. If it is, it prints "The number is positive."
- If the number is not greater than 0, it checks if it's less than 0. If it is, it prints "The number is negative."
- If neither of the above conditions is true (i.e., the number is not greater than 0 and not less than 0), the else block is executed, and it prints "The number is zero."

**Example 3: Multiple Discount Levels**

Imagine an e-commerce application where different discount levels are applied based on the total purchase amount.

```java
public class DiscountCalculator {
    public static void main(String[] args) {
        double purchaseAmount = 120.0; // Example purchase amount
        double discountRate = 0.0;

        if (purchaseAmount >= 200) {
            discountRate = 0.20; // 20% discount
        } else if (purchaseAmount >= 100) {
            discountRate = 0.10; // 10% discount
        } else if (purchaseAmount >= 50) {
            discountRate = 0.05; // 5% discount
        } else {
            discountRate = 0.0; // No discount
        }

        double discountAmount = purchaseAmount * discountRate;
        double finalAmount = purchaseAmount - discountAmount;

        System.out.println("Purchase Amount: $" + purchaseAmount);
        System.out.println("Discount Rate: " + (discountRate * 100) + "%");
        System.out.println("Discount Amount: $" + discountAmount);
        System.out.println("Final Amount: $" + finalAmount);
    }
}
```

**Explanation**:

- The code checks the purchaseAmount against different thresholds.
- If the amount is $200 or more, a 20% discount is applied.
- If the amount is between $100 and $200, a 10% discount is applied.
- If the amount is between $50 and $100, a 5% discount is applied.
- Otherwise, no discount is applied.

**Example 4: Hypothetical Scenario - Traffic Light Control**

Consider a hypothetical traffic light control system. The system needs to determine the appropriate action based on the current state of the traffic light.

```java
public class TrafficLight {
    public static void main(String[] args) {
        String lightColor = "yellow"; // Example light color

        if (lightColor.equals("green")) {
            System.out.println("Go!");
        } else if (lightColor.equals("yellow")) {
            System.out.println("Caution! Prepare to stop.");
        } else if (lightColor.equals("red")) {
            System.out.println("Stop!");
        } else {
            System.out.println("Invalid light color.");
        }
    }
}
```

**Explanation**:

- The code checks the lightColor against different possible values.
- If the color is "green", it prints "Go!".
- If the color is "yellow", it prints "Caution! Prepare to stop."
- If the color is "red", it prints "Stop!".
- If the color is none of the above, it prints "Invalid light color." This demonstrates the importance of the else block for handling unexpected or invalid inputs.

#### <a name="chapter3part5"></a>Chapter 3 - Part 5: The `switch` Statement: Selecting from Multiple Cases

The switch statement provides a way to execute different blocks of code based on the value of a single variable or expression. It offers a more structured and often more readable alternative to using multiple if-else if-else statements, especially when dealing with a fixed set of possible values. Understanding how to effectively use switch statements is crucial for writing clean, efficient, and maintainable Java code.

#### <a name="chapter3part5.1"></a>Chapter 3 - Part 5.1: Understanding the switch Statement

The switch statement allows you to select one of several code blocks to execute based on the value of an expression. This expression, often a variable, is evaluated once, and its value is compared against a series of case labels. If a case label matches the value of the expression, the code block associated with that case is executed.

**Syntax of the switch Statement**

The basic syntax of the switch statement in Java is as follows:

```java
switch (expression) {
    case value1:
        // Code to be executed if expression == value1;
        break;
    case value2:
        // Code to be executed if expression == value2;
        break;
    case valueN:
        // Code to be executed if expression == valueN;
        break;
    default:
        // Code to be executed if expression does not match any of the cases;
}
```

- **```switch (expression)```**: The expression is evaluated. It must result in a value of type byte, short, char, int, String, or an enum.
- **```case value1:```**: Each case label specifies a value to compare against the expression. The value must be a constant expression of the same type as the expression.
- **```// Code to be executed```**: This is the block of code that will be executed if the expression matches the case's value.
- **```break;```**: The break statement is crucial. It terminates the switch statement and prevents "fall-through" to the next case. If you omit the break statement, execution will continue to the next case, regardless of whether its value matches the expression.
- **```default:```**: The default label is optional. It specifies a block of code to be executed if the expression does not match any of the case labels.

**The Importance of the break Statement**

The break statement is essential for controlling the flow of execution within a switch statement. Without a break statement at the end of each case block, the program will "fall through" and execute the code in the subsequent case blocks, even if their values do not match the expression. This behavior can be useful in certain situations, but it's more commonly a source of errors if not handled intentionally.

**Example without break (Fall-Through)**:

```java
int day = 2;
String dayType;
switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        dayType = "Weekday";
        System.out.println("It's a Weekday");
    case 6:
    case 7:
        dayType = "Weekend";
        System.out.println("It's a Weekend");
    default:
        System.out.println("Invalid day");
}
```

In this example, because there are no break statements, if day is 2, the output will be:

```
It's a Weekday
It's a Weekend
Invalid day
```

**Example with ```break```**:

```java
int day = 2;
String dayType;
switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        dayType = "Weekday";
        System.out.println("It's a Weekday");
        break;
    case 6:
    case 7:
        dayType = "Weekend";
        System.out.println("It's a Weekend");
        break;
    default:
        System.out.println("Invalid day");
}
```

Now, the output will be:

```
It's a Weekday
```

**Using switch with Different Data Types**

The switch statement in Java can be used with several data types:

- ```int```: Integer values.
- ```char```: Character values.
- ```String```: String values (introduced in Java 7).
- ```enum```: Enumerated types.

**Example with String**:

```java
String fruit = "apple";
switch (fruit) {
    case "apple":
        System.out.println("It's an apple.");
        break;
    case "banana":
        System.out.println("It's a banana.");
        break;
    default:
        System.out.println("Unknown fruit.");
}
```

**Example with enum**:

First, define an enum:

```java
enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}
```

Then, use it in a switch statement:

```java
Day today = Day.WEDNESDAY;
switch (today) {
    case MONDAY:
        System.out.println("It's Monday.");
        break;
    case WEDNESDAY:
        System.out.println("It's Wednesday.");
        break;
    default:
        System.out.println("It's some other day.");
}
```

**The default Case**

The default case is an optional part of the switch statement. It provides a block of code to execute when none of the case values match the expression. It's good practice to include a default case, even if you think all possible values are covered by the case labels. This can help catch unexpected or invalid input.

**Example with default**:

```java
int month = 13; // Invalid month
switch (month) {
    case 1:
        System.out.println("January");
        break;
    case 2:
        System.out.println("February");
        break;
    default:
        System.out.println("Invalid month");
}
```

In this example, since month is 13, which doesn't match any of the case values, the default case will be executed, and "Invalid month" will be printed.

#### <a name="chapter3part5.2"></a>Chapter 3 - Part 5.2: Practical Examples and Demonstrations

Let's explore some practical examples to solidify your understanding of the switch statement.

**Example 1: Simple Calculator**

This example demonstrates a simple calculator that performs addition, subtraction, multiplication, or division based on user input.

```java
import java.util.Scanner;

public class Calculator {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter first number: ");
        double num1 = scanner.nextDouble();

        System.out.print("Enter an operator (+, -, *, /): ");
        char operator = scanner.next().charAt(0);

        System.out.print("Enter second number: ");
        double num2 = scanner.nextDouble();

        double result;

        switch (operator) {
            case '+':
                result = num1 + num2;
                break;
            case '-':
                result = num1 - num2;
                break;
            case '*':
                result = num1 * num2;
                break;
            case '/':
                if (num2 == 0) {
                    System.out.println("Cannot divide by zero.");
                    return;
                }
                result = num1 / num2;
                break;
            default:
                System.out.println("Invalid operator.");
                return;
        }

        System.out.println(num1 + " " + operator + " " + num2 + " = " + result);
        scanner.close();
    }
}
```

This code takes two numbers and an operator as input and performs the corresponding calculation using a switch statement. The default case handles invalid operators.

**Example 2: Determining the Number of Days in a Month**

This example uses a switch statement to determine the number of days in a given month.

```java
public class DaysInMonth {
    public static void main(String[] args) {
        int month = 2; // February
        int year = 2024; // Leap year

        int numDays = 0;

        switch (month) {
            case 1: case 3: case 5:
            case 7: case 8: case 10:
            case 12:
                numDays = 31;
                break;
            case 4: case 6:
            case 9: case 11:
                numDays = 30;
                break;
            case 2:
                if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
                    numDays = 29;
                } else {
                    numDays = 28;
                }
                break;
            default:
                System.out.println("Invalid month.");
        }

        if (numDays > 0) {
            System.out.println("Number of days in " + month + " is " + numDays);
        }
    }
}
```

This example demonstrates how to handle multiple case labels that execute the same code block (e.g., months with 31 days). It also includes a check for leap years when determining the number of days in February.

**Example 3: Traffic Light Simulation**

This example simulates a traffic light using an enum and a switch statement.

```java
enum TrafficLightColor {
    RED, YELLOW, GREEN
}

public class TrafficLight {
    public static void main(String[] args) {
        TrafficLightColor color = TrafficLightColor.GREEN;

        switch (color) {
            case RED:
                System.out.println("Stop!");
                break;
            case YELLOW:
                System.out.println("Caution!");
                break;
            case GREEN:
                System.out.println("Go!");
                break;
            default:
                System.out.println("Invalid traffic light color.");
        }
    }
}
```

This example showcases the use of enum types in a switch statement, making the code more readable and maintainable.

#### <a name="chapter3part6"></a>Chapter 3 - Part 6: The `while` Loop: Repeating Code While a Condition is True

The while loop is a fundamental control flow statement in Java that allows you to repeatedly execute a block of code as long as a specified condition remains true. It's a powerful tool for automating repetitive tasks and creating dynamic programs that respond to changing conditions. Understanding how to use while loops effectively is crucial for writing efficient and maintainable Java code.

#### <a name="chapter3part6.1"></a>Chapter 3 - Part 6.1: Understanding the while Loop

The while loop in Java is used to execute a block of code repeatedly as long as a given condition is true. The condition is evaluated before each iteration of the loop. If the condition is initially false, the loop body will not execute at all.

**Syntax of the while Loop**

The basic syntax of a while loop is as follows:

```java
while (condition) {
    // Code to be executed repeatedly
}
```

- ```while``` keyword: This keyword signifies the start of the while loop.
- ```condition```: This is a boolean expression that is evaluated before each iteration of the loop. If the condition is true, the loop body is executed. If the condition is false, the loop terminates, and the program continues with the next statement after the loop.
- ```{}``` (curly braces): These enclose the block of code that will be executed repeatedly. This block is often referred to as the "loop body." If the loop body consists of only one statement, the curly braces are technically optional, but it's considered good practice to always include them for clarity and to avoid potential errors when adding more statements later.

**How the while Loop Works: Step-by-Step**

- **Evaluate the Condition**: The while loop begins by evaluating the boolean expression specified as the condition.
- **Execute the Loop Body (if true)**: If the condition evaluates to true, the code inside the loop's curly braces (the loop body) is executed.
- **Re-evaluate the Condition**: After the loop body has been executed, the condition is evaluated again.
- **Repeat or Terminate**: If the condition is still true, the loop body is executed again. Steps 3 and 4 are repeated until the condition becomes false. When the condition evaluates to false, the loop terminates, and the program continues executing the code that follows the loop.

**Basic Example: Printing Numbers 1 to 5**

```java
public class WhileLoopExample {
    public static void main(String[] args) {
        int i = 1; // Initialize a counter variable

        while (i <= 5) { // Condition: loop as long as i is less than or equal to 5
            System.out.println(i); // Print the value of i
            i++; // Increment i (very important to avoid infinite loops!)
        }

        System.out.println("Loop finished!"); // This will be printed after the loop terminates
    }
}
```

**Explanation**:

- We initialize an integer variable i to 1. This variable acts as our loop counter.
- The while loop's condition is i <= 5. This means the loop will continue to execute as long as the value of i is less than or equal to 5.
- Inside the loop body, we first print the current value of i using System.out.println(i).
- Then, we increment i by 1 using i++. This is crucial because it ensures that the value of i eventually becomes greater than 5, causing the loop to terminate. Without this increment, the loop would run forever (an infinite loop).
- After the loop finishes, the line System.out.println("Loop finished!"); is executed, demonstrating that the program continues after the loop has terminated.

**Avoiding Infinite Loops**

A common mistake when working with while loops is creating an infinite loop. This occurs when the loop's condition never becomes false, causing the loop to execute indefinitely.

**Example of an Infinite Loop**:

```java
public class InfiniteLoopExample {
    public static void main(String[] args) {
        int i = 1;

        while (i <= 5) {
            System.out.println(i);
            // Missing i++ statement!
        }

        System.out.println("This will never be printed!");
    }
}
```

In this example, the i++ statement is missing. As a result, the value of i remains at 1, and the condition i <= 5 is always true. The loop will print the number 1 repeatedly, forever.

**How to Prevent Infinite Loops**:

- **Ensure the loop's condition will eventually become false**: Make sure that the variables involved in the condition are modified within the loop body in a way that will eventually lead to the condition being false.
- **Double-check your logic**: Carefully review your code to ensure that the condition and the loop body are behaving as you intend.
- **Use a debugger**: A debugger can help you step through your code line by line and observe the values of variables, making it easier to identify the cause of an infinite loop.

#### <a name="chapter3part6.2"></a>Chapter 3 - Part 6.2: Using while Loops with User Input

while loops are often used in conjunction with user input to create interactive programs. The loop can continue to execute until the user enters a specific value or performs a certain action.

**Example: Reading Input Until a Specific Value is Entered**

```java
import java.util.Scanner;

public class InputWhileLoop {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // Create a Scanner object to read input

        int number = 0;

        while (number != -1) { // Loop until the user enters -1
            System.out.print("Enter a number (-1 to quit): ");
            number = scanner.nextInt(); // Read the next integer entered by the user

            if (number != -1) {
                System.out.println("You entered: " + number);
            }
        }

        System.out.println("Goodbye!");
        scanner.close(); // Close the scanner to prevent resource leaks
    }
}
```

**Explanation**:

- We import the java.util.Scanner class, which allows us to read input from the console.
- We create a Scanner object named scanner.
- We initialize an integer variable number to 0.
- The while loop's condition is number != -1. This means the loop will continue to execute as long as the value of number is not equal to -1.
- Inside the loop, we prompt the user to enter a number using System.out.print().
- We read the integer entered by the user using scanner.nextInt() and store it in the number variable.
- We use an if statement to check if the entered number is not -1. If it's not, we print the number back to the user.
- When the user enters -1, the loop terminates, and the program prints "Goodbye!".
- Finally, we close the Scanner object using scanner.close() to release system resources. It's good practice to close the scanner when you're finished with it.

**Example: Validating User Input**

```java
import java.util.Scanner;

public class InputValidation {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int age;

        while (true) { // Infinite loop that breaks when valid input is received
            System.out.print("Enter your age (0-120): ");
            age = scanner.nextInt();

            if (age >= 0 && age <= 120) {
                System.out.println("Your age is: " + age);
                break; // Exit the loop if the input is valid
            } else {
                System.out.println("Invalid age. Please enter a value between 0 and 120.");
            }
        }
        scanner.close();
    }
}
```

**Explanation**:

- This example demonstrates how to use a while loop for input validation.
- The while (true) creates an infinite loop.
- Inside the loop, the program prompts the user to enter their age.
- An if statement checks if the entered age is within the valid range (0-120).
- If the age is valid, the program prints the age and uses the break statement to exit the loop.
- If the age is invalid, the program prints an error message and the loop continues, prompting the user to enter their age again.
- The break statement is crucial here. Without it, the loop would continue indefinitely, even after the user enters a valid age.

#### <a name="chapter3part6.3"></a>Chapter 3 - Part 6.3: Using while Loops with Boolean Flags

A boolean flag is a variable of type boolean that is used to control the execution of a loop. The flag is typically initialized to true and then set to false within the loop when a certain condition is met, causing the loop to terminate.

**Example: Searching for a Value in a Range**

```java
public class BooleanFlagExample {
    public static void main(String[] args) {
        int target = 7;
        int start = 1;
        int end = 10;
        boolean found = false; // Initialize the flag to false

        int current = start;
        while (current <= end) {
            System.out.println("Checking: " + current);
            if (current == target) {
                found = true; // Set the flag to true when the target is found
                break; // Exit the loop
            }
            current++;
        }

        if (found) {
            System.out.println("Target " + target + " found!");
        } else {
            System.out.println("Target " + target + " not found in the range.");
        }
    }
}
```

**Explanation**:

- We initialize a boolean variable found to false. This flag will indicate whether or not the target value has been found within the range.
- The while loop continues as long as current is less than or equal to end.
- Inside the loop, we check if the current value is equal to the target value.
- If the current value is equal to the target value, we set the found flag to true and use the break statement to exit the loop.
- After the loop, we check the value of the found flag. If it's true, we print a message indicating that the target was found. Otherwise, we print a message indicating that the target was not found.

#### <a name="chapter3part6.4"></a>Chapter 3 - Part 6.4: Nested while Loops

Just like if statements, while loops can be nested inside other while loops. This allows you to create more complex control flow structures. Nested loops are often used to process two-dimensional data structures, such as arrays (which we will cover in a later module).

**Example: Printing a Multiplication Table**

```java
public class NestedWhileLoop {
    public static void main(String[] args) {
        int i = 1;

        while (i <= 5) { // Outer loop
            int j = 1;
            while (j <= 5) { // Inner loop
                System.out.print(i * j + "\t"); // Print the product of i and j
                j++;
            }
            System.out.println(); // Move to the next line after each row
            i++;
        }
    }
}
```

**Explanation**:

- The outer while loop iterates from 1 to 5 (controlled by the variable i).
- The inner while loop also iterates from 1 to 5 (controlled by the variable j).
- For each iteration of the outer loop, the inner loop executes completely.
- Inside the inner loop, we print the product of i and j, followed by a tab character (\t) to create spacing between the numbers.
- After the inner loop completes, we print a newline character (\n) to move to the next line, creating the rows of the multiplication table.

#### <a name="chapter3part7"></a>Chapter 3 - Part 7: The `do-while` Loop: Ensuring Code Executes at Least Once

The do-while loop is a fundamental control flow statement in Java, offering a crucial variation on the standard while loop. Its key characteristic is that it guarantees the code block within the loop will execute at least once, regardless of whether the condition is initially true or false. This makes it ideal for scenarios where you need to perform an action before evaluating whether to repeat it. Understanding the do-while loop is essential for creating robust and flexible Java programs.

#### <a name="chapter3part7.1"></a>Chapter 3 - Part 7.1: Understanding the do-while Loop

The do-while loop is a post-test loop, meaning the condition is checked after the loop body executes. This contrasts with the while loop, which is a pre-test loop. The general structure of a do-while loop in Java is as follows:

```java
do {
    // Code to be executed
} while (condition);
```

The code within the do block is executed first. After the execution of the code block, the condition is evaluated. If the condition is true, the loop repeats; otherwise, the loop terminates. It's crucial to remember the semicolon (;) at the end of the while (condition) statement; this is a syntax requirement for the do-while loop.

**Key Differences from the while Loop**

The primary difference between the while and do-while loops lies in when the condition is checked.

|Feature|	while Loop|	do-while Loop|
| :-------------: |  :-------------: |  :-------------: |
|Condition Check|	Before executing the loop body	|After executing the loop body|
|Execution|	May not execute if condition is initially false	|Executes at least once|
|Use Case|	When you might not need to execute the loop body at all	|When you need to execute the loop body at least once|

**Anatomy of a do-while Loop**

Let's break down the components of a do-while loop:

- **```do``` Keyword**: This keyword marks the beginning of the loop's code block.
- **Code Block**: This is the set of statements that will be executed repeatedly as long as the condition is true. It's enclosed in curly braces {}.
- **```while``` Keyword**: This keyword, along with the condition in parentheses, determines whether the loop will continue to iterate.
- **Condition**: This is a boolean expression that is evaluated after each execution of the code block. If it evaluates to true, the loop continues. If it evaluates to false, the loop terminates.
- **Semicolon**: The do-while loop requires a semicolon after the closing parenthesis of the while condition. Forgetting this semicolon is a common syntax error.

#### <a name="chapter3part7.2"></a>Chapter 3 - Part 7.2: Practical Examples of do-while Loops

Let's explore some practical examples to illustrate the use of do-while loops.

**Example 1: Simple Counter**

This example demonstrates a basic counter that prints numbers from 1 to 5 using a do-while loop.

```java
public class DoWhileCounter {
    public static void main(String[] args) {
        int i = 1; // Initialize the counter variable

        do {
            System.out.println("Count: " + i); // Print the current count
            i++; // Increment the counter
        } while (i <= 5); // Continue looping as long as i is less than or equal to 5
    }
}
```

In this example, the code inside the do block will execute at least once, printing "Count: 1". Then, the condition i <= 5 is checked. Since i is 1, the condition is true, and the loop continues until i becomes 6.

**Example 2: User Input Validation**

A common use case for do-while loops is validating user input. This example prompts the user to enter a number between 1 and 10 and continues to prompt them until they enter a valid number.

```java
import java.util.Scanner;

public class InputValidation {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int number;

        do {
            System.out.print("Enter a number between 1 and 10: ");
            number = scanner.nextInt();

            if (number < 1 || number > 10) {
                System.out.println("Invalid input. Please enter a number between 1 and 10.");
            }
        } while (number < 1 || number > 10); // Continue looping if the number is outside the valid range

        System.out.println("You entered: " + number);
        scanner.close();
    }
}
```

Here, the loop always prompts the user for input at least once. The condition number < 1 || number > 10 checks if the input is invalid. If it is, the loop repeats, prompting the user again. This ensures that the program receives valid input before proceeding.

**Example 3: A Simple Game**

Let's create a simple number guessing game using a do-while loop. The program will generate a random number, and the user has to guess it. The loop continues until the user guesses the correct number.

```java
import java.util.Random;
import java.util.Scanner;

public class GuessingGame {
    public static void main(String[] args) {
        Random random = new Random();
        int randomNumber = random.nextInt(100) + 1; // Generate a random number between 1 and 100
        Scanner scanner = new Scanner(System.in);
        int guess;
        int attempts = 0;

        System.out.println("Welcome to the Guessing Game!");

        do {
            System.out.print("Enter your guess (1-100): ");
            guess = scanner.nextInt();
            attempts++;

            if (guess < randomNumber) {
                System.out.println("Too low! Try again.");
            } else if (guess > randomNumber) {
                System.out.println("Too high! Try again.");
            } else {
                System.out.println("Congratulations! You guessed the number in " + attempts + " attempts.");
            }
        } while (guess != randomNumber); // Continue looping until the guess matches the random number

        scanner.close();
    }
}
```

In this game, the user is always prompted to make a guess at least once. The loop continues until the user's guess matches the randomNumber. This demonstrates how do-while loops are useful when you need to execute a block of code before checking a condition.

**Example 4: Menu-Driven Program**

do-while loops are frequently used in menu-driven programs where you want to display a menu and process user choices until the user decides to exit.

```java
import java.util.Scanner;

public class MenuProgram {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int choice;

        do {
            System.out.println("Menu:");
            System.out.println("1. Option 1");
            System.out.println("2. Option 2");
            System.out.println("3. Exit");
            System.out.print("Enter your choice: ");
            choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    System.out.println("You selected Option 1.");
                    break;
                case 2:
                    System.out.println("You selected Option 2.");
                    break;
                case 3:
                    System.out.println("Exiting program.");
                    break;
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        } while (choice != 3); // Continue looping until the user chooses to exit (option 3)

        scanner.close();
    }
}
```

The menu is always displayed at least once. The loop continues until the user enters 3 to exit the program. This pattern is common in interactive command-line applications.

#### <a name="chapter3part8"></a>Chapter 3 - Part 8: The `for` Loop: Repeating Code a Specific Number of Times

The for loop is a fundamental control flow statement in Java, allowing you to execute a block of code repeatedly for a specific number of times. It's a powerful tool for automating repetitive tasks and is widely used in various programming scenarios. Understanding the for loop is crucial for writing efficient and concise Java code. This lesson will delve into the syntax, functionality, and practical applications of the for loop, equipping you with the knowledge to effectively utilize it in your programs.

#### <a name="chapter3part8.1"></a>Chapter 3 - Part 8.1: Understanding the for Loop Syntax

The for loop in Java has a specific syntax that you need to understand to use it correctly. The general structure of a for loop is as follows:

```java
for (initialization; condition; increment/decrement) {
    // Code to be executed repeatedly
}
```

Let's break down each part of the for loop:

- **Initialization**: This is the first part of the for loop, and it's executed only once at the beginning of the loop. It's typically used to declare and initialize a counter variable. For example: int i = 0;
- **Condition**: This is a boolean expression that's evaluated before each iteration of the loop. If the condition is true, the code inside the loop's body is executed. If the condition is false, the loop terminates. For example: i < 10;
- **Increment/Decrement**: This part is executed after each iteration of the loop. It's typically used to update the counter variable. For example: i++; or i--;
- **Loop Body**: This is the block of code that's executed repeatedly as long as the condition is true. It's enclosed in curly braces {}.

#### <a name="chapter3part8.2"></a>Chapter 3 - Part 8.2: How the for Loop Works

The for loop works in the following sequence:

- **Initialization**: The initialization statement is executed only once at the beginning of the loop.
- **Condition Check**: The condition is evaluated.
- **Execution**: If the condition is true, the code inside the loop's body is executed.
- **Increment/Decrement**: After the loop body is executed, the increment/decrement statement is executed.
- **Repeat**: Steps 2-4 are repeated until the condition becomes false.
- **Termination**: When the condition becomes false, the loop terminates, and the program continues with the next statement after the loop.

#### <a name="chapter3part8.3"></a>Chapter 3 - Part 8.3: Practical Examples of for Loops

Let's look at some practical examples of how to use for loops in Java.

**Example 1: Printing Numbers from 1 to 10**

This example demonstrates a basic for loop that prints numbers from 1 to 10.

```java
public class ForLoopExample1 {
    public static void main(String[] args) {
        // Initialize i to 1, loop as long as i is less than or equal to 10, increment i by 1 after each iteration
        for (int i = 1; i <= 10; i++) {
            // Print the value of i
            System.out.println(i);
        }
    }
}
```

In this example:

- ```int i = 1;``` initializes the counter variable i to 1.
- ```i <= 10;``` is the condition that checks if i is less than or equal to 10.
- ```i++;``` increments i by 1 after each iteration.
- ```System.out.println(i);``` prints the value of i in each iteration.

**Example 2: Calculating the Sum of Numbers from 1 to 100**

This example demonstrates how to use a for loop to calculate the sum of numbers from 1 to 100.

```java
public class ForLoopExample2 {
    public static void main(String[] args) {
        int sum = 0; // Initialize the sum to 0

        // Initialize i to 1, loop as long as i is less than or equal to 100, increment i by 1 after each iteration
        for (int i = 1; i <= 100; i++) {
            sum += i; // Add the value of i to the sum
        }

        // Print the final sum
        System.out.println("The sum of numbers from 1 to 100 is: " + sum);
    }
}
```

In this example:

- ```int sum = 0;``` initializes a variable sum to 0 to store the sum of the numbers.
- ```for (int i = 1; i <= 100; i++) is the for loop that iterates from 1 to 100.
- ```sum += i; adds the value of i to the sum in each iteration.
- ```System.out.println("The sum of numbers from 1 to 100 is: " + sum);``` prints the final sum after the loop completes.

**Example 3: Iterating Through an Array**

This example demonstrates how to use a for loop to iterate through an array and print its elements. This builds upon the array concepts introduced in Module 4.

```java
public class ForLoopExample3 {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50}; // Declare and initialize an array of integers

        // Loop through the array using the array's length as the loop's condition
        for (int i = 0; i < numbers.length; i++) {
            // Print the element at index i
            System.out.println("Element at index " + i + ": " + numbers[i]);
        }
    }
}
```

In this example:

- ```int[] numbers = {10, 20, 30, 40, 50};``` declares and initializes an array of integers.
- ```for (int i = 0; i < numbers.length; i++)``` is the for loop that iterates through the array. numbers.length gives the number of elements in the array.
- ```System.out.println("Element at index " + i + ": " + numbers[i]);``` prints the element at index i in each iteration.

**Example 4: Nested for Loops**

This example demonstrates how to use nested for loops to create a multiplication table.

```java
public class ForLoopExample4 {
    public static void main(String[] args) {
        // Outer loop iterates from 1 to 5
        for (int i = 1; i <= 5; i++) {
            // Inner loop iterates from 1 to 5
            for (int j = 1; j <= 5; j++) {
                // Print the product of i and j, followed by a tab
                System.out.print(i * j + "\t");
            }
            // Move to the next line after each row
            System.out.println();
        }
    }
}
```

In this example:

- ```The outer for loop iterates from 1 to 5, representing the rows of the multiplication table.
- ```The inner for loop iterates from 1 to 5, representing the columns of the multiplication table.
- ```System.out.print(i * j + "\t");``` prints the product of i and j, followed by a tab to create spacing.
- ```System.out.println();``` moves to the next line after each row is printed.

#### <a name="chapter3part8.4"></a>Chapter 3 - Part 8.4: Variations of the for Loop

While the standard for loop is commonly used, there are some variations that can be useful in specific situations.

**The Enhanced for Loop (for-each loop)**

The enhanced for loop, also known as the "for-each" loop, is a simplified way to iterate through arrays and collections. It was introduced in Java 5 and provides a more concise syntax for iterating through elements without explicitly managing an index.

```java
public class EnhancedForLoopExample {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};

        // Enhanced for loop to iterate through the array
        for (int number : numbers) {
            System.out.println(number);
        }
    }
}
```

In this example:

- ```for (int number : numbers)``` iterates through each element in the numbers array.
- ```int number``` declares a variable number that represents the current element in the array.
- ```System.out.println(number);``` prints the value of the current element.

The enhanced for loop is simpler and easier to read than the traditional for loop when you only need to access the elements of an array or collection sequentially. However, it doesn't provide access to the index of the elements, so it's not suitable for situations where you need to know the index.

**Infinite for Loop**

An infinite for loop is a loop that never terminates because the condition is always true. It can be created by omitting the condition in the for loop's syntax.

```java
public class InfiniteForLoopExample {
    public static void main(String[] args) {
        // Infinite for loop (condition is always true)
        for (;;) {
            System.out.println("This will print forever!");
        }
    }
}
```

In this example, the for loop has no initialization, condition, or increment/decrement statements. This means that the condition is always considered true, and the loop will continue to execute indefinitely.

Infinite loops are generally not desirable in most programs, as they can cause the program to freeze or crash. However, they can be useful in specific situations, such as in server applications that need to run continuously. You can use break statement (covered in the next lesson) to exit an infinite loop based on a certain condition.

#### <a name="chapter3part8.5"></a>Chapter 3 - Part 8.5: Common Mistakes and How to Avoid Them

When working with for loops, there are some common mistakes that beginners often make. Here are some of them and how to avoid them:

- **Off-by-one errors**: These occur when the loop iterates one too many or one too few times. To avoid this, carefully check the loop's condition and make sure it's correct. For example, if you want to iterate through an array of length n, the loop should iterate from 0 to n - 1, not 0 to n.
- **Incorrect initialization**: Initializing the counter variable to the wrong value can lead to unexpected results. Make sure to initialize the counter variable to the correct starting value.
- **Missing increment/decrement**: Forgetting to increment or decrement the counter variable can cause the loop to run indefinitely or not run at all. Make sure to include the increment/decrement statement in the loop's syntax.
- **Incorrect condition**: Using the wrong condition can cause the loop to terminate prematurely or run indefinitely. Carefully check the condition and make sure it accurately reflects the desired behavior.
- **Modifying the counter variable inside the loop**: Modifying the counter variable inside the loop's body can lead to unpredictable behavior and make the loop difficult to understand. Avoid modifying the counter variable inside the loop unless it's absolutely necessary.

#### <a name="chapter3part9"></a>Chapter 3 - Part 9: Using `break` and `continue` Statements

The break and continue statements are powerful tools in Java for controlling the flow of loops. They allow you to alter the normal execution of a loop based on specific conditions, providing flexibility and efficiency in your code. Understanding how to use these statements effectively is crucial for writing clean and optimized loops.

#### <a name="chapter3part9.1"></a>Chapter 3 - Part 9.1: Understanding the break Statement

The break statement is used to terminate a loop prematurely. When a break statement is encountered inside a loop (either a for, while, or do-while loop), the loop's execution is immediately stopped, and the program control transfers to the next statement after the loop.

**Basic Usage of break**

The most straightforward use of break is to exit a loop when a specific condition is met.

```java
public class BreakExample {
    public static void main(String[] args) {
        for (int i = 1; i <= 10; i++) {
            if (i == 5) {
                break; // Exit the loop when i is 5
            }
            System.out.println("i = " + i);
        }
        System.out.println("Loop finished.");
    }
}
```

In this example, the loop is designed to iterate from 1 to 10. However, when i becomes 5, the break statement is executed, causing the loop to terminate immediately. The output will be:

```
i = 1
i = 2
i = 3
i = 4
Loop finished.
```

**break in Nested Loops**

When dealing with nested loops (a loop inside another loop), the break statement only exits the innermost loop in which it is placed.

```java
public class NestedBreakExample {
    public static void main(String[] args) {
        for (int i = 1; i <= 3; i++) {
            System.out.println("Outer loop: i = " + i);
            for (int j = 1; j <= 3; j++) {
                if (j == 2) {
                    break; // Exit the inner loop when j is 2
                }
                System.out.println("  Inner loop: j = " + j);
            }
        }
    }
}
```

In this case, the break statement is inside the inner loop. When j is 2, only the inner loop terminates, and the outer loop continues its execution. The output will be:

```
Outer loop: i = 1
  Inner loop: j = 1
Outer loop: i = 2
  Inner loop: j = 1
Outer loop: i = 3
  Inner loop: j = 1
```

**Labeled break (Advanced)**

Java allows you to use labeled break statements to exit specific outer loops in nested loop scenarios. This is achieved by placing a label before the loop you want to exit and then using break labelName;.

```java
public class LabeledBreakExample {
    public static void main(String[] args) {
        outerLoop: // Label for the outer loop
        for (int i = 1; i <= 3; i++) {
            System.out.println("Outer loop: i = " + i);
            innerLoop:
            for (int j = 1; j <= 3; j++) {
                if (i == 2 && j == 2) {
                    break outerLoop; // Exit the outer loop when i is 2 and j is 2
                }
                System.out.println("  Inner loop: j = " + j);
            }
        }
        System.out.println("Loop finished.");
    }
}
```

Here, outerLoop is a label assigned to the outer loop. When i is 2 and j is 2, the break outerLoop; statement is executed, causing the outer loop to terminate. The output will be:

```
Outer loop: i = 1
  Inner loop: j = 1
  Inner loop: j = 2
  Inner loop: j = 3
Outer loop: i = 2
  Inner loop: j = 1
Loop finished.
```

#### <a name="chapter3part9.2"></a>Chapter 3 - Part 9.2: Understanding the continue Statement

The continue statement is used to skip the rest of the current iteration of a loop and proceed to the next iteration. When a continue statement is encountered, the remaining code within the loop for that iteration is skipped, and the loop proceeds to evaluate the loop's condition for the next iteration.

**Basic Usage of continue**

The primary use of continue is to bypass certain parts of a loop's body based on a condition.

```java
public class ContinueExample {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            if (i == 3) {
                continue; // Skip the rest of the iteration when i is 3
            }
            System.out.println("i = " + i);
        }
        System.out.println("Loop finished.");
    }
}
```

In this example, when i is 3, the continue statement is executed, causing the System.out.println("i = " + i); line to be skipped for that iteration. The output will be:

```
i = 1
i = 2
i = 4
i = 5
Loop finished.
```

**continue in Nested Loops**

Similar to break, when used in nested loops, continue only affects the innermost loop.

```java
public class NestedContinueExample {
    public static void main(String[] args) {
        for (int i = 1; i <= 3; i++) {
            System.out.println("Outer loop: i = " + i);
            for (int j = 1; j <= 3; j++) {
                if (j == 2) {
                    continue; // Skip the rest of the inner loop iteration when j is 2
                }
                System.out.println("  Inner loop: j = " + j);
            }
        }
    }
}
```

In this case, when j is 2, the continue statement skips the rest of the inner loop's iteration, but the outer loop continues its execution. The output will be:

```
Outer loop: i = 1
  Inner loop: j = 1
  Inner loop: j = 3
Outer loop: i = 2
  Inner loop: j = 1
  Inner loop: j = 3
Outer loop: i = 3
  Inner loop: j = 1
  Inner loop: j = 3
```

**Labeled continue (Advanced)**

Like break, continue can also be used with labels to skip to the next iteration of a specific outer loop.

```java
public class LabeledContinueExample {
    public static void main(String[] args) {
        outerLoop: // Label for the outer loop
        for (int i = 1; i <= 3; i++) {
            System.out.println("Outer loop: i = " + i);
            innerLoop:
            for (int j = 1; j <= 3; j++) {
                if (i == 2 && j == 2) {
                    continue outerLoop; // Skip to the next iteration of the outer loop
                }
                System.out.println("  Inner loop: j = " + j);
            }
        }
    }
}
```

Here, when i is 2 and j is 2, the continue outerLoop; statement is executed, causing the program to skip to the next iteration of the outer loop. The output will be:

```
Outer loop: i = 1
  Inner loop: j = 1
  Inner loop: j = 2
  Inner loop: j = 3
Outer loop: i = 2
  Inner loop: j = 1
Outer loop: i = 3
  Inner loop: j = 1
  Inner loop: j = 2
  Inner loop: j = 3
```

#### <a name="chapter3part9.3"></a>Chapter 3 - Part 9.3: Practical Examples and Demonstrations

**Example 1: Finding the First Even Number**

This example demonstrates how to use break to find the first even number in a range.

```java
public class FindFirstEven {
    public static void main(String[] args) {
        for (int i = 1; i <= 10; i++) {
            if (i % 2 == 0) {
                System.out.println("First even number found: " + i);
                break; // Exit the loop after finding the first even number
            }
        }
    }
}
```

**Example 2: Skipping Multiples of 3**

This example demonstrates how to use continue to skip multiples of 3 when printing numbers from 1 to 10.

```java
public class SkipMultiplesOfThree {
    public static void main(String[] args) {
        for (int i = 1; i <= 10; i++) {
            if (i % 3 == 0) {
                continue; // Skip this iteration if i is a multiple of 3
            }
            System.out.println("i = " + i);
        }
    }
}
```

**Example 3: Searching for an Element in an Array**

This example shows how to use break to efficiently search for a specific element in an array.

```java
public class ArraySearch {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int target = 7;
        boolean found = false;

        for (int number : numbers) {
            if (number == target) {
                System.out.println("Target " + target + " found!");
                found = true;
                break; // Exit the loop once the target is found
            }
        }

        if (!found) {
            System.out.println("Target " + target + " not found in the array.");
        }
    }
}
```

## <a name="chapter4"></a>Chapter 4: Working with Arrays and Strings

#### <a name="chapter4part1"></a>Chapter 4 - Part 1: Introduction to Arrays: Storing Collections of Data

Arrays are fundamental data structures in Java, allowing you to store and manage collections of elements of the same type. They provide a way to organize data efficiently and perform operations on multiple values using a single variable name. Understanding arrays is crucial for various programming tasks, from simple data storage to complex algorithms. This lesson will cover the basics of declaring, initializing, accessing, and looping through arrays in Java, laying the groundwork for more advanced data manipulation techniques.

In programming, "vector" is the name given to one-dimensional arrays.

Array is a data Structure:
- Homogeneous (data of the same type)
- Ordered (elements accessed through positions)
- Allocated at once, in a contiguous block of memory

Advantages:
- Immediate access to elements by their position

Disadvantages:
- Fixed Size
- Difficulty performing insertions and deletions

<br>

<div align="center"><img src="img/array1-w592-h173.png" width=592 height=173><br><sub>Fig 22 - Array - (<a href='https://www.geeksforgeeks.org/arrays-in-java/'>Work by geeksforgeeks</a>) </sub></div>

<br>

Arrays are used to store multiple values in a single variable, instead of declaring separate variables for each value.

To declare an array, define the variable type with **square brackets** ```[]```:

```java

String[] cars;

```

We have now declared a variable that holds an array of strings. To insert values to it, you can place the values in a comma-separated list, inside curly braces:

```java

String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};

```

To create an array of integers, you could write:

```java

int[] myNum = {10, 20, 30, 40};

```

**Access the Elements of an Array**

You can access an array element by referring to the index number.

This statement accesses the value of the first element in cars:

```java

String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
System.out.println(cars[0]);
// Outputs Volvo

```

OBS: Array indexes start with 0: [0] is the first element. [1] is the second element, etc.

**Change an Array Element**

To change the value of a specific element, refer to the index number:

```java

cars[0] = "Opel";

```

```java

String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
cars[0] = "Opel";
System.out.println(cars[0]);
// Now outputs Opel instead of Volvo

```

**Array Length**

To find out how many elements an array has, use the ```length``` property:

```java

String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
System.out.println(cars.length);
// Outputs 4

```

Example: Create a program that reads a certain amount of given double numbers and that in the end they are displayed on the screen

```java

import java.util.Locale;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		int N, i;
		
		System.out.print("How many numbers will be enter? ");
		N = sc.nextInt();
		
		double[] vet = new double[N];
		
		for (i = 0; i < N; i++) {
			System.out.print("Enter a number: ");
			vet[i] = sc.nextDouble();
		}
		
		System.out.println("\nTyped Numbers:");
		for (i = 0; i < N; i++) {
			System.out.println(String.format("%.1f", vet[i]));
		}
		
		sc.close();

	}

}

```


#### <a name="chapter4part1.1"></a>Chapter 4 - Part 1.1: Declaring and Initializing Arrays

In Java, arrays are declared with a specific data type and a fixed size. The declaration specifies the type of elements the array will hold, and the size determines the number of elements the array can store.

**Declaring Arrays**

To declare an array, you use the following syntax:

```java
dataType[] arrayName;
```

- ```dataType```: Specifies the type of elements the array will store (e.g., int, double, String).
- ```[]```: Indicates that you are declaring an array.
- ```arrayName```: The name you choose for the array variable.

For example, to declare an array of integers named numbers, you would write:

```java
int[] numbers;
```

This declaration only creates a reference to an array. It does not allocate any memory to store the array elements.

**Initializing Arrays**

After declaring an array, you need to initialize it to allocate memory and assign initial values to its elements. There are several ways to initialize an array in Java.

**Using the ```new``` Keyword

You can initialize an array using the new keyword, specifying the size of the array:

```java
arrayName = new dataType[arraySize];
```

- ```new```: Allocates memory for the array.
- ```dataType```: The type of elements the array will store.
- ```arraySize```: The number of elements the array can hold. This must be a non-negative integer.

For example, to initialize the numbers array to hold 5 integers, you would write:

```java
numbers = new int[5];
```

This creates an array of 5 integers, with each element initialized to the default value for the int type, which is 0.

**Initializing with Values**

You can also initialize an array with specific values during declaration using an array literal:

```java
dataType[] arrayName = {value1, value2, value3, ...};
```

- ```dataType```: The type of elements the array will store.
- ```arrayName```: The name you choose for the array variable.
- ```{value1, value2, value3, ...}```: An array literal containing the initial values for the array elements. The size of the array is determined by the number of values in the literal.

For example, to initialize an array of strings named names with three names, you would write:

```java
String[] names = {"Alice", "Bob", "Charlie"};
```

This creates an array of 3 strings, with the first element initialized to "Alice", the second to "Bob", and the third to "Charlie".

**Combining Declaration and Initialization**

You can combine the declaration and initialization steps into a single statement:

```java
dataType[] arrayName = new dataType[arraySize]; // Declaration and initialization with size
dataType[] arrayName = {value1, value2, value3, ...}; // Declaration and initialization with values
```

For example:

```java
int[] scores = new int[10]; // Declares an integer array named scores with a size of 10
double[] prices = {19.99, 29.99, 39.99}; // Declares a double array named prices with initial values
```

**Examples**

**Example 1: Initializing an array of integers with a specific size**:

```java
int[] ages = new int[4]; // Creates an integer array named ages with a size of 4
System.out.println(ages[0]); // Output: 0 (default value for int)
```

**Example 2: Initializing an array of strings with values**:

```java
String[] colors = {"red", "green", "blue"}; // Creates a string array named colors with initial values
System.out.println(colors[1]); // Output: green
```

**Example 3: Combining declaration and initialization**:

```java
boolean[] flags = {true, false, true, true}; // Creates a boolean array named flags with initial values
System.out.println(flags[2]); // Output: true
```

#### <a name="chapter4part1.2"></a>Chapter 4 - Part 1.2: Accessing Array Elements

Array elements are accessed using their index, which is an integer value that represents the position of the element in the array. Array indices start at 0 and go up to arraySize - 1.

**Using Indices**

To access an array element, you use the following syntax:

```java
arrayName[index]
```

- ```arrayName```: The name of the array.

- ```index```: The index of the element you want to access. This must be a non-negative integer less than the array size.

For example, to access the first element of the numbers array, you would write:

```java
numbers[0]
```

To access the third element, you would write:

```java
numbers[2]
```

**Assigning Values to Array Elements**

You can also assign values to array elements using their index:

```java
arrayName[index] = value;
```

- ```arrayName```: The name of the array.
- ```index```: The index of the element you want to assign a value to.
- ```value```: The value you want to assign to the element. This must be of the same type as the array's data type.

For example, to assign the value 10 to the first element of the numbers array, you would write:

```java
numbers[0] = 10;
```

**ArrayIndexOutOfBoundsException**

It's important to note that accessing an array element with an invalid index (i.e., an index that is less than 0 or greater than or equal to the array size) will result in an ArrayIndexOutOfBoundsException. This is a common error when working with arrays, so it's crucial to ensure that your indices are within the valid range.

**Examples**

**Example 1: Accessing and assigning values to an integer array**:

```java
int[] scores = new int[5]; // Creates an integer array named scores with a size of 5
scores[0] = 85; // Assigns the value 85 to the first element (index 0)
scores[1] = 90; // Assigns the value 90 to the second element (index 1)
System.out.println(scores[0]); // Output: 85
System.out.println(scores[1]); // Output: 90
```

**Example 2: Accessing and assigning values to a string array**:

```java
String[] names = new String[3]; // Creates a string array named names with a size of 3
names[0] = "Alice"; // Assigns the value "Alice" to the first element (index 0)
names[1] = "Bob"; // Assigns the value "Bob" to the second element (index 1)
System.out.println(names[0]); // Output: Alice
System.out.println(names[1]); // Output: Bob
```

**Example 3: Demonstrating ArrayIndexOutOfBoundsException**:

```java
int[] values = new int[3]; // Creates an integer array named values with a size of 3
// values[3] = 10; // This will cause an ArrayIndexOutOfBoundsException because the valid indices are 0, 1, and 2
```

#### <a name="chapter4part1.3"></a>Chapter 4 - Part 1.3: Looping Through Arrays

Looping through arrays is a common task that allows you to process each element in the array. Java provides several ways to loop through arrays, including the for loop and the enhanced for loop (also known as the "for-each" loop).

**Using the for Loop**

The for loop is a traditional way to iterate through an array using an index.

```java
for (int i = 0; i < arrayName.length; i++) {
    // Access array elements using arrayName[i]
}
```

- ```int i = 0```: Initializes a loop counter i to 0.
- ```i < arrayName.length```: Specifies the loop condition. The loop continues as long as i is less than the length of the array. arrayName.length returns the number of elements in the array.
- ```i++```: Increments the loop counter i after each iteration.
- ```arrayName[i]```: Accesses the element at index i in the array.

For example, to print all the elements of the numbers array, you would write:

```java
int[] numbers = {1, 2, 3, 4, 5};
for (int i = 0; i < numbers.length; i++) {
    System.out.println(numbers[i]);
}
```

This code will print each element of the numbers array to the console.

**Using the Enhanced for Loop (For-Each Loop)**

The enhanced for loop provides a more concise way to iterate through an array without using an index.

```java
for (dataType element : arrayName) {
    // Access each element directly using the element variable
}
```

- ```dataType```: The type of elements in the array.
- ```element```: A variable that represents the current element being processed in the loop.
- ```arrayName```: The name of the array.

For example, to print all the elements of the numbers array using the enhanced for loop, you would write:

```java
int[] numbers = {1, 2, 3, 4, 5};
for (int number : numbers) {
    System.out.println(number);
}
```

This code will also print each element of the numbers array to the console. The enhanced for loop is simpler to use when you only need to access the elements of the array and don't need to know their indices.

**Examples**

**Example 1: Using a for loop to calculate the sum of elements in an integer array**:

```java
int[] values = {10, 20, 30, 40, 50};
int sum = 0;
for (int i = 0; i < values.length; i++) {
    sum += values[i];
}
System.out.println("Sum: " + sum); // Output: Sum: 150
```

**Example 2: Using an enhanced for loop to print the elements of a string array**:

```java
String[] fruits = {"apple", "banana", "orange"};
for (String fruit : fruits) {
    System.out.println(fruit);
}
// Output:
// apple
// banana
// orange
```

**Example 3: Using a for loop to modify elements in an array**:

```java
int[] numbers = {1, 2, 3, 4, 5};
for (int i = 0; i < numbers.length; i++) {
    numbers[i] *= 2; // Multiply each element by 2
}
for (int number : numbers) {
    System.out.println(number);
}
// Output:
// 2
// 4
// 6
// 8
// 10
```

#### <a name="chapter4part2"></a>Chapter 4 - Part 2: Declaring and Initializing Arrays

Arrays are fundamental data structures in Java, allowing you to store and manage collections of elements of the same data type. Understanding how to declare and initialize arrays is crucial for efficiently handling data in your programs. This lesson will provide a comprehensive guide to declaring and initializing arrays in Java, covering various methods and best practices.

#### <a name="chapter4part2.1"></a>Chapter 4 - Part 2.1: Declaring Arrays

Declaring an array in Java involves specifying the data type of the elements it will hold and the name of the array variable. This declaration informs the compiler about the type of data the array will store, but it doesn't allocate any memory space for the array elements.

**Syntax for Array Declaration**

The general syntax for declaring an array is:

```java
dataType[] arrayName; // Preferred way
// or
dataType arrayName[]; // Also valid, but less common
```

- ```dataType```: Specifies the type of elements the array will store (e.g., int, String, double, or a custom class).
- ```[]```: Indicates that the variable is an array.
- ```arrayName```: The identifier (name) you choose for the array variable.

**Examples of Array Declarations**

Here are a few examples of declaring arrays of different data types:

```java
int[] numbers;         // Declares an array of integers
double[] prices;       // Declares an array of doubles
String[] names;         // Declares an array of Strings
boolean[] flags;       // Declares an array of booleans
```

In these examples, we've declared array variables named numbers, prices, names, and flags that can hold collections of integers, doubles, Strings, and booleans, respectively. At this point, these arrays do not yet exist in memory. We've only told the compiler that these names will refer to arrays of the specified types.

#### <a name="chapter4part2.2"></a>Chapter 4 - Part 2.2: Initializing Arrays

Initialization is the process of allocating memory space for the array and assigning initial values to its elements. In Java, arrays are objects, and they must be created using the new keyword.

**Initializing Arrays with a Fixed Size**

You can initialize an array by specifying its size, which determines the number of elements it can hold. All elements will be initialized with default values based on their data type (0 for numeric types, false for booleans, and null for object references).

**Syntax for Fixed-Size Initialization**

```java
dataType[] arrayName = new dataType[arraySize];
```

- ```dataType```: The data type of the array elements.
- ```arrayName```: The name of the array variable.
- ```new```: The keyword used to create a new array object.
- ```arraySize```: An integer specifying the number of elements the array can hold.

**Examples of Fixed-Size Initialization**

```java
int[] numbers = new int[5];       // Creates an array of 5 integers, initialized to 0
double[] prices = new double[10];    // Creates an array of 10 doubles, initialized to 0.0
String[] names = new String[3];      // Creates an array of 3 Strings, initialized to null
boolean[] flags = new boolean[8];     // Creates an array of 8 booleans, initialized to false
```

In these examples, we've created arrays of specific sizes. For instance, numbers can hold 5 integers, and each element is initially set to 0. Similarly, names can hold 3 Strings, and each element is initially null because String is an object.

**Initializing Arrays with Initial Values**

You can also initialize an array by directly providing the initial values for its elements. In this case, the size of the array is automatically determined based on the number of values provided.

**Syntax for Initialization with Values**

```java
dataType[] arrayName = {value1, value2, value3, ...};
```

- ```dataType```: The data type of the array elements.
- ```arrayName```: The name of the array variable.
- ```{}```: Curly braces enclose the initial values.
- ```value1, value2, value3, ...```: The initial values for the array elements, separated by commas.

**Examples of Initialization with Values**

```java
int[] numbers = {1, 2, 3, 4, 5};             // Creates an array of 5 integers with the specified values
double[] prices = {9.99, 19.99, 29.99};       // Creates an array of 3 doubles with the specified values
String[] names = {"Alice", "Bob", "Charlie"};  // Creates an array of 3 Strings with the specified values
boolean[] flags = {true, false, true};        // Creates an array of 3 booleans with the specified values
```

In these examples, the arrays are initialized with specific values. The size of each array is determined by the number of values provided within the curly braces. For example, numbers is an array of size 5, with elements initialized to 1, 2, 3, 4, and 5, respectively.

**Combining Declaration and Initialization**

You can combine the declaration and initialization steps into a single statement:

```java
int[] numbers = new int[5]; // Declaration and fixed-size initialization
int[] values = {10, 20, 30}; // Declaration and initialization with values
```

This approach is concise and often preferred for its readability.

#### <a name="chapter4part2.3"></a>Chapter 4 - Part 2.3: Accessing Array Elements

Array elements are accessed using their index, which is an integer representing the element's position in the array. Array indices start at 0 and go up to arraySize - 1.

**Syntax for Accessing Elements**

```java
arrayName[index]
```

- ```arrayName```: The name of the array.
- ```index```: An integer representing the position of the element you want to access.

**Examples of Accessing Elements**

```java
int[] numbers = {10, 20, 30, 40, 50};

System.out.println(numbers[0]); // Accesses the first element (10)
System.out.println(numbers[2]); // Accesses the third element (30)

numbers[1] = 25; // Modifies the second element to 25
System.out.println(numbers[1]); // Accesses the modified second element (25)
```

In this example, we access and modify elements of the numbers array using their indices. It's important to note that attempting to access an element with an index outside the valid range (0 to arraySize - 1) will result in an ArrayIndexOutOfBoundsException.

#### <a name="chapter4part2.4"></a>Chapter 4 - Part 2.4: Looping Through Arrays

Looping through arrays is a common operation used to process each element in the array. The for loop is particularly well-suited for this purpose. We will cover looping in more detail in the next lesson.

**Example of Looping Through an Array**

```java
int[] numbers = {1, 2, 3, 4, 5};

for (int i = 0; i < numbers.length; i++) {
    System.out.println("Element at index " + i + ": " + numbers[i]);
}
```

In this example, the for loop iterates through each element of the numbers array, printing the index and value of each element. The numbers.length property provides the size of the array, ensuring that the loop iterates through all valid indices.

#### <a name="chapter4part3"></a>Chapter 4 - Part 3: Accessing Array Elements

Arrays are fundamental data structures in Java, allowing you to store and manage collections of elements of the same data type. Accessing these elements is a core operation, enabling you to retrieve, modify, and manipulate the data stored within the array. Understanding how to correctly access array elements is crucial for effectively utilizing arrays in your Java programs. This lesson will cover the different ways to access array elements, potential pitfalls like ArrayIndexOutOfBoundsException, and best practices for working with array indices.

#### <a name="chapter4part3.1"></a>Chapter 4 - Part 3.1: Accessing Array Elements Using Indices

Arrays in Java are zero-indexed, meaning the first element in the array is located at index 0, the second element at index 1, and so on. To access a specific element, you use the array's name followed by the index of the element enclosed in square brackets [].

**Basic Access**

Let's consider an array of integers:

```java
int[] numbers = {10, 20, 30, 40, 50};

// Accessing the first element (index 0)
int firstElement = numbers[0];
System.out.println("First element: " + firstElement); // Output: First element: 10

// Accessing the third element (index 2)
int thirdElement = numbers[2];
System.out.println("Third element: " + thirdElement); // Output: Third element: 30

// Accessing the last element (index 4)
int lastElement = numbers[4];
System.out.println("Last element: " + lastElement); // Output: Last element: 50
```

In this example, numbers[0] accesses the element at index 0, which is 10. Similarly, numbers[2] accesses the element at index 2, which is 30, and numbers[4] accesses the element at index 4, which is 50.

**Modifying Array Elements**

You can also modify the value of an array element using its index:

```java
int[] numbers = {10, 20, 30, 40, 50};

// Modifying the second element (index 1)
numbers[1] = 25;
System.out.println("Second element after modification: " + numbers[1]); // Output: Second element after modification: 25

// Modifying the last element (index 4)
numbers[4] = 55;
System.out.println("Last element after modification: " + numbers[4]); // Output: Last element after modification: 55
```

Here, numbers[1] = 25 changes the value of the element at index 1 from 20 to 25. Likewise, numbers[4] = 55 changes the value of the element at index 4 from 50 to 55.

**Accessing Array Elements in a Loop**

A common task is to iterate through an array and access each element. This is typically done using a for loop. This prepares us for the next lesson on looping through arrays.

```java
int[] numbers = {10, 20, 30, 40, 50};

// Accessing each element using a for loop
for (int i = 0; i < numbers.length; i++) {
    System.out.println("Element at index " + i + ": " + numbers[i]);
}
```

In this code, numbers.length returns the number of elements in the array. The loop iterates from i = 0 to i < numbers.length, accessing each element numbers[i] in turn.

**Example with Strings**

Arrays aren't limited to just numbers. Here's an example using an array of strings:

```java
String[] names = {"Alice", "Bob", "Charlie"};

// Accessing the first name
String firstName = names[0];
System.out.println("First name: " + firstName); // Output: First name: Alice

// Accessing the last name
String lastName = names[2];
System.out.println("Last name: " + lastName); // Output: Last name: Charlie

// Modifying the second name
names[1] = "Robert";
System.out.println("Second name after modification: " + names[1]); // Output: Second name after modification: Robert
```

This example demonstrates accessing and modifying elements within a string array.

#### <a name="chapter4part3.2"></a>Chapter 4 - Part 3.2: ArrayIndexOutOfBoundsException

A common error when working with arrays is the ArrayIndexOutOfBoundsException. This exception occurs when you try to access an array element using an index that is outside the valid range of indices (i.e., less than 0 or greater than or equal to the array's length).

**Understanding the Exception**

Consider the following code:

```java
int[] numbers = {10, 20, 30};

// Attempting to access an element at an invalid index
try {
    int element = numbers[3]; // This will cause an ArrayIndexOutOfBoundsException
    System.out.println("Element: " + element); // This line will not be executed
} catch (ArrayIndexOutOfBoundsException e) {
    System.out.println("Error: ArrayIndexOutOfBoundsException caught!");
}
```

**Avoiding the Exception**

To avoid ArrayIndexOutOfBoundsException, always ensure that the index you are using to access an array element is within the valid range. Before accessing an element, you can check if the index is valid:

```java
int[] numbers = {10, 20, 30};
int index = 3;

if (index >= 0 && index < numbers.length) {
    int element = numbers[index];
    System.out.println("Element at index " + index + ": " + element);
} else {
    System.out.println("Error: Index is out of bounds!");
}
```

In this example, the code checks if the index is within the valid range (0 to numbers.length - 1) before attempting to access the array element. If the index is out of bounds, an error message is printed.

#### <a name="chapter4part3.3"></a>Chapter 4 - Part 3.3: Practical Examples and Demonstrations

**Example 1: Calculating the Sum of Array Elements**

```java
int[] scores = {85, 90, 78, 92, 88};
int sum = 0;

// Calculating the sum of all elements in the array
for (int i = 0; i < scores.length; i++) {
    sum += scores[i];
}

System.out.println("Sum of scores: " + sum); // Output: Sum of scores: 433
```

This example demonstrates how to use a loop to access each element in an array and calculate the sum of all elements.

**Example 2: Finding the Maximum Value in an Array**

```java
int[] values = {45, 23, 89, 12, 56};
int max = values[0]; // Assume the first element is the maximum

// Finding the maximum value in the array
for (int i = 1; i < values.length; i++) {
    if (values[i] > max) {
        max = values[i];
    }
}

System.out.println("Maximum value: " + max); // Output: Maximum value: 89
```

This example shows how to iterate through an array and find the maximum value. It initializes max with the first element and then compares each subsequent element to max, updating max if a larger value is found.

**Example 3: Reversing an Array**

```java
int[] original = {1, 2, 3, 4, 5};
int[] reversed = new int[original.length];

// Reversing the array
for (int i = 0; i < original.length; i++) {
    reversed[original.length - 1 - i] = original[i];
}

// Printing the reversed array
System.out.print("Reversed array: ");
for (int i = 0; i < reversed.length; i++) {
    System.out.print(reversed[i] + " ");
}
// Output: Reversed array: 5 4 3 2 1
```

This example demonstrates how to reverse an array by creating a new array and copying the elements from the original array in reverse order.

#### <a name="chapter4part4"></a>Chapter 4 - Part 4: Looping Through Arrays

Looping through arrays is a fundamental skill in Java programming. It allows you to access and manipulate each element within an array efficiently. This lesson will cover the different types of loops available in Java and how to use them effectively with arrays. Understanding how to iterate through arrays is crucial for performing various operations, such as searching, sorting, and modifying array elements.

#### <a name="chapter4part4.1"></a>Chapter 4 - Part 4.1: Understanding the Need for Loops

Arrays store collections of data of the same type. To work with the data stored in an array, you often need to access each element individually. Loops provide a way to automate this process, allowing you to execute a block of code repeatedly for each element in the array. Without loops, you would have to write separate lines of code to access each element, which is inefficient and impractical for large arrays.

Consider these scenarios:

- **Scenario 1**: Calculating the sum of elements in an array. You need to add up all the numbers stored in an array. A loop allows you to iterate through each element, adding it to a running total.
- **Scenario 2**: Searching for a specific value in an array. You want to find out if a particular value exists in an array. A loop allows you to check each element until you find the value or reach the end of the array.
- **Scenario 3**: Modifying elements in an array. You want to update the values of certain elements in an array based on a specific condition. A loop allows you to apply the condition to each element and modify it accordingly.

#### <a name="chapter4part4.2"></a>Chapter 4 - Part 4.2: Types of Loops in Java

Java provides several types of loops that can be used to iterate through arrays:

- ```for``` loop
- ```while``` loop
- ```do-while``` loop
- Enhanced ```for``` loop (also known as the "for-each" loop)
- Using Streams and Lambda Expressions to Loop Through Arrays

Each loop type has its own syntax and use cases. The for loop and enhanced for loop are the most commonly used for iterating through arrays because they provide a concise and readable way to access each element.

#### <a name="chapter4part4.3"></a>Chapter 4 - Part 4.3: The for Loop

The for loop is a powerful and versatile loop that is often used to iterate through arrays when you know the number of iterations in advance.

**Syntax of the for Loop**

```java
for (initialization; condition; increment/decrement) {
    // Code to be executed
}
```

- **Initialization**: This part is executed only once at the beginning of the loop. It typically involves declaring and initializing a counter variable.
- **Condition**: This is a boolean expression that is evaluated before each iteration of the loop. If the condition is true, the loop continues to execute. If the condition is false, the loop terminates.
- **Increment/Decrement**: This part is executed after each iteration of the loop. It typically involves incrementing or decrementing the counter variable.

**Using the for Loop with Arrays**

To use the for loop with arrays, you typically use the counter variable as an index to access each element of the array.

```java
public class ForLoopArray {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};

        // Iterate through the array using a for loop
        for (int i = 0; i < numbers.length; i++) {
            System.out.println("Element at index " + i + ": " + numbers[i]);
        }
    }
}
```

In this example:

- ```int i = 0;``` initializes the counter variable i to 0. This is the index of the first element in the array.
- ```i < numbers.length;``` is the condition that checks if the counter variable i is less than the length of the array. The length property of an array returns the number of elements in the array.
- ```i++;``` increments the counter variable i by 1 after each iteration. This moves to the next element in the array.
- ```System.out.println("Element at index " + i + ": " + numbers[i]);``` prints the value of the element at the current index i.

**Example: Calculating the Sum of Array Elements**

```java
public class SumArray {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};
        int sum = 0;

        // Calculate the sum of the elements in the array
        for (int i = 0; i < numbers.length; i++) {
            sum += numbers[i]; // sum = sum + numbers[i];
        }

        System.out.println("Sum of array elements: " + sum);
    }
}
```

In this example, the for loop iterates through each element of the numbers array, adding it to the sum variable. After the loop finishes, the sum variable contains the total sum of all the elements in the array.

**Example: Modifying Array Elements**

```java
public class ModifyArray {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};

        // Multiply each element in the array by 2
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = numbers[i] * 2;
        }

        // Print the modified array
        System.out.println("Modified array:");
        for (int i = 0; i < numbers.length; i++) {
            System.out.println(numbers[i]);
        }
    }
}
```

In this example, the for loop iterates through each element of the numbers array, multiplying it by 2 and updating the element's value. After the loop finishes, all the elements in the array have been modified.

#### <a name="chapter4part4.4"></a>Chapter 4 - Part 4.4: The Enhanced for Loop (For-Each Loop)

The enhanced for loop, also known as the "for-each" loop, provides a simpler and more concise way to iterate through arrays. It automatically iterates through each element of the array without requiring you to manage the index.

**Syntax of the Enhanced for Loop**

```java
for (dataType element : arrayName) {
    // Code to be executed
}
```

- **dataType**: The data type of the elements in the array.
- **element**: A variable that represents the current element being processed in the loop.
- **arrayName**: The name of the array you want to iterate through.

**Using the Enhanced for Loop with Arrays**

```java
public class EnhancedForLoopArray {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};

        // Iterate through the array using an enhanced for loop
        for (int number : numbers) {
            System.out.println("Element: " + number);
        }
    }
}
```

In this example:

- ```int number : numbers``` declares a variable number of type int that will hold the value of each element in the numbers array during each iteration of the loop.
- The loop automatically iterates through each element of the numbers array, assigning the value of the current element to the number variable.
- ```System.out.println("Element: " + number);``` prints the value of the current element.

**Example: Calculating the Sum of Array Elements (Enhanced for Loop)**

```java
public class SumArrayEnhanced {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};
        int sum = 0;

        // Calculate the sum of the elements in the array using an enhanced for loop
        for (int number : numbers) {
            sum += number;
        }

        System.out.println("Sum of array elements: " + sum);
    }
}
```

This example demonstrates how to calculate the sum of array elements using the enhanced for loop. The code is more concise and easier to read compared to using a traditional for loop.

**When to Use the Enhanced for Loop**

The enhanced for loop is ideal when you need to access each element of an array sequentially and you don't need to know the index of the element. It simplifies the code and makes it more readable.

However, the enhanced for loop has some limitations:

- You cannot modify the array elements directly within the loop. Any changes made to the element variable will not affect the original array.
- You cannot access the index of the current element.
- You cannot iterate through the array in reverse order.

If you need to perform any of these operations, you should use a traditional for loop instead.

#### <a name="chapter4part4.5"></a>Chapter 4 - Part 4.5: The while Loop

The while loop is another type of loop that can be used to iterate through arrays. It continues to execute a block of code as long as a specified condition is true.

**Syntax of the while Loop**

```java
while (condition) {
    // Code to be executed
}
```

- **Condition**: This is a boolean expression that is evaluated before each iteration of the loop. If the condition is true, the loop continues to execute. If the condition is false, the loop terminates.

**Using the while Loop with Arrays**

To use the while loop with arrays, you need to manually manage the index of the array.

```java
public class WhileLoopArray {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};
        int i = 0; // Initialize the index

        // Iterate through the array using a while loop
        while (i < numbers.length) {
            System.out.println("Element at index " + i + ": " + numbers[i]);
            i++; // Increment the index
        }
    }
}
```

In this example:

- ```int i = 0;``` initializes the index variable i to 0.
- ```while (i < numbers.length)``` is the condition that checks if the index i is less than the length of the array.
- ```System.out.println("Element at index " + i + ": " + numbers[i]);``` prints the value of the element at the current index i.
- ```i++;``` increments the index i by 1 after each iteration.

**Example: Searching for a Specific Value in an Array (While Loop)**

```java
public class SearchArrayWhile {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};
        int target = 30;
        int i = 0;
        boolean found = false;

        // Search for the target value in the array using a while loop
        while (i < numbers.length) {
            if (numbers[i] == target) {
                found = true;
                break; // Exit the loop if the target is found
            }
            i++;
        }

        if (found) {
            System.out.println("Target " + target + " found in the array.");
        } else {
            System.out.println("Target " + target + " not found in the array.");
        }
    }
}
```

In this example, the while loop iterates through the numbers array until the target value is found or the end of the array is reached. The break statement is used to exit the loop when the target is found.

**When to Use the while Loop**

The while loop is useful when you don't know the number of iterations in advance, and the loop should continue as long as a certain condition is true. In the context of arrays, it's less commonly used than the for loop or enhanced for loop, especially when you need to iterate through all elements sequentially. However, it can be useful for scenarios like searching or processing elements until a specific condition is met.

#### <a name="chapter4part4.6"></a>Chapter 4 - Part 4.6: The do-while Loop

The do-while loop is similar to the while loop, but it guarantees that the code block is executed at least once, even if the condition is initially false.

**Syntax of the do-while Loop**

```java
do {
    // Code to be executed
} while (condition);
```

- **Condition**: This is a boolean expression that is evaluated after each iteration of the loop. If the condition is true, the loop continues to execute. If the condition is false, the loop terminates.

**Using the do-while Loop with Arrays**

```java
public class DoWhileLoopArray {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};
        int i = 0;

        // Iterate through the array using a do-while loop
        do {
            System.out.println("Element at index " + i + ": " + numbers[i]);
            i++;
        } while (i < numbers.length);
    }
}
```

In this example, the code block inside the do block is executed at least once, even if the condition i < numbers.length is initially false (which it isn't in this case).

**When to Use the do-while Loop**

The do-while loop is useful when you want to ensure that a block of code is executed at least once, regardless of the initial condition. In the context of arrays, this is less common than using a for or while loop. A potential use case might be when you need to process the first element of an array before deciding whether to continue iterating through the rest of the array. However, in most array processing scenarios, a for or while loop is more appropriate.

#### <a name="chapter4part4.7"></a>Chapter 4 - Part 4.7: Using Streams and Lambda Expressions to Loop Through Arrays

This is a feature that became more prominent with the introduction of Streams in Java 8.

- **1**: Convert Array to Stream
  - First, you need to convert your array into a Stream. Java provides convenient ways to do this using the java.util.Arrays class.
 
- **2**: Use forEach with a Lambda
  - The Stream interface has a forEach method that accepts a Consumer functional interface. A lambda expression can be used to implement the Consumer, allowing you to define the action to perform on each element of the stream (and thus, each element of the array).
 
Here's a breakdown with an example:

```java
import java.util.Arrays;

public class ArrayLooping {

    public static void main(String[] args) {
        String[] names = {"Alice", "Bob", "Charlie", "David"};

        // Using streams and lambda to print each name
        Arrays.stream(names).forEach(name -> System.out.println("Hello, " + name + "!"));

        //Another example with integers
        int[] numbers = {1, 2, 3, 4, 5};
        Arrays.stream(numbers).forEach(number -> System.out.println("Number: " + number));

        // Using a method reference (a shorthand for a lambda in some cases)
        Arrays.stream(names).forEach(System.out::println);
    }
}
```

- ```Arrays.stream(names)```: This converts the names array into a Stream<String>. For primitive type arrays (like int[]), there are specialized streams like IntStream, LongStream, and DoubleStream that you should use (e.g., Arrays.stream(numbers) returns an IntStream).
- ```.forEach(name -> System.out.println("Hello, " + name + "!"))```: This is the core of the lambda expression.
  - ```forEach``` is a terminal operation on the stream, meaning it triggers the processing of the stream.
  - ```name -> System.out.println("Hello, " + name + "!")``` is a lambda expression. It takes each element from the stream (which represents an element from the array) and assigns it to the variable name. Then, it executes the code on the right side of the ->, which in this case prints a greeting to the console.
- ```System.out::println```: This is a method reference. It's equivalent to the lambda name -> System.out.println(name). It's a more concise way to write the lambda when you're simply calling a method on the element.

**Advantages of Using Streams and Lambdas for Looping:**

- **Conciseness**: The code is often more compact and readable than traditional for loops, especially for simple operations.

- **Functional Style**: It encourages a more functional programming style, which can lead to more maintainable and testable code.

- **Parallelism (Potential)**: Streams can be easily processed in parallel, which can significantly improve performance for large arrays and computationally intensive operations (though you need to be careful about thread safety).

**Important Considerations:**

- **Not a Replacement for All Loops**: While streams and lambdas are powerful, they are not always the best choice. For very simple loops where you just need to iterate through the array once, a traditional for loop might be more straightforward. Also, if you need to modify the original array in place during the loop, streams are generally not the right tool. Streams are designed for creating new collections or performing actions on elements, not for directly mutating the source array.

- **Primitive Type Streams**: Remember to use IntStream, LongStream, and DoubleStream when working with arrays of primitive types (int, long, double) to avoid boxing/unboxing overhead.

- **Terminal Operations**: forEach is a terminal operation. Once you call a terminal operation on a stream, you can't reuse that stream. If you need to perform multiple operations on the same data, you'll need to create a new stream.

#### <a name="chapter4part5"></a>Chapter 4 - Part 5: Multidimensional Arrays

Multidimensional arrays extend the concept of single-dimensional arrays by allowing you to store data in a grid-like structure, similar to a table with rows and columns. This is incredibly useful for representing data that has inherent two-dimensional or higher-dimensional relationships, such as game boards, image pixels, or spreadsheet data. Understanding how to declare, initialize, access, and manipulate multidimensional arrays is a fundamental skill for any Java programmer.

A multidimensional array is an array of arrays.

In programming, "Matriz" is the name given to two-dimensional arrays.
obs: array is an array of arrays.

Array is a data Structure:
- Homogeneous (data of the same type)
- Ordered (elements accessed through positions)
- Allocated at once, in a contiguous block of memory

Advantages:
- Immediate access to elements by their position

Disadvantages:
- Fixed Size
- Difficulty performing insertions and deletions

To create a two-dimensional array, add each array within its own set of **curly braces** ```[][]```:

<br>

<div align="center"><img src="img/array2-w740-h282.png" width=740 height=282><br><sub>Fig 23 - Multidimensional Array - (<a href='https://www.geeksforgeeks.org/multidimensional-arrays-in-java/?ref=lbp'>Work by geeksforgeeks</a>) </sub></div>

<br>

```java

int[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };

```

**myNumbers** is now an array with two arrays as its elements.

To access the elements of the **myNumbers** array, specify two indexes: one for the array, and one for the element inside that array. This example accesses the third element (2) in the second array (1) of myNumbers:

```java

int[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };
int x = myNumbers[1][2];
System.out.println(x); // Outputs 7

```

We can also use a ```for loop``` inside another ```for loop``` to get the elements of a two-dimensional array (we still have to point to the two indexes):

```java

public class Main {
  public static void main(String[] args) {
    int[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };
    for (int i = 0; i < myNumbers.length; ++i) {
      for(int j = 0; j < myNumbers[i].length; ++j) {
        System.out.println(myNumbers[i][j]);
      }
    }
  }
}

```

Example: Create a Matrix

```java

import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		
		int M, N, i, j;
		
		System.out.print("How many rows the matrix will be? ");
		M = sc.nextInt();
		System.out.print("How many columns the matrix will be? ");
		N = sc.nextInt();
		
		int[][] mat = new int[M][N];
		
		for (i = 0; i < M; i++) {
			for (j = 0; j < N; j++) {
				System.out.print("Element [" + i + "," + j + "]: ");
				mat[i][j] = sc.nextInt();
			}
		}
		
		System.out.println("\nTyped Matrix:");
		for (i = 0; i < M; i++) {
			for (j = 0; j < N; j++) {
				System.out.print(mat[i][j] + " ");	
			}
			System.out.println();
		}
		
		sc.close();
	}

}

```

#### <a name="chapter4part5.1"></a>Chapter 4 - Part 5.1: Understanding Multidimensional Arrays

A multidimensional array is essentially an array of arrays. The most common type is a two-dimensional array, which can be visualized as a table with rows and columns. You can also have arrays with three or more dimensions, although they are less frequently used.

**Declaring Multidimensional Arrays**

To declare a two-dimensional array, you use the following syntax:

```
dataType[][] arrayName;
```

For example, to declare a two-dimensional array of integers named matrix, you would write:

```java
int[][] matrix;
```

This declaration only creates a reference to an array. To actually create the array, you need to allocate memory for it.

**Initializing Multidimensional Arrays**

There are several ways to initialize a multidimensional array:

- **Using new keyword**: You can specify the number of rows and columns when creating the array:

```java
int[][] matrix = new int[3][4]; // Creates a 3x4 matrix (3 rows, 4 columns)
```

This creates a matrix where all elements are initialized to the default value for the int data type, which is 0.

- **Using an initializer list**: You can directly provide the values for the array elements:

```java
int[][] matrix = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};
```

This creates a 3x4 matrix with the specified values. Each inner set of curly braces represents a row in the matrix.

- **Combining declaration and initialization**:

```java
int[][] matrix;
matrix = new int[][] {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};
```

This is equivalent to the previous method but separates the declaration and initialization steps.

**Accessing Array Elements**

To access an element in a two-dimensional array, you use two indices: the row index and the column index. Array indices start at 0.

```java
int[][] matrix = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

int element = matrix[1][2]; // Accesses the element at row 1, column 2 (value is 7)
System.out.println(element); // Output: 7

matrix[0][0] = 100; // Modifies the element at row 0, column 0
System.out.println(matrix[0][0]); // Output: 100
```

**Looping Through Multidimensional Arrays**

You typically use nested loops to iterate through all the elements of a multidimensional array. The outer loop iterates through the rows, and the inner loop iterates through the columns.

```java
int[][] matrix = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

for (int i = 0; i < matrix.length; i++) { // Iterate through rows
    for (int j = 0; j < matrix[i].length; j++) { // Iterate through columns in the current row
        System.out.print(matrix[i][j] + " ");
    }
    System.out.println(); // Move to the next line after printing each row
}
```

This code will print the following output:

```
1 2 3 4
5 6 7 8
9 10 11 12
```

**Example: Game Board**

Consider a simple game board represented by a 2D array:

```java
char[][] board = new char[3][3]; // Creates a 3x3 board

// Initialize the board with empty spaces
for (int i = 0; i < board.length; i++) {
    for (int j = 0; j < board[i].length; j++) {
        board[i][j] = ' ';
    }
}

// Place an 'X' on the board
board[1][1] = 'X';

// Print the board
for (int i = 0; i < board.length; i++) {
    for (int j = 0; j < board[i].length; j++) {
        System.out.print(board[i][j] + " | ");
    }
    System.out.println();
    if (i < board.length - 1) {
        System.out.println("---------");
    }
}
```

This code will output:

```
  |   |   |
---------
  | X |   |
---------
  |   |   |
```

**Ragged Arrays**

In Java, you can create "ragged" or "jagged" arrays, where each row can have a different number of columns. This is achieved by creating an array of arrays where the inner arrays have different lengths.

```java
int[][] raggedArray = new int[3][]; // Creates an array with 3 rows, but no columns are defined yet

raggedArray[0] = new int[4]; // Row 0 has 4 columns
raggedArray[1] = new int[2]; // Row 1 has 2 columns
raggedArray[2] = new int[5]; // Row 2 has 5 columns

// Initialize the ragged array
for (int i = 0; i < raggedArray.length; i++) {
    for (int j = 0; j < raggedArray[i].length; j++) {
        raggedArray[i][j] = i * 10 + j;
    }
}

// Print the ragged array
for (int i = 0; i < raggedArray.length; i++) {
    for (int j = 0; j < raggedArray[i].length; j++) {
        System.out.print(raggedArray[i][j] + " ");
    }
    System.out.println();
}
```

This code will output:

```
0 1 2 3
10 11
20 21 22 23 24
```

**Three-Dimensional Arrays (and Beyond)**

While less common, Java supports arrays with three or more dimensions. A three-dimensional array can be thought of as a cube of data.

```java
int[][][] cube = new int[3][3][3];

// Initialize the cube
for (int i = 0; i < cube.length; i++) {
    for (int j = 0; j < cube[i].length; j++) {
        for (int k = 0; k < cube[i][j].length; k++) {
            cube[i][j][k] = i * 100 + j * 10 + k;
        }
    }
}

// Access an element
System.out.println(cube[1][2][0]); // Output: 120
```

The same principles apply to arrays with higher dimensions: you declare them with additional square brackets, initialize them using nested loops or initializer lists, and access elements using multiple indices.

#### <a name="chapter4part5.2"></a>Chapter 4 - Part 5.2: Practical Examples and Demonstrations

**Example 1: Calculating the Sum of Elements in a Matrix**

```java
public class MatrixSum {
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };

        int sum = 0;
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                sum += matrix[i][j];
            }
        }

        System.out.println("Sum of all elements: " + sum); // Output: Sum of all elements: 45
    }
}
```

This example demonstrates how to calculate the sum of all elements in a two-dimensional array using nested loops.

**Example 2: Finding the Maximum Element in a Matrix**

```java
public class MatrixMax {
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 20, 3},
            {4, 5, 60},
            {70, 8, 9}
        };

        int max = matrix[0][0]; // Initialize max with the first element
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                if (matrix[i][j] > max) {
                    max = matrix[i][j];
                }
            }
        }

        System.out.println("Maximum element: " + max); // Output: Maximum element: 70
    }
}
```

This example shows how to find the maximum element in a two-dimensional array by iterating through all elements and comparing them to the current maximum.

**Example 3: Matrix Multiplication**

```java
public class MatrixMultiplication {
    public static void main(String[] args) {
        int[][] matrixA = {
            {1, 2},
            {3, 4}
        };

        int[][] matrixB = {
            {5, 6},
            {7, 8}
        };

        int rowsA = matrixA.length;
        int colsA = matrixA[0].length;
        int rowsB = matrixB.length;
        int colsB = matrixB[0].length;

        if (colsA != rowsB) {
            System.out.println("Matrices cannot be multiplied.");
            return;
        }

        int[][] result = new int[rowsA][colsB];

        for (int i = 0; i < rowsA; i++) {
            for (int j = 0; j < colsB; j++) {
                for (int k = 0; k < colsA; k++) {
                    result[i][j] += matrixA[i][k] * matrixB[k][j];
                }
            }
        }

        // Print the result matrix
        System.out.println("Resultant Matrix:");
        for (int i = 0; i < rowsA; i++) {
            for (int j = 0; j < colsB; j++) {
                System.out.print(result[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

This example demonstrates matrix multiplication, a common operation in linear algebra and computer graphics. It highlights the use of nested loops to perform the necessary calculations.

#### <a name="chapter4part6"></a>Chapter 4 - Part 6: Introduction to Strings: Working with Text

Strings are fundamental to programming, as they allow us to represent and manipulate text, which is a crucial part of almost any application. From displaying messages to users to processing data from files, strings are everywhere. This lesson will introduce you to the concept of strings in Java, how to create them, and some of the basic operations you can perform on them. Understanding strings is essential for building more complex and interactive programs.

#### <a name="chapter4part6.1"></a>Chapter 4 - Part 6.1: Creating Strings

In Java, a string is an object that represents a sequence of characters. Unlike primitive data types like int or boolean, strings are objects of the String class. There are two primary ways to create strings in Java: using string literals and using the new keyword.

**String Literals**

The most common way to create a string is by using a string literal. A string literal is a sequence of characters enclosed in double quotes.

```java
String message = "Hello, world!";
String name = "Alice";
String emptyString = ""; // An empty string
```

When you create a string literal, Java checks if a string with the same content already exists in the string pool. The string pool is a special memory area in the Java Virtual Machine (JVM) that stores string literals. If the string already exists, Java will simply return a reference to the existing string in the pool. If it doesn't exist, Java will create a new string object in the pool and return a reference to it. This mechanism is called string interning and it helps to save memory and improve performance.

**Using the new Keyword**

You can also create a string using the new keyword, just like creating any other object in Java.

```java
String message = new String("Hello, world!");
String name = new String("Alice");
```

When you use the new keyword, Java always creates a new string object in the heap memory, regardless of whether a string with the same content already exists in the string pool. This means that using new to create strings is generally less efficient than using string literals.

**Example**:

```java
String str1 = "Hello";
String str2 = "Hello";
String str3 = new String("Hello");
String str4 = new String("Hello");

System.out.println(str1 == str2); // Output: true (both refer to the same string in the string pool)
System.out.println(str1 == str3); // Output: false (str1 is in the string pool, str3 is in the heap)
System.out.println(str3 == str4); // Output: false (both are different objects in the heap)
```

In the above example, str1 and str2 both refer to the same string object in the string pool. However, str3 and str4 are different string objects in the heap memory, even though they have the same content. This distinction is important when comparing strings, as we'll see later.

#### <a name="chapter4part6.2"></a>Chapter 4 - Part 6.2: String Manipulation

Strings in Java are immutable, which means that once a string object is created, its value cannot be changed. Any operation that appears to modify a string actually creates a new string object. This immutability has several advantages, such as thread safety and the ability to cache string hash codes.

**Concatenation**

String concatenation is the process of joining two or more strings together to create a new string. In Java, you can concatenate strings using the + operator or the concat() method.

**Using the + Operator**

The + operator is the most common and convenient way to concatenate strings in Java.

```java
String firstName = "John";
String lastName = "Doe";
String fullName = firstName + " " + lastName; // Concatenating with a space in between
System.out.println(fullName); // Output: John Doe
```

When you use the + operator to concatenate a string with a value of another data type (e.g., an integer or a boolean), Java automatically converts the other value to a string before performing the concatenation.

```java
String age = "30";
String message = "He is " + age + " years old.";
System.out.println(message); // Output: He is 30 years old.
```

**Using the concat() Method**

The String class also provides a concat() method that you can use to concatenate strings.

```java
String str1 = "Hello";
String str2 = " World";
String result = str1.concat(str2);
System.out.println(result); // Output: Hello World
```

The concat() method takes a single string argument and returns a new string that is the result of concatenating the original string with the argument.

**Performance Considerations**:

While both the + operator and the concat() method can be used for string concatenation, the + operator is generally more efficient, especially when concatenating multiple strings. This is because the Java compiler optimizes the + operator to use a StringBuilder object internally, which is more efficient for performing multiple concatenations. For simple concatenations, the performance difference is negligible. However, when performing a large number of concatenations in a loop, using a StringBuilder directly can significantly improve performance. We will cover StringBuilder in a later lesson.

**Substrings**

A substring is a contiguous sequence of characters within a string. The String class provides the substring() method to extract substrings from a string.

The substring() method has two overloaded versions:

- ```substring(int beginIndex)```: Returns a substring starting from the specified beginIndex to the end of the string.
- ```substring(int beginIndex, int endIndex)```: Returns a substring starting from the specified beginIndex up to (but not including) the specified endIndex.

```java
String message = "Hello, world!";

String sub1 = message.substring(7); // Substring from index 7 to the end
System.out.println(sub1); // Output: world!

String sub2 = message.substring(0, 5); // Substring from index 0 up to (but not including) index 5
System.out.println(sub2); // Output: Hello
```

**Important Notes**:

- The beginIndex is inclusive, meaning the character at that index is included in the substring.
- The endIndex is exclusive, meaning the character at that index is not included in the substring.
- The beginIndex must be between 0 and the length of the string (inclusive).
- The endIndex must be between 0 and the length of the string (inclusive).
- The beginIndex must be less than or equal to the endIndex.
- If any of these conditions are not met, the substring() method will throw a StringIndexOutOfBoundsException.

**Length**

The length() method returns the number of characters in a string.

```java
String message = "Hello, world!";
int length = message.length();
System.out.println(length); // Output: 13
```

The length of a string includes all characters, including spaces and punctuation marks.

#### <a name="chapter4part6.3"></a>Chapter 4 - Part 6.3: String Comparison: equals() vs. ==

Comparing strings in Java can be tricky because strings are objects. You need to understand the difference between comparing the content of strings and comparing the references to string objects.

**The equals() Method**

The equals() method compares the content of two strings. It returns true if the strings have the same sequence of characters, and false otherwise.

```java
String str1 = "Hello";
String str2 = "Hello";
String str3 = new String("Hello");

System.out.println(str1.equals(str2)); // Output: true (same content)
System.out.println(str1.equals(str3)); // Output: true (same content)
```

The equals() method is case-sensitive, meaning that "Hello" is not equal to "hello". If you want to perform a case-insensitive comparison, you can use the equalsIgnoreCase() method.

```java
String str1 = "Hello";
String str2 = "hello";

System.out.println(str1.equals(str2)); // Output: false (different case)
System.out.println(str1.equalsIgnoreCase(str2)); // Output: true (same content, ignoring case)
```

**The == Operator**

The == operator compares the references of two string objects. It returns true if the two variables refer to the same object in memory, and false otherwise.

```java
String str1 = "Hello";
String str2 = "Hello";
String str3 = new String("Hello");

System.out.println(str1 == str2); // Output: true (both refer to the same string in the string pool)
System.out.println(str1 == str3); // Output: false (str1 is in the string pool, str3 is in the heap)
```

As we saw earlier, string literals are interned in the string pool, so if you create two string literals with the same content, they will both refer to the same object in memory. However, if you create a string using the new keyword, it will always create a new object in the heap memory, even if a string with the same content already exists in the string pool.

**Best Practice**:

Always use the equals() method to compare the content of strings. Avoid using the == operator unless you specifically need to check if two variables refer to the same object in memory.



#### <a name="chapter4part6.4"></a>Chapter 4 - Part 6.4: String Methods: ```toUpperCase()```, ```toLowerCase()```, ```trim()```

The String class provides a variety of methods for manipulating strings. Here are three commonly used methods:

**```toUpperCase()```**

The toUpperCase() method converts all characters in a string to uppercase.

```java
String message = "Hello, world!";
String upperCaseMessage = message.toUpperCase();
System.out.println(upperCaseMessage); // Output: HELLO, WORLD!
```

**```toLowerCase()```**

The toLowerCase() method converts all characters in a string to lowercase.

```java
String message = "Hello, world!";
String lowerCaseMessage = message.toLowerCase();
System.out.println(lowerCaseMessage); // Output: hello, world!
```

**```trim()```**

The trim() method removes any leading and trailing whitespace from a string. Whitespace includes spaces, tabs, and newline characters.

```java
String message = "   Hello, world!   ";
String trimmedMessage = message.trim();
System.out.println(trimmedMessage); // Output: Hello, world!
```

**Example demonstrating all three methods**:

```java
String input = "  Java Programming  ";
String trimmedInput = input.trim(); // Remove leading/trailing spaces
String lowerCaseInput = trimmedInput.toLowerCase(); // Convert to lowercase
String upperCaseInput = trimmedInput.toUpperCase(); // Convert to uppercase

System.out.println("Original: " + input);
System.out.println("Trimmed: " + trimmedInput);
System.out.println("Lowercase: " + lowerCaseInput);
System.out.println("Uppercase: " + upperCaseInput);
```

#### <a name="chapter4part7"></a>Chapter 4 - Part 7: String Manipulation: Concatenation, Substrings, Length

Strings are fundamental to programming, representing and manipulating text. In Java, strings are objects, and the String class provides numerous methods for working with them. This lesson focuses on three essential string manipulation techniques: concatenation, extracting substrings, and determining string length. Mastering these techniques is crucial for tasks such as building dynamic messages, parsing data, and validating user input.

#### <a name="chapter4part7.1"></a>Chapter 4 - Part 7.1: String Concatenation

String concatenation is the process of combining two or more strings into a single, longer string. Java provides two primary ways to concatenate strings: the + operator and the concat() method.

**Using the + Operator**

The + operator is the most common and straightforward way to concatenate strings in Java. When used with strings, the + operator creates a new string that is the result of joining the operands.

```java
public class StringConcatenation {
    public static void main(String[] args) {
        String firstName = "John";
        String lastName = "Doe";
        String fullName = firstName + " " + lastName; // Concatenating with a space in between
        System.out.println(fullName); // Output: John Doe

        String greeting = "Hello, " + fullName + "!";
        System.out.println(greeting); // Output: Hello, John Doe!

        int age = 30;
        String ageMessage = "Age: " + age; // Concatenating a string with an integer
        System.out.println(ageMessage); // Output: Age: 30
    }
}
```

In the example above, the + operator is used to combine string literals, string variables, and even an integer with a string. Java automatically converts the integer to its string representation before concatenation.

**Important Note**: When using the + operator for concatenation within loops, especially with a large number of iterations, it can lead to performance issues because strings are immutable in Java. Each concatenation creates a new String object, which can be inefficient. In such cases, using StringBuilder or StringBuffer (discussed later in the course) is recommended.

**Using the concat() Method**

The String class provides a concat() method that performs string concatenation. This method takes a single string argument and returns a new string that is the result of appending the argument to the original string.

```java
public class StringConcatMethod {
    public static void main(String[] args) {
        String str1 = "Hello";
        String str2 = " World";
        String result = str1.concat(str2);
        System.out.println(result); // Output: Hello World

        String str3 = "Java";
        String str4 = str3.concat(" Programming");
        System.out.println(str4); // Output: Java Programming
    }
}
```

The concat() method is functionally equivalent to the + operator for simple string concatenation. However, the + operator is generally preferred for its readability and ease of use.

**Example**:

Let's say you're building a system that generates personalized email greetings. You can use string concatenation to combine a generic greeting with a user's name:

```java
public class EmailGreeting {
    public static void main(String[] args) {
        String baseGreeting = "Dear ";
        String userName = "Alice";
        String salutation = ",";
        String closing = "\nThank you,\nThe Team";

        String fullGreeting = baseGreeting + userName + salutation + closing;
        System.out.println(fullGreeting);
    }
}
```

This example demonstrates how concatenation can be used to dynamically create personalized messages.

#### <a name="chapter4part7.2"></a>Chapter 4 - Part 7.2: Extracting Substrings

A substring is a contiguous sequence of characters within a string. The String class provides methods to extract substrings based on starting and ending indices.

**The ```substring()``` Method**

The substring() method has two overloaded forms:

- ```substring(int beginIndex)```: Returns a substring starting from the specified beginIndex to the end of the string.
- ```substring(int beginIndex, int endIndex)```: Returns a substring starting from the specified beginIndex up to (but not including) the specified endIndex.

**Important Notes**:

- String indices are zero-based, meaning the first character is at index 0.
- The beginIndex is inclusive, while the endIndex is exclusive.
- If beginIndex is negative or greater than the string length, an IndexOutOfBoundsException is thrown.
- If endIndex is less than beginIndex or greater than the string length, an IndexOutOfBoundsException is thrown.

```java
public class SubstringExample {
    public static void main(String[] args) {
        String message = "Hello, World!";

        // Extracting a substring from index 7 to the end
        String sub1 = message.substring(7);
        System.out.println(sub1); // Output: World!

        // Extracting a substring from index 0 to index 5 (exclusive)
        String sub2 = message.substring(0, 5);
        System.out.println(sub2); // Output: Hello

        // Extracting "World" from the string
        String sub3 = message.substring(7, 12);
        System.out.println(sub3); // Output: World
    }
}
```

**Example**:

Suppose you have a string containing a file path, and you want to extract the file name. You can use the substring() method in conjunction with the lastIndexOf() method (which will be covered in a later lesson) to achieve this.

```java
public class FilePathExample {
    public static void main(String[] args) {
        String filePath = "/path/to/my/document.txt";
        int lastSlashIndex = filePath.lastIndexOf('/'); // Find the last occurrence of '/'
        String fileName = filePath.substring(lastSlashIndex + 1); // Extract the file name
        System.out.println(fileName); // Output: document.txt
    }
}
```

This example demonstrates how substrings can be used to parse and extract specific parts of a string.

#### <a name="chapter4part7.3"></a>Chapter 4 - Part 7.3: Determining String Length

The length of a string is the number of characters it contains. The String class provides the length() method to determine the length of a string.

**The ```length()``` Method**

The length() method returns the number of characters in the string.

```java
public class StringLengthExample {
    public static void main(String[] args) {
        String str1 = "Hello";
        int len1 = str1.length();
        System.out.println(len1); // Output: 5

        String str2 = "This is a sentence.";
        int len2 = str2.length();
        System.out.println(len2); // Output: 19

        String str3 = ""; // Empty string
        int len3 = str3.length();
        System.out.println(len3); // Output: 0
    }
}
```

Important Note: The length() method returns the number of characters, not the number of bytes. In Java, strings are represented using Unicode, where each character can be represented by one or more bytes.

**Example**:

You might want to validate user input to ensure it meets certain length requirements. For example, you might require a password to be at least 8 characters long.

```java
import java.util.Scanner;

public class PasswordValidation {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter your password: ");
        String password = scanner.nextLine();

        int minLength = 8;
        if (password.length() >= minLength) {
            System.out.println("Password is valid.");
        } else {
            System.out.println("Password must be at least " + minLength + " characters long.");
        }
        scanner.close();
    }
}
```

This example demonstrates how the length() method can be used for input validation.

#### <a name="chapter4part8"></a>Chapter 4 - Part 8: String Comparison: equals() vs. ==

String comparison is a fundamental operation in Java programming. It allows you to determine if two strings are the same or different, which is crucial for various tasks such as data validation, searching, and sorting. However, comparing strings in Java can be tricky because of the way strings are handled as objects. This lesson will delve into the nuances of string comparison in Java, focusing on the equals() method and the == operator, highlighting their differences and proper usage.

#### <a name="chapter4part8.1"></a>Chapter 4 - Part 8.1: Understanding String Immutability and the String Pool

Before diving into the comparison methods, it's essential to understand that strings in Java are immutable. This means that once a string object is created, its value cannot be changed. Any operation that appears to modify a string actually creates a new string object.

Java also uses a "string pool" (also known as the string intern pool) to optimize memory usage. When a string literal is created (e.g., "hello"), the JVM first checks if a string with the same value already exists in the string pool. If it does, the new string variable will point to the existing string object in the pool. If not, a new string object is created in the pool.

#### <a name="chapter4part8.2"></a>Chapter 4 - Part 8.2: The equals() Method: Comparing String Content

The equals() method is the correct way to compare the content of two strings in Java. It checks if the two strings have the exact same sequence of characters, regardless of whether they are stored in the same memory location.

**Syntax and Usage**

The equals() method is called on a string object and takes another string object as an argument:

```java
String str1 = "hello";
String str2 = "hello";

boolean isEqual = str1.equals(str2); // Returns true
```

**Case Sensitivity**

The equals() method is case-sensitive. This means that "Hello" and "hello" are considered different strings.

```java
String str1 = "Hello";
String str2 = "hello";

boolean isEqual = str1.equals(str2); // Returns false
```

**The equalsIgnoreCase() Method**

If you need to compare strings without regard to case, you can use the equalsIgnoreCase() method.

```java
String str1 = "Hello";
String str2 = "hello";

boolean isEqual = str1.equalsIgnoreCase(str2); // Returns true
```

**Comparing with Null**

It's important to be careful when using equals() with potentially null strings. Calling equals() on a null reference will result in a NullPointerException. To avoid this, you can either check for null explicitly or use the Objects.equals() method (introduced in Java 7), which handles null checks for you.

```java
String str1 = null;
String str2 = "hello";

// Avoid NullPointerException
boolean isEqual1 = (str1 != null) && str1.equals(str2); // Returns false

// Using Objects.equals()
boolean isEqual2 = java.util.Objects.equals(str1, str2); // Returns false
```

**Examples**

```java
public class StringEqualsExample {
    public static void main(String[] args) {
        String str1 = "Java";
        String str2 = "Java";
        String str3 = new String("Java");
        String str4 = "Python";

        System.out.println("str1 equals str2: " + str1.equals(str2)); // true
        System.out.println("str1 equals str3: " + str1.equals(str3)); // true
        System.out.println("str1 equals str4: " + str1.equals(str4)); // false

        String nullStr = null;
        String str5 = "test";

        //System.out.println("nullStr equals str5: " + nullStr.equals(str5)); // NullPointerException
        System.out.println("Objects.equals(nullStr, str5): " + java.util.Objects.equals(nullStr, str5)); // false
    }
}
```

#### <a name="chapter4part8.3"></a>Chapter 4 - Part 8.3: The == Operator: Comparing Object References

The == operator compares the references of two objects. In the context of strings, it checks if two string variables point to the same memory location (i.e., the same object). It does not compare the content of the strings.

**Behavior with String Literals**

When you create string literals, Java often uses the string pool. If two string literals have the same value, they will usually point to the same object in the string pool, and == will return true.

```java
String str1 = "hello";
String str2 = "hello";

boolean areSame = (str1 == str2); // Returns true because both point to the same object in the string pool
```

**Behavior with ```new String()```**

However, when you create a string object using the new String() constructor, a new string object is created in memory, even if a string with the same value already exists in the string pool. In this case, == will return false because the two variables point to different objects.

```java
String str1 = "hello";
String str2 = new String("hello");

boolean areSame = (str1 == str2); // Returns false because str2 is a new object
```

**Examples**

```java
public class StringEqualsOperatorExample {
    public static void main(String[] args) {
        String str1 = "Java";
        String str2 = "Java";
        String str3 = new String("Java");

        System.out.println("str1 == str2: " + (str1 == str2)); // true (both point to the same string in the pool)
        System.out.println("str1 == str3: " + (str1 == str3)); // false (str3 is a new object)
    }
}
```

#### <a name="chapter4part8.4"></a>Chapter 4 - Part 8.4: When to Use ```equals()``` vs. ```==```

- **```Use equals() (or equalsIgnoreCase())``` to compare the content of strings**. This is almost always what you want to do.

- **Avoid using == to compare strings unless you specifically need to check if two variables point to the exact same object in memory**. This is rarely the case in typical string manipulation scenarios.

#### <a name="chapter4part9"></a>Chapter 4 - Part 9: String Methods: toUpperCase(), toLowerCase(), trim()

Strings in Java are immutable sequences of characters, and the String class provides a rich set of methods for manipulating them. This lesson focuses on three fundamental string methods: toUpperCase(), toLowerCase(), and trim(). These methods are essential for standardizing and cleaning string data, which is a common task in many applications. Understanding how to use these methods effectively will enable you to write more robust and maintainable code.

#### <a name="chapter4part9.1"></a>Chapter 4 - Part 9.1: Understanding toUpperCase() and toLowerCase()

**Understanding toUpperCase() and toLowerCase()**

The toUpperCase() and toLowerCase() methods are used to convert a string to uppercase and lowercase, respectively. These methods are particularly useful when you need to perform case-insensitive comparisons or when you need to format strings for display purposes.

**```toUpperCase()```**

The toUpperCase() method converts all characters in a string to uppercase. It returns a new string with all characters converted to their uppercase equivalents. If a character does not have an uppercase equivalent, it remains unchanged.

```java
public class ToUpperCaseExample {
    public static void main(String[] args) {
        String str = "Hello World";
        String upperCaseStr = str.toUpperCase();
        System.out.println("Original String: " + str);
        System.out.println("Uppercase String: " + upperCaseStr);
    }
}
```

In this example, the toUpperCase() method converts the string "Hello World" to "HELLO WORLD".

**```toLowerCase()```**

The toLowerCase() method converts all characters in a string to lowercase. It returns a new string with all characters converted to their lowercase equivalents. If a character does not have a lowercase equivalent, it remains unchanged.

```java
public class ToLowerCaseExample {
    public static void main(String[] args) {
        String str = "Hello World";
        String lowerCaseStr = str.toLowerCase();
        System.out.println("Original String: " + str);
        System.out.println("Lowercase String: " + lowerCaseStr);
    }
}
```

In this example, the toLowerCase() method converts the string "Hello World" to "hello world".

**Locale-Specific Case Conversion**

Both toUpperCase() and toLowerCase() have overloaded versions that accept a Locale object as an argument. The Locale object specifies the cultural context for the conversion. This is important because the rules for case conversion can vary depending on the language and region.

```java
import java.util.Locale;

public class LocaleCaseConversionExample {
    public static void main(String[] args) {
        String str = "turkey";
        String upperCaseStrDefault = str.toUpperCase();
        String upperCaseStrTurkish = str.toUpperCase(new Locale("tr", "TR"));

        System.out.println("Original String: " + str);
        System.out.println("Uppercase String (Default Locale): " + upperCaseStrDefault);
        System.out.println("Uppercase String (Turkish Locale): " + upperCaseStrTurkish);
    }
}
```

In this example, the toUpperCase() method is called with and without a Locale object. The default locale conversion might not correctly handle characters specific to the Turkish language. Using the Turkish locale ensures that the conversion is performed according to Turkish language rules. The output of this code demonstrates the difference: the default locale might not convert the "i" correctly, while the Turkish locale will.

**Practical Examples**

- **User Input Normalization**: When accepting user input, you might want to convert the input to a consistent case before processing it. For example, if you are checking if a user has entered "yes" to confirm an action, you can convert the input to lowercase before comparing it to "yes".

```java
import java.util.Scanner;

public class UserInputNormalization {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Do you want to continue? (yes/no)");
        String answer = scanner.nextLine();
        String normalizedAnswer = answer.toLowerCase();

        if (normalizedAnswer.equals("yes")) {
            System.out.println("Continuing...");
        } else {
            System.out.println("Stopping...");
        }
        scanner.close();
    }
}
```

- **Data Standardization**: When processing data from different sources, you might encounter inconsistencies in the case of strings. Converting all strings to a consistent case can help to standardize the data and make it easier to process.

```java
public class DataStandardization {
    public static void main(String[] args) {
        String[] data = {"Apple", "banana", "ORANGE"};
        for (int i = 0; i < data.length; i++) {
            data[i] = data[i].toLowerCase();
        }

        for (String item : data) {
            System.out.println(item);
        }
    }
}
```

#### <a name="chapter4part9.2"></a>Chapter 4 - Part 9.2: Understanding trim()

The trim() method removes leading and trailing whitespace from a string. Whitespace includes spaces, tabs, and newline characters. This method is useful for cleaning up strings that may have unwanted whitespace, such as user input or data read from a file.

**Basic Usage**

The trim() method returns a new string with all leading and trailing whitespace removed. If the string has no leading or trailing whitespace, it returns the original string.

```java
public class TrimExample {
    public static void main(String[] args) {
        String str = "   Hello World   ";
        String trimmedStr = str.trim();
        System.out.println("Original String: \"" + str + "\"");
        System.out.println("Trimmed String: \"" + trimmedStr + "\"");
    }
}
```

In this example, the trim() method removes the leading and trailing spaces from the string " Hello World ".

**Practical Examples**

- **User Input Validation**: When accepting user input, you might want to trim the input to remove any leading or trailing whitespace that the user may have accidentally entered.

```java
import java.util.Scanner;

public class UserInputValidation {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter your username:");
        String username = scanner.nextLine();
        String trimmedUsername = username.trim();

        if (trimmedUsername.isEmpty()) {
            System.out.println("Username cannot be empty.");
        } else {
            System.out.println("Username: " + trimmedUsername);
        }
        scanner.close();
    }
}
```

- **Data Cleaning**: When processing data from different sources, you might encounter strings with leading or trailing whitespace. Trimming these strings can help to ensure that the data is consistent and accurate.

```java
public class DataCleaning {
    public static void main(String[] args) {
        String[] data = {"  Apple", "banana  ", "  Orange  "};
        for (int i = 0; i < data.length; i++) {
            data[i] = data[i].trim();
        }

        for (String item : data) {
            System.out.println("\"" + item + "\"");
        }
    }
}
```

#### <a name="chapter4part9.3"></a>Chapter 4 - Part 9.3: Combining String Methods

You can combine these string methods to perform more complex string manipulations. For example, you can convert a string to lowercase and then trim it to remove any leading or trailing whitespace.

```java
public class CombinedStringMethods {
    public static void main(String[] args) {
        String str = "   Hello World   ";
        String processedStr = str.toLowerCase().trim();
        System.out.println("Original String: \"" + str + "\"");
        System.out.println("Processed String: \"" + processedStr + "\"");
    }
}
```

In this example, the toLowerCase() method is called first to convert the string to lowercase, and then the trim() method is called to remove any leading or trailing whitespace.

## <a name="chapter5"></a>Chapter 5: Object-Oriented Programming (OOP) Fundamentals

#### <a name="chapter5part1"></a>Chapter 5 - Part 1: Introduction to Object-Oriented Programming (OOP)

Object-oriented programming (OOP) is a programming paradigm centered around "objects" that contain both data (attributes) and code (methods) to manipulate that data. It's a fundamental concept in modern software development, enabling developers to create modular, reusable, and maintainable code. Understanding OOP principles is crucial for building complex applications and working effectively in team environments. This lesson introduces the core concepts of OOP, laying the groundwork for more advanced topics in subsequent lessons.

#### <a name="chapter5part1.1"></a>Chapter 5 - Part 1.1: Understanding Classes and Objects

Look at the following illustration to see the difference between class and objects:

<br>

<div align="center"><img src="img/classandobjects1-w1291-h563.png" width=1291 height=563><br><sub>Fig 28 - Class and objects - (<a href='https://www.w3schools.com/java/java_oop.asp'>Work by  w3schools</a>) </sub></div>

<br>

So, a class is a template for objects, and an object is an instance of a class.

When the individual objects are created, they inherit all the variables and methods from the class.

At the heart of OOP are classes and objects. A class is a blueprint or a template that defines the characteristics and behaviors of a particular type of object. Think of it as a cookie cutter. An object is an instance of a class. It's a concrete realization of the blueprint. Think of it as the cookie created using the cookie cutter.

**Classes: Blueprints for Objects**

A class defines the attributes (data) and methods (behavior) that its objects will possess.

- **Attributes (Fields)**: These are variables that hold data about the object. They represent the object's state.
- **Methods**: These are functions that define the actions an object can perform. They represent the object's behavior.

Let's consider a simple example: a Dog class.

```java
class Dog {
    // Attributes (Fields)
    String breed;
    String name;
    int age;

    // Methods (Behaviors)
    void bark() {
        System.out.println("Woof!");
    }

    void displayInfo() {
        System.out.println("Name: " + name + ", Breed: " + breed + ", Age: " + age);
    }
}
```

In this example:

- breed, name, and age are attributes (fields) that describe a dog.

- bark() and displayInfo() are methods that define what a dog can do.

**Objects: Instances of Classes**

An object is a specific instance of a class. You create objects from classes using the new keyword.

```java
public class Main {
    public static void main(String[] args) {
        // Creating objects of the Dog class
        Dog dog1 = new Dog();
        dog1.breed = "Golden Retriever";
        dog1.name = "Buddy";
        dog1.age = 3;

        Dog dog2 = new Dog();
        dog2.breed = "Poodle";
        dog2.name = "Coco";
        dog2.age = 5;

        // Calling methods on the objects
        dog1.bark(); // Output: Woof!
        dog1.displayInfo(); // Output: Name: Buddy, Breed: Golden Retriever, Age: 3
        dog2.displayInfo(); // Output: Name: Coco, Breed: Poodle, Age: 5
    }
}
```

In this example:

- dog1 and dog2 are objects of the Dog class.
- We assign values to the attributes of each object.
- We call the bark() and displayInfo() methods on each object.

Each object has its own unique set of attribute values. dog1 has a different name, breed, and age than dog2.

#### <a name="chapter5part1.2"></a>Chapter 5 - Part 1.2: Defining Classes: Attributes (Fields) and Behaviors (Methods)

Let's delve deeper into defining classes, focusing on attributes (fields) and behaviors (methods).

**Attributes (Fields)**

Attributes represent the data associated with an object. They are declared as variables within the class. Each object has its own copy of these variables.

- **Data Types**: Attributes can be of any valid Java data type (e.g., int, double, String, boolean, or even other classes).
- **Naming Conventions**: Attribute names typically follow the camelCase convention (e.g., firstName, accountBalance).

Consider a Car class:

```java
class Car {
    String make;
    String model;
    int year;
    String color;
    double currentSpeed;
}
```

Here, make, model, year, color, and currentSpeed are attributes that describe a car.

**Methods (Behaviors)**

Methods define the actions an object can perform. They are declared as functions within the class.

- **Method Signature**: A method signature consists of the method name, parameters (if any), and return type.
- **Return Type**: A method can return a value (e.g., int, String, void if it doesn't return anything).
- **Parameters**: Methods can accept input values through parameters.

Extending the Car class:

```java
class Car {
    String make;
    String model;
    int year;
    String color;
    double currentSpeed;

    void accelerate(double increment) {
        currentSpeed += increment;
        System.out.println("Accelerating. Current speed: " + currentSpeed);
    }

    void brake(double decrement) {
        currentSpeed -= decrement;
        if (currentSpeed < 0) {
            currentSpeed = 0;
        }
        System.out.println("Braking. Current speed: " + currentSpeed);
    }

    void displayCarInfo() {
        System.out.println("Make: " + make + ", Model: " + model + ", Year: " + year + ", Color: " + color);
    }
}
```

In this example:

- accelerate() and brake() are methods that modify the currentSpeed attribute.
- displayCarInfo() is a method that displays the car's information.

#### <a name="chapter5part1.3"></a>Chapter 5 - Part 1.3: Creating Objects: Instantiating Classes

Creating an object from a class is called instantiation. You use the new keyword followed by the class name and parentheses () to create an object.

```java
Car myCar = new Car(); // Creates a new Car object
```

This line of code does the following:

- Declares a variable named myCar of type Car.
- Uses the new keyword to allocate memory for a new Car object.
- Calls the class's constructor (we'll discuss constructors shortly) to initialize the object.
- Assigns the reference to the newly created object to the myCar variable.

You can then access the object's attributes and methods using the dot operator (.).

```java
myCar.make = "Toyota";
myCar.model = "Camry";
myCar.year = 2023;
myCar.color = "Silver";
myCar.currentSpeed = 0;

myCar.displayCarInfo(); // Output: Make: Toyota, Model: Camry, Year: 2023, Color: Silver
myCar.accelerate(30); // Output: Accelerating. Current speed: 30.0
```

#### <a name="chapter5part1.4"></a>Chapter 5 - Part 1.4: Accessing Object Attributes and Calling Methods

As shown in the previous section, you use the dot operator (.) to access an object's attributes and call its methods.

- Accessing Attributes: objectName.attributeName
- Calling Methods: objectName.methodName(arguments)

Let's illustrate this with a Rectangle class:

```java
class Rectangle {
    double length;
    double width;

    double calculateArea() {
        return length * width;
    }

    double calculatePerimeter() {
        return 2 * (length + width);
    }
}

public class Main {
    public static void main(String[] args) {
        Rectangle myRectangle = new Rectangle();
        myRectangle.length = 10;
        myRectangle.width = 5;

        double area = myRectangle.calculateArea();
        double perimeter = myRectangle.calculatePerimeter();

        System.out.println("Area: " + area); // Output: Area: 50.0
        System.out.println("Perimeter: " + perimeter); // Output: Perimeter: 30.0
    }
}
```

In this example:

- We access the length and width attributes of the myRectangle object.
- We call the calculateArea() and calculatePerimeter() methods on the myRectangle object.

#### <a name="chapter5part1.5"></a>Chapter 5 - Part 1.5: Constructors: Initializing Objects

A constructor is a special method that is automatically called when an object is created. Its primary purpose is to initialize the object's attributes.

- **Name**: A constructor has the same name as the class.
- **No Return Type**: A constructor does not have a return type (not even void).
- **Default Constructor**: If you don't define a constructor in your class, Java provides a default constructor (with no parameters).
- **Parameterized Constructors**: You can define constructors with parameters to initialize the object with specific values.

Let's add a constructor to the Car class:

```java
class Car {
    String make;
    String model;
    int year;
    String color;
    double currentSpeed;

    // Constructor
    Car(String make, String model, int year, String color) {
        this.make = make;
        this.model = model;
        this.year = year;
        this.color = color;
        this.currentSpeed = 0; // Initialize currentSpeed to 0
    }

    void accelerate(double increment) {
        currentSpeed += increment;
        System.out.println("Accelerating. Current speed: " + currentSpeed);
    }

    void brake(double decrement) {
        currentSpeed -= decrement;
        if (currentSpeed < 0) {
            currentSpeed = 0;
        }
        System.out.println("Braking. Current speed: " + currentSpeed);
    }

    void displayCarInfo() {
        System.out.println("Make: " + make + ", Model: " + model + ", Year: " + year + ", Color: " + color);
    }
}

public class Main {
    public static void main(String[] args) {
        // Creating a Car object using the constructor
        Car myCar = new Car("Toyota", "Camry", 2023, "Silver");

        myCar.displayCarInfo(); // Output: Make: Toyota, Model: Camry, Year: 2023, Color: Silver
        myCar.accelerate(50); // Output: Accelerating. Current speed: 50.0
    }
}
```

In this example:

- We define a constructor that takes make, model, year, and color as parameters.
- Inside the constructor, we initialize the object's attributes with the provided values.
- When creating the myCar object, we pass the initial values to the constructor.

#### <a name="chapter5part1.6"></a>Chapter 5 - Part 1.6: The this Keyword: Referring to the Current Object

The this keyword is a reference to the current object. It's used to:

- **Differentiate between instance variables and local variables**: When a method parameter has the same name as an instance variable, you can use this to refer to the instance variable.
- **Call one constructor from another**: Within a constructor, you can use this() to call another constructor of the same class.
- **Return the current object**: A method can return this to allow for method chaining.

Let's illustrate the first use case (differentiating between instance variables and local variables) with the Car class constructor:

```java
class Car {
    String make;
    String model;
    int year;
    String color;
    double currentSpeed;

    // Constructor
    Car(String make, String model, int year, String color) {
        // Using 'this' to differentiate between instance variables and parameters
        this.make = make;
        this.model = model;
        this.year = year;
        this.color = color;
        this.currentSpeed = 0; // Initialize currentSpeed to 0
    }

    // ... (other methods)
}
```

In this example, this.make refers to the instance variable make, while make refers to the parameter make passed to the constructor. Without this, the assignment make = make; would have no effect, as it would simply be assigning the parameter to itself.

#### <a name="chapter5part1.7"></a>Chapter 5 - Part 1.7: Introduction to Encapsulation: Hiding Data

Encapsulation is one of the four fundamental principles of OOP (along with abstraction, inheritance, and polymorphism). It refers to the bundling of data (attributes) and methods that operate on that data into a single unit (a class), and restricting direct access to some of the object's components. This is often achieved through access modifiers.

The main benefits of encapsulation are:

- **Data Hiding**: Prevents direct access to the internal state of an object, protecting it from accidental or malicious modification.
- **Code Maintainability**: Makes it easier to modify the internal implementation of a class without affecting other parts of the code that use it.
- **Code Reusability**: Encapsulated classes can be easily reused in different parts of the application or in other applications.
- **Increased Flexibility**: Allows you to change the internal representation of an object without affecting the external code that uses it.

We will explore encapsulation in more detail in the next lesson, including access modifiers (public, private, protected, and default).

#### <a name="chapter5part2"></a>Chapter 5 - Part 2: Understanding Classes and Objects

Object-oriented programming (OOP) is a programming paradigm centered around "objects" that contain both data (attributes) and code (methods) to manipulate that data. Understanding classes and objects is fundamental to grasping OOP principles in Java. This lesson will provide a comprehensive introduction to these concepts, laying the groundwork for more advanced OOP topics.

#### <a name="chapter5part2.1"></a>Chapter 5 - Part 2.1: Understanding Classes

A class is a blueprint or a template for creating objects. It defines the attributes (data) and behaviors (methods) that objects of that class will possess. Think of a class as a cookie cutter and the objects as the cookies. The cookie cutter defines the shape, and each cookie is an instance of that shape.

**Defining Classes: Attributes (Fields) and Behaviors (Methods)**

A class definition consists of two main parts:

- **Attributes (Fields)**: These are variables that hold the data associated with an object. They represent the state of an object.
- **Behaviors (Methods)**: These are functions that define what an object can do. They represent the behavior of an object.

Let's consider a simple example of a Dog class:

```java
public class Dog {
    // Attributes (Fields)
    String breed;
    String name;
    int age;

    // Behaviors (Methods)
    public void bark() {
        System.out.println("Woof!");
    }

    public void displayInfo() {
        System.out.println("Name: " + name + ", Breed: " + breed + ", Age: " + age);
    }
}
```

In this example:

- breed, name, and age are attributes (fields) that describe a Dog object.
- bark() and displayInfo() are behaviors (methods) that define what a Dog object can do.

**Class Naming Conventions**

Class names in Java should follow these conventions:

- Start with an uppercase letter.
- Use camel case for multi-word names (e.g., ShoppingCart, EmployeeRecord).
- Choose descriptive and meaningful names.

**Declaring Attributes**

Attributes are declared within the class using the following syntax:

```java
accessModifier dataType attributeName;
```

- **```accessModifier```**: Controls the visibility of the attribute (e.g., public, private). We'll cover access modifiers in detail in a later lesson. For now, we'll use public for simplicity.
- **```dataType```**: Specifies the type of data the attribute will hold (e.g., String, int, boolean).
- **```attributeName```**: The name of the attribute.

**Defining Methods**

Methods are declared within the class using the following syntax:

```java
accessModifier returnType methodName(parameterList) {
    // Method body
}
```

- **```accessModifier```**: Controls the visibility of the method (e.g., public, private).
- **```returnType```**: Specifies the type of data the method will return (e.g., void, String, int). If the method doesn't return any value, use void.
- **```methodName```**: The name of the method.
- **```parameterList```**: A comma-separated list of parameters that the method accepts (e.g., int age, String name).
- **```method body```**: The code that the method executes.

#### <a name="chapter5part2.2"></a>Chapter 5 - Part 2.2: Creating Objects: Instantiating Classes

An object is an instance of a class. Creating an object is also known as instantiation. You create an object using the new keyword.

**The new Keyword**

The new keyword is used to create a new instance of a class. The syntax is as follows:

```java
ClassName objectName = new ClassName();
```

- **```ClassName```**: The name of the class you want to create an object of.
- **```objectName```**: The name of the object.
- **```new ClassName()```**: This creates a new object of the specified class.

Let's create a Dog object:

```java
Dog myDog = new Dog();
```

Now, myDog is an object of the Dog class. It has its own set of attributes and can perform the actions defined by the methods in the Dog class.

**Multiple Objects from the Same Class**

You can create multiple objects from the same class. Each object will have its own unique set of attribute values.

```java
Dog myDog = new Dog();
Dog yourDog = new Dog();
Dog anotherDog = new Dog();
```

myDog, yourDog, and anotherDog are all separate Dog objects. Changes to one object will not affect the others.

#### <a name="chapter5part2.3"></a>Chapter 5 - Part 2.3: Accessing Object Attributes and Calling Methods

Once you have created an object, you can access its attributes and call its methods using the dot operator (.).

**Accessing Attributes**

To access an attribute of an object, use the following syntax:

```java
objectName.attributeName
```

For example, to set the name attribute of myDog:

```java
myDog.name = "Buddy";
```

And to access the name attribute:

```java
System.out.println(myDog.name); // Output: Buddy
```

**Calling Methods**

To call a method of an object, use the following syntax:

```java
objectName.methodName(arguments);
```

For example, to call the bark() method of myDog:

```java
myDog.bark(); // Output: Woof!
```

And to call the displayInfo() method after setting the attributes:

```java
myDog.name = "Buddy";
myDog.breed = "Golden Retriever";
myDog.age = 3;
myDog.displayInfo(); // Output: Name: Buddy, Breed: Golden Retriever, Age: 3
```

#### <a name="chapter5part2.4"></a>Chapter 5 - Part 2.4: Constructors: Initializing Objects

A constructor is a special method that is called when an object is created. It is used to initialize the object's attributes.

**Defining Constructors**

A constructor has the same name as the class and does not have a return type (not even void).

```java
public class Dog {
    String breed;
    String name;
    int age;

    // Constructor
    public Dog(String breed, String name, int age) {
        this.breed = breed;
        this.name = name;
        this.age = age;
    }

    public void bark() {
        System.out.println("Woof!");
    }

    public void displayInfo() {
        System.out.println("Name: " + name + ", Breed: " + breed + ", Age: " + age);
    }
}
```

In this example, the Dog class has a constructor that takes three parameters: breed, name, and age. These parameters are used to initialize the corresponding attributes of the Dog object.

**Using Constructors**

When you create an object using the new keyword, you can pass arguments to the constructor to initialize the object's attributes.

```java
Dog myDog = new Dog("Golden Retriever", "Buddy", 3);
myDog.displayInfo(); // Output: Name: Buddy, Breed: Golden Retriever, Age: 3
```

**Default Constructor**

If you don't define a constructor in your class, Java provides a default constructor. The default constructor takes no arguments and initializes all attributes to their default values (e.g., 0 for int, null for String).

However, if you define any constructor, Java will not provide the default constructor. If you need a no-argument constructor in addition to other constructors, you must define it explicitly:

```java
public class Dog {
    String breed;
    String name;
    int age;

    // No-argument constructor
    public Dog() {
        this.breed = "Unknown";
        this.name = "Unknown";
        this.age = 0;
    }

    // Constructor with arguments
    public Dog(String breed, String name, int age) {
        this.breed = breed;
        this.name = name;
        this.age = age;
    }

    public void bark() {
        System.out.println("Woof!");
    }

    public void displayInfo() {
        System.out.println("Name: " + name + ", Breed: " + breed + ", Age: " + age);
    }
}

Dog myDog = new Dog(); // Uses the no-argument constructor
myDog.displayInfo(); // Output: Name: Unknown, Breed: Unknown, Age: 0

Dog yourDog = new Dog("Labrador", "Lucy", 5); // Uses the constructor with arguments
yourDog.displayInfo(); // Output: Name: Lucy, Breed: Labrador, Age: 5
```

#### <a name="chapter5part2.5"></a>Chapter 5 - Part 2.5: The this Keyword: Referring to the Current Object

The this keyword is a reference to the current object. It is used to access the object's attributes and methods from within the object itself.

**Using this to Differentiate Attributes from Parameters**

The most common use of this is to differentiate between an object's attributes and method parameters that have the same name.

```java
public class Dog {
    String breed;
    String name;
    int age;

    public Dog(String breed, String name, int age) {
        this.breed = breed; // this.breed refers to the attribute, breed refers to the parameter
        this.name = name;   // this.name refers to the attribute, name refers to the parameter
        this.age = age;     // this.age refers to the attribute, age refers to the parameter
    }

    public void displayInfo() {
        System.out.println("Name: " + name + ", Breed: " + breed + ", Age: " + age);
    }
}
```

Without this, the compiler would not know which breed, name, and age you are referring to within the constructor.

**Using this to Call Other Methods**

You can also use this to call other methods of the same object.

```java
public class Dog {
    String breed;
    String name;
    int age;

    public Dog(String breed, String name, int age) {
        this.breed = breed;
        this.name = name;
        this.age = age;
    }

    public void bark() {
        System.out.println("Woof!");
    }

    public void displayInfo() {
        System.out.println("Name: " + name + ", Breed: " + breed + ", Age: " + age);
        this.bark(); // Calling the bark() method of the current object
    }
}

Dog myDog = new Dog("Poodle", "Max", 2);
myDog.displayInfo();
// Output:
// Name: Max, Breed: Poodle, Age: 2
// Woof!
```

#### <a name="chapter5part2.6"></a>Chapter 5 - Part 2.6: Introduction to Encapsulation: Hiding Data

Encapsulation is one of the four fundamental principles of OOP (the others being inheritance, polymorphism, and abstraction). It refers to the bundling of data (attributes) and methods that operate on that data into a single unit (a class), and restricting direct access to some of the object's components. This is often achieved by declaring attributes as private.

**Why Encapsulation?**

- **Data Hiding**: Prevents direct access to the internal state of an object, protecting it from accidental or malicious modification.
- **Code Maintainability**: Makes it easier to modify the internal implementation of a class without affecting other parts of the code.
- **Code Reusability**: Promotes code reusability by creating self-contained units that can be easily used in other programs.

**Example of Encapsulation**

```java
public class Dog {
    private String breed; // Private attribute
    private String name;  // Private attribute
    private int age;      // Private attribute

    public Dog(String breed, String name, int age) {
        this.breed = breed;
        this.name = name;
        this.age = age;
    }

    // Getter methods (accessors)
    public String getBreed() {
        return breed;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    // Setter methods (mutators)
    public void setBreed(String breed) {
        this.breed = breed;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        if (age >= 0) { // Add validation
            this.age = age;
        } else {
            System.out.println("Age cannot be negative.");
        }
    }

    public void bark() {
        System.out.println("Woof!");
    }

    public void displayInfo() {
        System.out.println("Name: " + name + ", Breed: " + breed + ", Age: " + age);
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog("German Shepherd", "Rocky", 4);

        // Cannot access attributes directly because they are private
        // System.out.println(myDog.name); // This will cause an error

        // Access attributes using getter methods
        System.out.println("Name: " + myDog.getName()); // Output: Name: Rocky

        // Modify attributes using setter methods
        myDog.setAge(5);
        System.out.println("Age: " + myDog.getAge()); // Output: Age: 5

        myDog.setAge(-2); // Output: Age cannot be negative.
        System.out.println("Age: " + myDog.getAge()); // Output: Age: 5 (value remains unchanged)
    }
}
```

In this example:

- The breed, name, and age attributes are declared as private. This means they can only be accessed from within the Dog class.
- Getter methods (getBreed(), getName(), getAge()) are provided to allow access to the attributes from outside the class.
- Setter methods (setBreed(), setName(), setAge()) are provided to allow modification of the attributes from outside the class. The setAge() method includes validation to ensure that the age is not negative.

By using encapsulation, you can control how the attributes of an object are accessed and modified, which helps to protect the integrity of the object's data. We will delve deeper into access modifiers in a later lesson.

#### <a name="chapter5part3"></a>Chapter 5 - Part 3: Defining Classes: Attributes (Fields) and Behaviors (Methods)

Object-oriented programming (OOP) revolves around the concept of "objects," which are self-contained entities that combine data and behavior. Understanding how to define these objects through classes is fundamental to mastering OOP. This lesson delves into the core components of a class: attributes (fields) that represent the object's data and behaviors (methods) that define what the object can do. By learning how to define classes effectively, you'll be able to create modular, reusable, and maintainable code.

#### <a name="chapter5part3.1"></a>Chapter 5 - Part 3.1: Understanding Classes and Objects

A class serves as a blueprint or template for creating objects. It defines the type of object, specifying what attributes it will have and what actions it can perform. An object, on the other hand, is a specific instance of a class. Think of a class as a cookie cutter and an object as the cookie itself. You can create many cookies (objects) from the same cutter (class).

For example, consider a Car class. The class defines the general characteristics of a car, such as its color, model, and number of doors. An object of the Car class would be a specific car, like a red Toyota Corolla with four doors.

#### <a name="chapter5part3.2"></a>Chapter 5 - Part 3.2: Defining Classes: Attributes (Fields)

Attributes, also known as fields or instance variables, are the data that an object holds. They represent the state of the object. Each object of a class has its own set of values for its attributes.

**Declaring Attributes**

In Java, you declare attributes within a class using the following syntax:

```java
class ClassName {
    dataType attributeName;
}
```

- **```dataType```**: Specifies the type of data the attribute will hold (e.g., int, String, boolean).
- **```attributeName```**: The name you give to the attribute. Choose descriptive names that clearly indicate the attribute's purpose.

**Example: Dog Class with Attributes**

Let's create a Dog class with some attributes:

```java
class Dog {
    String breed;
    String name;
    int age;
    double weight;
}
```

In this example, the Dog class has four attributes:

- **```breed```**: Stores the breed of the dog (e.g., "Golden Retriever").
- **```name```**: Stores the name of the dog (e.g., "Buddy").
- **```age```**: Stores the age of the dog in years.
- **```weight```**: Stores the weight of the dog in kilograms.

**Accessing Attributes**

To access an object's attributes, you first need to create an instance of the class (an object). Then, you can use the dot operator (.) to access the attribute:

```java
Dog myDog = new Dog(); // Creating an object of the Dog class
myDog.breed = "Labrador";
myDog.name = "Max";
myDog.age = 3;
myDog.weight = 25.5;

System.out.println("My dog's name is " + myDog.name); // Output: My dog's name is Max
```

**Data Encapsulation and Access Modifiers (Brief Introduction)**

While we're directly accessing attributes here, it's important to note that in good OOP practice, you'll often use access modifiers (like private, public, and protected) to control how attributes are accessed and modified. This is related to the concept of encapsulation, which we'll explore in more detail in a later lesson. For now, just be aware that directly accessing attributes like this is often discouraged in favor of using methods (getters and setters) to interact with the object's data.

#### <a name="chapter5part3.3"></a>Chapter 5 - Part 3.3: Defining Classes: Behaviors (Methods)

Behaviors, also known as methods, define what an object can do. They are functions that operate on the object's data (attributes) or perform other actions.

**Declaring Methods**

In Java, you declare methods within a class using the following syntax:

```java
class ClassName {
    returnType methodName(parameterList) {
        // Method body (code to be executed)
    }
}
```

- **```returnType```**: Specifies the type of data the method will return (e.g., int, String, void if the method doesn't return anything).
- **```methodName```**: The name you give to the method. Choose descriptive names that indicate what the method does.
- **```parameterList```**: A list of parameters (input values) the method accepts. Each parameter consists of a data type and a parameter name (e.g., int age, String name).
- **```method body```**: The code that will be executed when the method is called.

**Example: Dog Class with Methods**

Let's add some methods to our Dog class:

```java
class Dog {
    String breed;
    String name;
    int age;
    double weight;

    void bark() {
        System.out.println("Woof!");
    }

    void eat(double amountOfFood) {
        weight += amountOfFood;
        System.out.println(name + " ate " + amountOfFood + " kg of food. New weight: " + weight + " kg");
    }

    int getAgeInHumanYears() {
        return age * 7;
    }
}
```

In this example, the Dog class has three methods:

- **```bark()```**: Makes the dog bark. It doesn't take any parameters and doesn't return any value (void).
- **```eat(double amountOfFood)```**: Simulates the dog eating food. It takes the amount of food as a parameter (a double) and increases the dog's weight accordingly. It also prints a message to the console.
- **```getAgeInHumanYears()```**: Calculates the dog's age in human years (assuming 1 dog year = 7 human years). It doesn't take any parameters and returns the age in human years as an int.

**Calling Methods**

To call a method on an object, you use the dot operator (.):

```java
Dog myDog = new Dog();
myDog.breed = "Labrador";
myDog.name = "Max";
myDog.age = 3;
myDog.weight = 25.5;

myDog.bark(); // Output: Woof!
myDog.eat(0.5); // Output: Max ate 0.5 kg of food. New weight: 26.0 kg
int humanAge = myDog.getAgeInHumanYears();
System.out.println(myDog.name + " is " + humanAge + " years old in human years."); // Output: Max is 21 years old in human years.
```

#### <a name="chapter5part3.4"></a>Chapter 5 - Part 3.4: Practical Examples and Demonstrations

Let's consider another example: a Rectangle class.

```java
class Rectangle {
    double length;
    double width;

    // Constructor (explained in the next lesson)
    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    double calculateArea() {
        return length * width;
    }

    double calculatePerimeter() {
        return 2 * (length + width);
    }

    void resize(double newLength, double newWidth) {
        length = newLength;
        width = newWidth;
        System.out.println("Rectangle resized to length: " + length + ", width: " + width);
    }
}

public class Main {
    public static void main(String[] args) {
        Rectangle myRectangle = new Rectangle(5.0, 3.0); // Creating a Rectangle object

        System.out.println("Area: " + myRectangle.calculateArea()); // Output: Area: 15.0
        System.out.println("Perimeter: " + myRectangle.calculatePerimeter()); // Output: Perimeter: 16.0

        myRectangle.resize(7.0, 4.0); // Output: Rectangle resized to length: 7.0, width: 4.0
        System.out.println("New Area: " + myRectangle.calculateArea()); // Output: New Area: 28.0
    }
}
```

In this example:

- The Rectangle class has two attributes: length and width.
- It has three methods: calculateArea(), calculatePerimeter(), and resize().
- The calculateArea() method calculates and returns the area of the rectangle.
- The calculatePerimeter() method calculates and returns the perimeter of the rectangle.
- The resize() method changes the length and width of the rectangle and prints a message to the console.
- The Main class demonstrates how to create a Rectangle object, call its methods, and access its attributes.

#### <a name="chapter5part4"></a>Chapter 5 - Part 4: Creating Objects: Instantiating Classes

Creating objects is a fundamental concept in object-oriented programming. It's the process of bringing your class definitions to life, allowing you to work with concrete instances of those classes. Without object instantiation, classes would merely be blueprints, never actually used to store data or perform actions. This lesson will delve into the mechanics of creating objects, exploring the syntax, the underlying processes, and the implications for your Java programs.

#### <a name="chapter5part4.1"></a>Chapter 5 - Part 4.1: Understanding Object Instantiation

Object instantiation, also known as object creation, is the process of creating a new instance of a class. In simpler terms, it's like using a blueprint (the class) to build a house (the object). Each house built from the same blueprint will have the same basic structure, but each can have different paint colors, furniture, and occupants. Similarly, each object created from the same class will have the same attributes (fields) and behaviors (methods), but each object can have different values for its attributes.

**The new Keyword**

The new keyword is the cornerstone of object instantiation in Java. It's the operator that allocates memory for a new object in the heap and returns a reference to that memory location. The basic syntax for creating an object is:

```java
ClassName objectName = new ClassName();
```

Let's break this down:

- **```ClassName```**: This is the name of the class you want to create an object from.
- **```objectName```**: This is the name you give to the new object. It's a variable that will hold a reference to the object in memory.
- **```new```**: This keyword tells Java to create a new object.
- **```ClassName()```**: This is the constructor of the class. It's a special method that initializes the new object. The parentheses () indicate that you're calling a method (in this case, the constructor).

**Constructors: The Object's Initializer**

Constructors are special methods within a class that are automatically called when a new object is created. Their primary purpose is to initialize the object's attributes with appropriate values. Constructors have the same name as the class and do not have a return type (not even void).

**Default Constructor**

If you don't explicitly define a constructor in your class, Java provides a default constructor. The default constructor is a no-argument constructor (it takes no parameters) and initializes all the object's attributes to their default values (e.g., 0 for int, 0.0 for double, false for boolean, and null for object references).

**Parameterized Constructors**

You can also define constructors that take parameters. These are called parameterized constructors. Parameterized constructors allow you to initialize the object's attributes with specific values when the object is created.

```java
class Dog {
    String name;
    int age;

    // Parameterized constructor
    public Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void bark() {
        System.out.println("Woof!");
    }

    public static void main(String[] args) {
        // Creating a Dog object using the parameterized constructor
        Dog myDog = new Dog("Buddy", 3);
        System.out.println("Dog's name: " + myDog.name); // Output: Dog's name: Buddy
        System.out.println("Dog's age: " + myDog.age);   // Output: Dog's age: 3
        myDog.bark(); // Output: Woof!
    }
}
```

In this example, the Dog class has a parameterized constructor that takes the dog's name and age as parameters. When we create a Dog object using new Dog("Buddy", 3), the constructor is called, and the name and age attributes are initialized with the provided values.

**Multiple Objects from the Same Class**

You can create multiple objects from the same class. Each object will be a separate instance of the class, with its own set of attribute values.

```java
class Car {
    String model;
    String color;

    public Car(String model, String color) {
        this.model = model;
        this.color = color;
    }

    public void displayCarDetails() {
        System.out.println("Model: " + this.model + ", Color: " + this.color);
    }

    public static void main(String[] args) {
        Car car1 = new Car("Toyota Camry", "Silver");
        Car car2 = new Car("Honda Civic", "Blue");

        car1.displayCarDetails(); // Output: Model: Toyota Camry, Color: Silver
        car2.displayCarDetails(); // Output: Model: Honda Civic, Color: Blue
    }
}
```

In this example, we create two Car objects, car1 and car2. Each object has its own model and color attributes, which are initialized with different values.

**Object References**

When you create an object using the new keyword, Java allocates memory for the object in the heap and returns a reference to that memory location. This reference is then stored in the variable you used to declare the object.

It's important to understand that the variable doesn't actually contain the object itself; it only contains a reference to the object's location in memory. This has important implications for how objects are handled in Java, particularly when it comes to assignment and comparison.

```java
class Point {
    int x;
    int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public static void main(String[] args) {
        Point p1 = new Point(10, 20);
        Point p2 = p1; // p2 now references the same object as p1

        p2.x = 30; // Modifying p2 also modifies p1 because they point to the same object

        System.out.println("p1.x: " + p1.x); // Output: p1.x: 30
        System.out.println("p2.x: " + p2.x); // Output: p2.x: 30
    }
}
```

In this example, p1 and p2 both reference the same Point object in memory. Therefore, modifying p2.x also modifies p1.x because they are both accessing the same object.

**Null References**

A variable that is declared but not yet assigned a reference to an object has a value of null. null represents the absence of an object reference. Attempting to access an attribute or call a method on a null reference will result in a NullPointerException at runtime.

```java
class Book {
    String title;

    public Book(String title) {
        this.title = title;
    }

    public void displayTitle() {
        System.out.println("Title: " + this.title);
    }

    public static void main(String[] args) {
        Book myBook = null;

        try {
            myBook.displayTitle(); // This will cause a NullPointerException
        } catch (NullPointerException e) {
            System.out.println("Error: myBook is null.  Cannot call displayTitle().");
        }
    }
}
```

It's crucial to check for null references before attempting to use them to prevent NullPointerException errors.

#### <a name="chapter5part4.2"></a>Chapter 5 - Part 4.2: Practical Examples and Demonstrations

Let's solidify our understanding with some practical examples. We'll revisit the Rectangle class from the previous lesson and demonstrate how to create and use Rectangle objects.

```java
class Rectangle {
    double length;
    double width;

    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    public double calculateArea() {
        return length * width;
    }

    public double calculatePerimeter() {
        return 2 * (length + width);
    }

    public static void main(String[] args) {
        // Creating Rectangle objects
        Rectangle rectangle1 = new Rectangle(5.0, 10.0);
        Rectangle rectangle2 = new Rectangle(7.5, 3.2);

        // Accessing attributes and calling methods
        System.out.println("Rectangle 1 Area: " + rectangle1.calculateArea());       // Output: Rectangle 1 Area: 50.0
        System.out.println("Rectangle 1 Perimeter: " + rectangle1.calculatePerimeter()); // Output: Rectangle 1 Perimeter: 30.0
        System.out.println("Rectangle 2 Area: " + rectangle2.calculateArea());       // Output: Rectangle 2 Area: 24.0
        System.out.println("Rectangle 2 Perimeter: " + rectangle2.calculatePerimeter()); // Output: Rectangle 2 Perimeter: 21.4
    }
}
```

In this example, we create two Rectangle objects, rectangle1 and rectangle2, each with different length and width values. We then call the calculateArea() and calculatePerimeter() methods on each object to demonstrate that each object maintains its own state and behavior.

Let's consider another example, a BankAccount class:

```java
class BankAccount {
    String accountNumber;
    String accountHolderName;
    double balance;

    public BankAccount(String accountNumber, String accountHolderName, double initialBalance) {
        this.accountNumber = accountNumber;
        this.accountHolderName = accountHolderName;
        this.balance = initialBalance;
    }

    public void deposit(double amount) {
        this.balance += amount;
        System.out.println("Deposited: " + amount + ". New balance: " + this.balance);
    }

    public void withdraw(double amount) {
        if (amount <= this.balance) {
            this.balance -= amount;
            System.out.println("Withdrawn: " + amount + ". New balance: " + this.balance);
        } else {
            System.out.println("Insufficient funds.");
        }
    }

    public void displayAccountDetails() {
        System.out.println("Account Number: " + this.accountNumber);
        System.out.println("Account Holder: " + this.accountHolderName);
        System.out.println("Balance: " + this.balance);
    }

    public static void main(String[] args) {
        BankAccount account1 = new BankAccount("1234567890", "John Doe", 1000.0);
        BankAccount account2 = new BankAccount("0987654321", "Jane Smith", 500.0);

        account1.displayAccountDetails();
        account1.deposit(500.0);
        account1.withdraw(200.0);

        account2.displayAccountDetails();
        account2.withdraw(600.0); // Insufficient funds
    }
}
```

This example demonstrates how multiple BankAccount objects can be created, each representing a different bank account with its own account number, account holder name, and balance. The deposit() and withdraw() methods operate on the individual object's balance, demonstrating that each object maintains its own state.

#### <a name="chapter5part5"></a>Chapter 5 - Part 5: Accessing Object Attributes and Calling Methods

Object-oriented programming revolves around the concept of objects, which are instances of classes. These objects have attributes (data) and behaviors (methods). This lesson focuses on how to interact with these objects once they've been created – specifically, how to access their attributes to read or modify their data, and how to call their methods to execute their behaviors. Understanding these mechanisms is fundamental to working with objects in Java and building complex, modular applications.

#### <a name="chapter5part5.1"></a>Chapter 5 - Part 5.1: Accessing Object Attributes

Attributes, also known as fields or instance variables, store the data associated with an object. To access an attribute, you use the dot operator (.) followed by the attribute's name. The syntax is objectName.attributeName.

**Reading Attributes**

Reading an attribute's value allows you to retrieve the data stored within an object.

```java
class Dog {
    String name;
    String breed;
    int age;

    public Dog(String name, String breed, int age) {
        this.name = name;
        this.breed = breed;
        this.age = age;
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy", "Golden Retriever", 3);

        // Accessing attributes
        String dogName = myDog.name;
        String dogBreed = myDog.breed;
        int dogAge = myDog.age;

        System.out.println("Dog's name: " + dogName); // Output: Dog's name: Buddy
        System.out.println("Dog's breed: " + dogBreed); // Output: Dog's breed: Golden Retriever
        System.out.println("Dog's age: " + dogAge); // Output: Dog's age: 3
    }
}
```

In this example, we create a Dog object named myDog. We then use the dot operator to access the name, breed, and age attributes and store their values in separate variables. Finally, we print these values to the console.

**Modifying Attributes**

Modifying an attribute's value allows you to change the data stored within an object.

```java
class Dog {
    String name;
    String breed;
    int age;

    public Dog(String name, String breed, int age) {
        this.name = name;
        this.breed = breed;
        this.age = age;
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy", "Golden Retriever", 3);

        System.out.println("Original age: " + myDog.age); // Output: Original age: 3

        // Modifying the age attribute
        myDog.age = 4;

        System.out.println("New age: " + myDog.age); // Output: New age: 4
    }
}
```

Here, we first create a Dog object and print its initial age. Then, we use the dot operator to assign a new value (4) to the age attribute. Finally, we print the updated age to confirm the modification.

**Considerations for Attribute Access**

- **Access Modifiers**: The ability to access and modify attributes is controlled by access modifiers (public, private, protected, and default). We will cover access modifiers in detail in a later lesson, but it's important to note that private attributes can only be accessed within the class itself, while public attributes can be accessed from anywhere.
- **Data Encapsulation**: Direct access to attributes can sometimes violate the principle of encapsulation, which aims to protect an object's internal state. It's often better to use getter and setter methods (covered in the next section) to control how attributes are accessed and modified.

#### <a name="chapter5part5.2"></a>Chapter 5 - Part 5.2: Calling Methods

Methods define the behaviors or actions that an object can perform. To call a method, you use the dot operator (.) followed by the method's name and parentheses (). If the method requires arguments, you pass them within the parentheses. The syntax is objectName.methodName(arguments).

**Basic Method Call**

```java
class Dog {
    String name;
    String breed;
    int age;

    public Dog(String name, String breed, int age) {
        this.name = name;
        this.breed = breed;
        this.age = age;
    }

    public void bark() {
        System.out.println("Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy", "Golden Retriever", 3);

        // Calling the bark method
        myDog.bark(); // Output: Woof!
    }
}
```

In this example, the Dog class has a bark() method that prints "Woof!" to the console. We create a Dog object and then call the bark() method using the dot operator.

**Methods with Arguments**

Methods can accept arguments, which are values passed to the method when it's called.

```java
class Dog {
    String name;
    String breed;
    int age;

    public Dog(String name, String breed, int age) {
        this.name = name;
        this.breed = breed;
        this.age = age;
    }

    public void bark(int numberOfTimes) {
        for (int i = 0; i < numberOfTimes; i++) {
            System.out.println("Woof!");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy", "Golden Retriever", 3);

        // Calling the bark method with an argument
        myDog.bark(3); // Output: Woof! Woof! Woof!
    }
}
```

Here, the bark() method now accepts an integer argument numberOfTimes. When we call the method, we pass the value 3, which causes the method to print "Woof!" three times.

**Methods with Return Values**

Methods can also return values, which are the results of the method's execution. The return type is specified in the method declaration.

```java
class Dog {
    String name;
    String breed;
    int age;

    public Dog(String name, String breed, int age) {
        this.name = name;
        this.breed = breed;
        this.age = age;
    }

    public int getAgeInDogYears() {
        return age * 7;
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy", "Golden Retriever", 3);

        // Calling the getAgeInDogYears method and storing the return value
        int dogYears = myDog.getAgeInDogYears();

        System.out.println("Age in dog years: " + dogYears); // Output: Age in dog years: 21
    }
}
```

In this example, the getAgeInDogYears() method calculates the dog's age in dog years and returns the result as an integer. We call the method and store the returned value in the dogYears variable.

**Chaining Method Calls**

In some cases, you can chain method calls together if a method returns an object that has other methods you want to call.

```java
class StringModifier {
    private String text;

    public StringModifier(String text) {
        this.text = text;
    }

    public StringModifier toUpperCase() {
        this.text = this.text.toUpperCase();
        return this;
    }

    public StringModifier trim() {
        this.text = this.text.trim();
        return this;
    }

    public String getText() {
        return this.text;
    }
}

public class Main {
    public static void main(String[] args) {
        StringModifier modifier = new StringModifier("  hello world  ");
        String result = modifier.trim().toUpperCase().getText();
        System.out.println(result); // Output: HELLO WORLD
    }
}
```

In this example, the trim() and toUpperCase() methods return the StringModifier object itself, allowing you to chain the calls. The getText() method then returns the modified string.

**Considerations for Method Calls**

- **Method Signature**: The method signature consists of the method's name and the number, type, and order of its parameters. When calling a method, you must provide arguments that match the method's signature.
- **Return Type**: If a method has a return type (other than void), you must handle the returned value. This typically involves assigning it to a variable or using it in an expression.
- **Access Modifiers**: Similar to attributes, the ability to call a method is controlled by access modifiers. private methods can only be called from within the class itself, while public methods can be called from anywhere.

#### <a name="chapter5part6"></a>Chapter 5 - Part 6: Constructors: Initializing Objects

Constructors are special methods in Java that play a crucial role in object-oriented programming. They are responsible for initializing the state of an object when it is created. Understanding constructors is fundamental to creating well-behaved and predictable objects. Without constructors, objects might be created in an inconsistent or unusable state, leading to unexpected behavior in your programs. This lesson will delve into the details of constructors, their types, and how to use them effectively.

#### <a name="chapter5part6.1"></a>Chapter 5 - Part 6.1: Understanding Constructors

A constructor is a special method that is called when an object of a class is created. Its primary purpose is to initialize the object's attributes (fields) with appropriate values. Constructors have the same name as the class and do not have a return type (not even void).

**Purpose of Constructors**

The main purposes of constructors are:

- **Initialization**: To set the initial values of the object's attributes.
- **Resource Allocation**: To allocate any necessary resources for the object, such as memory or file handles.
- **Ensuring Validity**: To ensure that the object is in a valid state when it is created.

**Types of Constructors**

There are two main types of constructors in Java:

- **Default Constructor (No-Argument Constructor)**: A constructor that takes no arguments. If you don't define any constructors in your class, Java automatically provides a default constructor.
- **Parameterized Constructor**: A constructor that takes one or more arguments. You can define parameterized constructors to initialize the object's attributes with specific values.

#### <a name="chapter5part6.2"></a>Chapter 5 - Part 6.2: Default Constructor (No-Argument Constructor)

The default constructor is a constructor that takes no arguments. If you don't explicitly define any constructors in your class, Java provides a default constructor implicitly. This default constructor initializes all instance variables to their default values (e.g., 0 for int, 0.0 for double, false for boolean, and null for object references).

**Implicit Default Constructor**

If you don't define any constructors in your class, Java automatically provides a default constructor.

```java
class Dog {
    String breed;
    int age;

    // No constructor defined, so Java provides a default constructor
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog(); // Calls the default constructor
        System.out.println("Breed: " + myDog.breed); // Output: Breed: null
        System.out.println("Age: " + myDog.age);     // Output: Age: 0
    }
}
```

In this example, since we didn't define a constructor for the Dog class, Java provides a default constructor. The breed attribute is initialized to null (the default value for String), and the age attribute is initialized to 0 (the default value for int).

**Explicit Default Constructor**

You can also define a default constructor explicitly. This is useful if you want to perform some additional initialization logic when an object is created.

```java
class Cat {
    String name;
    int age;

    // Explicit default constructor
    public Cat() {
        name = "Unknown";
        age = 0;
        System.out.println("Cat object created with default values.");
    }
}

public class Main {
    public static void main(String[] args) {
        Cat myCat = new Cat(); // Calls the explicit default constructor
        System.out.println("Name: " + myCat.name); // Output: Name: Unknown
        System.out.println("Age: " + myCat.age);   // Output: Age: 0
    }
}
```

In this example, we explicitly defined a default constructor for the Cat class. When a Cat object is created, the constructor sets the name attribute to "Unknown" and the age attribute to 0. It also prints a message to the console.

#### <a name="chapter5part6.3"></a>Chapter 5 - Part 6.3: Parameterized Constructor

A parameterized constructor is a constructor that takes one or more arguments. It allows you to initialize the object's attributes with specific values when the object is created.

**Defining Parameterized Constructors**

To define a parameterized constructor, you specify the parameters in the constructor's parentheses.

```java
class Person {
    String name;
    int age;

    // Parameterized constructor
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

public class Main {
    public static void main(String[] args) {
        Person person1 = new Person("Alice", 30); // Calls the parameterized constructor
        System.out.println("Name: " + person1.name); // Output: Name: Alice
        System.out.println("Age: " + person1.age);   // Output: Age: 30
    }
}
```

In this example, we defined a parameterized constructor for the Person class that takes two arguments: name (a String) and age (an int). When a Person object is created, the constructor sets the name and age attributes to the values passed as arguments. The this keyword is used to refer to the instance variables of the class.

**Multiple Constructors (Constructor Overloading)**

You can define multiple constructors in a class, as long as they have different parameter lists (i.e., different numbers or types of parameters). This is known as constructor overloading.

```java
class Book {
    String title;
    String author;
    int publicationYear;

    // Constructor 1: Takes title and author
    public Book(String title, String author) {
        this.title = title;
        this.author = author;
        this.publicationYear = 0; // Default value
    }

    // Constructor 2: Takes title, author, and publicationYear
    public Book(String title, String author, int publicationYear) {
        this.title = title;
        this.author = author;
        this.publicationYear = publicationYear;
    }
}

public class Main {
    public static void main(String[] args) {
        Book book1 = new Book("The Lord of the Rings", "J.R.R. Tolkien");
        System.out.println("Title: " + book1.title + ", Author: " + book1.author + ", Year: " + book1.publicationYear);
        // Output: Title: The Lord of the Rings, Author: J.R.R. Tolkien, Year: 0

        Book book2 = new Book("1984", "George Orwell", 1949);
        System.out.println("Title: " + book2.title + ", Author: " + book2.author + ", Year: " + book2.publicationYear);
        // Output: Title: 1984, Author: George Orwell, Year: 1949
    }
}
```

In this example, we defined two constructors for the Book class. The first constructor takes the title and author as arguments and sets the publicationYear to a default value of 0. The second constructor takes the title, author, and publicationYear as arguments.

**Calling One Constructor from Another**

Within a constructor, you can call another constructor of the same class using the this() keyword. This is useful for avoiding code duplication and ensuring that common initialization logic is performed in a single place.

```java
class Rectangle {
    int width;
    int height;

    // Constructor 1: Takes width and height
    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }

    // Constructor 2: Takes side (for a square)
    public Rectangle(int side) {
        this(side, side); // Calls the first constructor
    }
}

public class Main {
    public static void main(String[] args) {
        Rectangle rectangle1 = new Rectangle(5, 10);
        System.out.println("Width: " + rectangle1.width + ", Height: " + rectangle1.height);
        // Output: Width: 5, Height: 10

        Rectangle rectangle2 = new Rectangle(7);
        System.out.println("Width: " + rectangle2.width + ", Height: " + rectangle2.height);
        // Output: Width: 7, Height: 7
    }
}
```

In this example, the second constructor Rectangle(int side) calls the first constructor Rectangle(int width, int height) using this(side, side). This ensures that the width and height attributes are initialized correctly when a Rectangle object is created with a single side length (for a square).

#### <a name="chapter5part6.4"></a>Chapter 5 - Part 6.4: The this Keyword

The this keyword is a reference to the current object. It is used to access the object's attributes and methods from within the object itself.

**Using this to Differentiate Instance Variables from Local Variables**

When a constructor or method has a parameter with the same name as an instance variable, you can use the this keyword to differentiate between them.

```java
class Car {
    String model;

    // Constructor
    public Car(String model) {
        this.model = model; // 'this.model' refers to the instance variable, 'model' refers to the parameter
    }

    public void printModel() {
        System.out.println("Model: " + this.model);
    }
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car("Tesla Model 3");
        myCar.printModel(); // Output: Model: Tesla Model 3
    }
}
```

In this example, the constructor has a parameter named model, which has the same name as the instance variable model. The this.model = model; statement assigns the value of the parameter model to the instance variable model.

**Using this to Call Another Constructor**

As shown in the previous section, you can use the this() keyword to call another constructor of the same class. This is useful for avoiding code duplication and ensuring that common initialization logic is performed in a single place.

#### <a name="chapter5part6.5"></a>Chapter 5 - Part 6.5: Practical Examples and Demonstrations

Let's consider a more complex example with a BankAccount class.

```java
class BankAccount {
    String accountNumber;
    String accountHolderName;
    double balance;

    // Default constructor
    public BankAccount() {
        this.accountNumber = "Unknown";
        this.accountHolderName = "Unknown";
        this.balance = 0.0;
    }

    // Parameterized constructor
    public BankAccount(String accountNumber, String accountHolderName, double initialBalance) {
        this.accountNumber = accountNumber;
        this.accountHolderName = accountHolderName;
        this.balance = initialBalance;
    }

    public void deposit(double amount) {
        this.balance += amount;
    }

    public void withdraw(double amount) {
        if (amount <= this.balance) {
            this.balance -= amount;
        } else {
            System.out.println("Insufficient funds.");
        }
    }

    public void printAccountDetails() {
        System.out.println("Account Number: " + this.accountNumber);
        System.out.println("Account Holder Name: " + this.accountHolderName);
        System.out.println("Balance: " + this.balance);
    }
}

public class Main {
    public static void main(String[] args) {
        BankAccount account1 = new BankAccount();
        account1.printAccountDetails();
        // Output:
        // Account Number: Unknown
        // Account Holder Name: Unknown
        // Balance: 0.0

        BankAccount account2 = new BankAccount("1234567890", "John Doe", 1000.0);
        account2.deposit(500.0);
        account2.withdraw(200.0);
        account2.printAccountDetails();
        // Output:
        // Account Number: 1234567890
        // Account Holder Name: John Doe
        // Balance: 1300.0
    }
}
```

In this example, the BankAccount class has a default constructor and a parameterized constructor. The default constructor initializes the account number and account holder name to "Unknown" and the balance to 0.0. The parameterized constructor initializes the account number, account holder name, and balance to the values passed as arguments. The deposit and withdraw methods update the balance, and the printAccountDetails method prints the account details.

#### <a name="chapter5part7"></a>Chapter 5 - Part 7: The `this` Keyword: Referring to the Current Object

The this keyword is a fundamental concept in object-oriented programming (OOP) in Java. It acts as a reference to the current object within a class. Understanding this is crucial for writing clear, maintainable, and bug-free code, especially when dealing with instance variables, constructors, and method chaining. It allows you to disambiguate between instance variables and local variables, and to pass the current object as an argument to other methods.

#### <a name="chapter5part7.1"></a>Chapter 5 - Part 7.1: Understanding the this Keyword

The this keyword in Java is a reference variable that refers to the current object. It's used to access the object's members (fields and methods) from within the object itself. The this keyword is implicitly available inside every non-static method and constructor.

**Purpose of this**

The primary purposes of the this keyword are:

- **To differentiate between instance variables and local variables**: When a method or constructor has a local variable with the same name as an instance variable, this is used to refer to the instance variable.
- **To call one constructor from another**: Within a class, one constructor can call another constructor using this(). This is useful for code reuse and ensuring that objects are properly initialized.
- **To return the current object**: A method can return this, allowing for method chaining.
- **To pass the current object as an argument to another method**: The this keyword can be used to pass the current object as an argument to another method within the same class or in another class.

**Differentiating Instance Variables from Local Variables**

When a method or constructor has a local variable with the same name as an instance variable, the local variable takes precedence within the scope of that method or constructor. To access the instance variable, you must use the this keyword.

```java
public class Dog {
    private String name;
    private int age;

    public Dog(String name, int age) {
        // 'name' and 'age' are local variables (parameters)
        // 'this.name' and 'this.age' refer to the instance variables
        this.name = name;
        this.age = age;
    }

    public void bark() {
        System.out.println("Woof! My name is " + this.name + " and I am " + this.age + " years old.");
    }

    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy", 3);
        myDog.bark(); // Output: Woof! My name is Buddy and I am 3 years old.
    }
}
```

In this example, the constructor parameters name and age have the same names as the instance variables name and age. Without this, the constructor would not be able to correctly assign the values of the parameters to the instance variables.

**Example without this (Incorrect):**

```java
public class Dog {
    private String name;
    private int age;

    public Dog(String name, int age) {
        name = name; // No effect: assigns the local variable to itself
        age = age;   // No effect: assigns the local variable to itself
    }

    public void bark() {
        System.out.println("Woof! My name is " + name + " and I am " + age + " years old.");
    }

    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy", 3);
        myDog.bark(); // Output: Woof! My name is null and I am 0 years old.
    }
}
```

In this incorrect example, the instance variables name and age are never initialized because the constructor is assigning the local variables to themselves.

**Calling One Constructor from Another**

Within a class, one constructor can call another constructor using this(). This is useful for avoiding code duplication and ensuring that common initialization logic is executed regardless of which constructor is used to create the object. The call to this() must be the first statement in the constructor.

```java
public class Rectangle {
    private int width;
    private int height;

    public Rectangle() {
        this(1, 1); // Call the constructor with width = 1 and height = 1
        System.out.println("Default constructor called");
    }

    public Rectangle(int size) {
        this(size, size); // Call the constructor with width = size and height = size
        System.out.println("Square constructor called");
    }

    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
        System.out.println("Rectangle constructor called");
    }

    public int getArea() {
        return width * height;
    }

    public static void main(String[] args) {
        Rectangle rect1 = new Rectangle();        // Output: Rectangle constructor called, Default constructor called
        Rectangle rect2 = new Rectangle(5);       // Output: Rectangle constructor called, Square constructor called
        Rectangle rect3 = new Rectangle(4, 6);    // Output: Rectangle constructor called

        System.out.println("Area of rect1: " + rect1.getArea()); // Output: Area of rect1: 1
        System.out.println("Area of rect2: " + rect2.getArea()); // Output: Area of rect2: 25
        System.out.println("Area of rect3: " + rect3.getArea()); // Output: Area of rect3: 24
    }
}
```

In this example, the default constructor Rectangle() calls the Rectangle(int width, int height) constructor with default values of 1 for both width and height. The Rectangle(int size) constructor calls the Rectangle(int width, int height) constructor with the same value for both width and height, creating a square. This avoids duplicating the initialization logic in each constructor.

**Returning the Current Object (Method Chaining)**

A method can return this, which allows for method chaining. Method chaining is a technique where multiple method calls are chained together in a single statement. This can make code more concise and readable.

```java
public class Car {
    private String color;
    private String model;

    public Car setColor(String color) {
        this.color = color;
        return this; // Return the current object
    }

    public Car setModel(String model) {
        this.model = model;
        return this; // Return the current object
    }

    public void display() {
        System.out.println("Color: " + color + ", Model: " + model);
    }

    public static void main(String[] args) {
        Car myCar = new Car()
                .setColor("Red")
                .setModel("Sedan");
        myCar.display(); // Output: Color: Red, Model: Sedan
    }
}
```

In this example, the setColor() and setModel() methods both return this, allowing you to chain the method calls together. This makes the code more readable and concise.

**Passing the Current Object as an Argument**

The this keyword can be used to pass the current object as an argument to another method, either within the same class or in another class. This is useful when you need to perform operations on the current object in another method or class.

```java
class Engine {
    public void start(Car car) {
        System.out.println("Starting the " + car.getModel() + " engine.");
    }
}

public class Car {
    private String color;
    private String model;
    private Engine engine;

    public Car(String model) {
        this.model = model;
        this.engine = new Engine();
    }

    public String getColor() {
        return color;
    }

    public String getModel() {
        return model;
    }

    public void startEngine() {
        engine.start(this); // Pass the current Car object to the start method of the Engine class
    }

    public static void main(String[] args) {
        Car myCar = new Car("SUV");
        myCar.startEngine(); // Output: Starting the SUV engine.
    }
}
```

In this example, the startEngine() method passes the current Car object to the start() method of the Engine class. This allows the Engine class to access the Car object's properties, such as the model.

#### <a name="chapter5part7.2"></a>Chapter 5 - Part 7.2: Practical Examples and Demonstrations

Let's consider a more complex example involving a Person class and an Address class to further illustrate the use of this.

```java
class Address {
    private String street;
    private String city;
    private String zipCode;

    public Address(String street, String city, String zipCode) {
        this.street = street;
        this.city = city;
        this.zipCode = zipCode;
    }

    public String getStreet() {
        return street;
    }

    public String getCity() {
        return city;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void displayAddress() {
        System.out.println("Street: " + street + ", City: " + city + ", Zip Code: " + zipCode);
    }
}

public class Person {
    private String name;
    private int age;
    private Address address;

    public Person(String name, int age, Address address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public Address getAddress() {
        return address;
    }

    public void displayPersonInfo() {
        System.out.println("Name: " + this.name + ", Age: " + this.age);
        this.address.displayAddress(); // Calling a method on another object using 'this' context
    }

    public boolean isOlderThan(Person otherPerson) {
        return this.age > otherPerson.getAge(); // Comparing the age of the current object with another object
    }

    public static void main(String[] args) {
        Address address1 = new Address("123 Main St", "Anytown", "12345");
        Person person1 = new Person("Alice", 30, address1);

        Address address2 = new Address("456 Oak Ave", "Springfield", "67890");
        Person person2 = new Person("Bob", 25, address2);

        person1.displayPersonInfo();
        // Output:
        // Name: Alice, Age: 30
        // Street: 123 Main St, City: Anytown, Zip Code: 12345

        person2.displayPersonInfo();
        // Output:
        // Name: Bob, Age: 25
        // Street: 456 Oak Ave, City: Springfield, Zip Code: 67890

        System.out.println("Is Alice older than Bob? " + person1.isOlderThan(person2)); // Output: Is Alice older than Bob? true
    }
}
```

In this example:

- The Person class has instance variables name, age, and address.
- The constructor uses this to differentiate between the constructor parameters and the instance variables.
- The displayPersonInfo() method uses this to access the instance variables and calls the displayAddress() method on the address object.
- The isOlderThan() method uses this to compare the age of the current Person object with the age of another Person object.

#### <a name="chapter5part8"></a>Chapter 5 - Part 8: Introduction to Encapsulation: Hiding Data

Encapsulation is a fundamental concept in object-oriented programming (OOP) that focuses on bundling data (attributes) and the methods that operate on that data into a single unit, known as a class. More importantly, it involves controlling access to this data, preventing direct manipulation from outside the class. This "hiding" of data is a crucial aspect of encapsulation, promoting data integrity and reducing the risk of unintended side effects. This lesson will delve into the principles of encapsulation, exploring how it enhances code maintainability, flexibility, and security.

#### <a name="chapter5part8.1"></a>Chapter 5 - Part 8.1: Understanding Encapsulation

Encapsulation is often described as "data hiding." It's a mechanism that restricts direct access to some of an object's components and can only be accessed through methods of that class. This protects the data from accidental corruption or misuse. Think of it like a capsule that contains medicine; the medicine (data) is protected within the capsule, and you can only access it in a controlled manner (through methods).

**Key Principles of Encapsulation**

- **Data Hiding**: Protecting the internal state of an object by making attributes private.
- **Controlled Access**: Providing access to the data through public methods (getters and setters).
- **Bundling**: Combining data and methods that operate on that data within a class.

**Benefits of Encapsulation**

- **Data Integrity**: By controlling access to data, encapsulation prevents direct modification, ensuring that data remains in a consistent and valid state.
- **Modularity**: Encapsulation promotes modularity by creating self-contained units (classes) that can be developed, tested, and maintained independently.
- **Flexibility**: Encapsulation allows you to change the internal implementation of a class without affecting other parts of the code that use it, as long as the public interface (methods) remains the same.
- **Code Reusability**: Encapsulated classes can be easily reused in different parts of the application or in other projects.

#### <a name="chapter5part8.2"></a>Chapter 5 - Part 8.2: Implementing Encapsulation in Java

In Java, encapsulation is achieved using access modifiers: private, protected, and public. For data hiding, we primarily use the private access modifier.

**Access Modifiers**

- **```private```**: Members (attributes and methods) declared as private are only accessible within the same class.
- **```public```**: Members declared as public are accessible from anywhere.
- **```protected```**: Members declared as protected are accessible within the same package and by subclasses in other packages. We will cover this in more detail when we discuss inheritance.
- **Default (no modifier)**: If no access modifier is specified, the member has default (package-private) access, meaning it's accessible within the same package.

**Getters and Setters**

To provide controlled access to private attributes, we use getter and setter methods (also known as accessor and mutator methods).

- **Getter (Accessor)**: A public method that returns the value of a private attribute. It typically follows the naming convention getVariableName().
- **Setter (Mutator)**: A public method that allows you to modify the value of a private attribute. It typically follows the naming convention setVariableName(newValue). Setters often include validation logic to ensure that the new value is valid.

**Example: Encapsulating a BankAccount Class**

Let's consider a BankAccount class. We want to encapsulate the accountNumber and balance attributes to protect them from direct modification.

```java
public class BankAccount {
    private String accountNumber;
    private double balance;

    public BankAccount(String accountNumber, double balance) {
        this.accountNumber = accountNumber;
        this.balance = balance;
    }

    // Getter for accountNumber
    public String getAccountNumber() {
        return accountNumber;
    }

    // Setter for accountNumber (Consider if you really need to change the account number)
    public void setAccountNumber(String accountNumber) {
        // You might want to add validation here, e.g., check if the new account number is valid
        this.accountNumber = accountNumber;
    }

    // Getter for balance
    public double getBalance() {
        return balance;
    }

    // Setter for balance (More complex logic is usually needed for balance)
    public void setBalance(double balance) {
        if (balance >= 0) {
            this.balance = balance;
        } else {
            System.out.println("Invalid balance. Balance cannot be negative.");
        }
    }

    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            System.out.println("Deposit of " + amount + " successful. New balance: " + balance);
        } else {
            System.out.println("Invalid deposit amount. Amount must be positive.");
        }
    }

    public void withdraw(double amount) {
        if (amount > 0 && balance >= amount) {
            balance -= amount;
            System.out.println("Withdrawal of " + amount + " successful. New balance: " + balance);
        } else {
            System.out.println("Insufficient funds or invalid withdrawal amount.");
        }
    }
}
```

In this example:

- accountNumber and balance are declared as private, making them inaccessible directly from outside the BankAccount class.
- getAccountNumber() and getBalance() are getter methods that allow you to retrieve the values of these attributes.
- setAccountNumber() and setBalance() are setter methods that allow you to modify the values, but they can include validation logic to ensure data integrity.
- deposit() and withdraw() methods encapsulate the logic for modifying the balance, ensuring that the balance is updated correctly and that withdrawals don't result in a negative balance.

**Example Usage**

```java
public class Main {
    public static void main(String[] args) {
        BankAccount myAccount = new BankAccount("1234567890", 1000.0);

        // Accessing balance using the getter method
        System.out.println("Account balance: " + myAccount.getBalance());

        // Depositing money
        myAccount.deposit(500.0);

        // Withdrawing money
        myAccount.withdraw(200.0);

        // Trying to withdraw more than the balance
        myAccount.withdraw(2000.0);

        //Trying to set an invalid balance
        myAccount.setBalance(-100);

        // Accessing account number using the getter method
        System.out.println("Account number: " + myAccount.getAccountNumber());
    }
}
```

This example demonstrates how to interact with the BankAccount class through its public methods, ensuring that the internal state of the object is protected.

#### <a name="chapter5part8.3"></a>Chapter 5 - Part 8.3: Advanced Encapsulation Techniques

While basic getters and setters are common, encapsulation can involve more sophisticated techniques.

**Read-Only Attributes**

Sometimes, you might want an attribute to be readable but not modifiable from outside the class. You can achieve this by providing a getter method but omitting the setter method.

```java
public class Circle {
    private final double radius; // Radius is set once during object creation

    public Circle(double radius) {
        this.radius = radius;
    }

    public double getRadius() {
        return radius;
    }

    // No setter method for radius, making it read-only
}
```

In this example, the radius attribute is initialized in the constructor and can be accessed using the getRadius() method, but it cannot be modified after the object is created. The final keyword ensures that the value of radius cannot be changed after initialization.

**Validation in Setters**

Setters are the ideal place to implement validation logic to ensure that the data being assigned to an attribute is valid.

```java
public class Employee {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name != null && !name.isEmpty()) {
            this.name = name;
        } else {
            System.out.println("Invalid name. Name cannot be null or empty.");
        }
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if (age >= 18 && age <= 65) {
            this.age = age;
        } else {
            System.out.println("Invalid age. Age must be between 18 and 65.");
        }
    }
}
```

In this example, the setAge() method validates that the age is within a reasonable range (18-65) before assigning it to the age attribute.

**Data Transformation in Getters and Setters**

Getters and setters can also be used to transform data before it's returned or assigned.

```java
public class Product {
    private double price;

    public double getPrice() {
        // Apply a discount before returning the price
        return price * 0.9; // 10% discount
    }

    public void setPrice(double price) {
        // Ensure the price is not negative
        if (price >= 0) {
            this.price = price;
        } else {
            System.out.println("Invalid price. Price cannot be negative.");
        }
    }
}
```

In this example, the getPrice() method applies a 10% discount before returning the price, and the setPrice() method ensures that the price is not negative.

## <a name="chapter6"></a>Chapter 6: Methods and Classes in Depth

#### <a name="chapter6part1"></a>Chapter 6 - Part 1: Method Overloading: Creating Methods with the Same Name

Method overloading is a powerful feature in Java that allows you to define multiple methods within the same class that share the same name but have different parameter lists. This capability enhances code readability and flexibility by allowing you to use a single method name to perform similar actions on different types of data or with a different number of arguments. It's a cornerstone of polymorphism, one of the key principles of object-oriented programming.

#### <a name="chapter6part1.1"></a>Chapter 6 - Part 1.1: Understanding Method Overloading

Method overloading occurs when a class contains two or more methods with the same name but different signatures. The signature of a method consists of the method's name and the number, types, and order of its parameters. The return type of a method is not part of its signature, meaning you cannot overload methods based solely on their return type.

**Key Principles of Method Overloading**

- **Same Name, Different Parameters**: Methods must have the same name but differ in the number, type, or order of their parameters.
- **Return Type is Irrelevant**: The return type of the method does not play a role in method overloading. Methods with the same name and parameters but different return types will result in a compilation error.
- **Compiler Resolution**: The Java compiler determines which overloaded method to call based on the arguments passed to the method during the method call. This is known as compile-time polymorphism or static polymorphism.

**Examples of Method Overloading**

Let's consider a simple Calculator class to illustrate method overloading:

```java
public class Calculator {

    // Method to add two integers
    public int add(int a, int b) {
        System.out.println("Adding two integers");
        return a + b;
    }

    // Method to add three integers
    public int add(int a, int b, int c) {
        System.out.println("Adding three integers");
        return a + b + c;
    }

    // Method to add two doubles
    public double add(double a, double b) {
        System.out.println("Adding two doubles");
        return a + b;
    }

    // Method to add an integer and a double
    public double add(int a, double b) {
        System.out.println("Adding an integer and a double");
        return a + b;
    }

    // Method to add a double and an integer
    public double add(double a, int b) {
        System.out.println("Adding a double and an integer");
        return a + b;
    }

    public static void main(String[] args) {
        Calculator calc = new Calculator();

        System.out.println(calc.add(2, 3));       // Calls add(int, int)
        System.out.println(calc.add(2, 3, 4));    // Calls add(int, int, int)
        System.out.println(calc.add(2.5, 3.5));   // Calls add(double, double)
        System.out.println(calc.add(2, 3.5));     // Calls add(int, double)
        System.out.println(calc.add(2.5, 3));     // Calls add(double, int)
    }
}
```

In this example, the Calculator class has multiple add methods, each accepting different parameters. When you call the add method, the compiler determines which version to execute based on the arguments you provide.

**Detailed Explanation of the Code Example**

- ```add(int a, int b)```: This method takes two integer arguments and returns their sum as an integer.
- ```add(int a, int b, int c)```: This method takes three integer arguments and returns their sum as an integer.
- ```add(double a, double b)```: This method takes two double arguments and returns their sum as a double.
- ```add(int a, double b)```: This method takes an integer and a double as arguments and returns their sum as a double.
- ```add(double a, int b)```: This method takes a double and an integer as arguments and returns their sum as a double.

The main method demonstrates how each overloaded method is called based on the arguments passed. The output of the program will be:

```
Adding two integers
5
Adding three integers
9
Adding two doubles
6.0
Adding an integer and a double
5.5
Adding a double and an integer
5.5
```

**Another Example: Overloading with Different Data Types**

```java
public class StringConverter {

    public String convert(int num) {
        return String.valueOf(num);
    }

    public String convert(double num) {
        return String.valueOf(num);
    }

    public String convert(boolean bool) {
        return String.valueOf(bool);
    }

    public static void main(String[] args) {
        StringConverter converter = new StringConverter();

        System.out.println(converter.convert(10));       // Calls convert(int)
        System.out.println(converter.convert(3.14));     // Calls convert(double)
        System.out.println(converter.convert(true));     // Calls convert(boolean)
    }
}
```

This example shows how the convert method is overloaded to handle different data types (int, double, boolean) and convert them into strings.

**Overloading vs. Overriding**

It's crucial to distinguish between method overloading and method overriding.

- **Overloading**: Occurs within the same class. Methods have the same name but different parameter lists. Resolved at compile time (static polymorphism).
- **Overriding**: Occurs in different classes (inheritance). A subclass provides a specific implementation of a method that is already defined in its superclass. Methods have the same name and parameter list. Resolved at runtime (dynamic polymorphism), which will be covered in a later lesson.

#### <a name="chapter6part1.2"></a>Chapter 6 - Part 1.2: Practical Examples and Demonstrations

**Example 1: A Printer Class**

Consider a Printer class that can print different types of data:

```java
public class Printer {

    public void print(String text) {
        System.out.println("Printing String: " + text);
    }

    public void print(int number) {
        System.out.println("Printing Integer: " + number);
    }

    public void print(String text, int number) {
        System.out.println("Printing String: " + text + ", Printing Integer: " + number);
    }

    public static void main(String[] args) {
        Printer printer = new Printer();
        printer.print("Hello");          // Calls print(String)
        printer.print(123);             // Calls print(int)
        printer.print("World", 456);    // Calls print(String, int)
    }
}
```

This example demonstrates how the print method can be overloaded to handle different types of input, providing flexibility in how data is printed.

**Example 2: A Shape Class (Illustrating Area Calculation)**

```java
public class Shape {

    public double calculateArea(double radius) {
        System.out.println("Calculating area of a circle");
        return Math.PI * radius * radius;
    }

    public double calculateArea(double length, double width) {
        System.out.println("Calculating area of a rectangle");
        return length * width;
    }

    public double calculateArea(int side) {
        System.out.println("Calculating area of a square");
        return side * side;
    }

    public static void main(String[] args) {
        Shape shape = new Shape();
        System.out.println("Area of circle: " + shape.calculateArea(5.0));
        System.out.println("Area of rectangle: " + shape.calculateArea(4.0, 6.0));
        System.out.println("Area of square: " + shape.calculateArea(5));
    }
}
```

This Shape class overloads the calculateArea method to compute the area of different shapes (circle, rectangle, square) based on the input parameters.

**Example 3: Overloading Constructors**

Constructors can also be overloaded, allowing you to create objects with different initializations.

```java
public class Rectangle {
    private double length;
    private double width;

    public Rectangle() {
        this.length = 1.0;
        this.width = 1.0;
        System.out.println("Default rectangle created");
    }

    public Rectangle(double side) {
        this.length = side;
        this.width = side;
        System.out.println("Square rectangle created");
    }

    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
        System.out.println("Rectangle created with length and width");
    }

    public double getLength() {
        return length;
    }

    public double getWidth() {
        return width;
    }

    public static void main(String[] args) {
        Rectangle rect1 = new Rectangle();          // Calls Rectangle()
        Rectangle rect2 = new Rectangle(5.0);       // Calls Rectangle(double)
        Rectangle rect3 = new Rectangle(4.0, 6.0);    // Calls Rectangle(double, double)

        System.out.println("Rectangle 1: Length = " + rect1.getLength() + ", Width = " + rect1.getWidth());
        System.out.println("Rectangle 2: Length = " + rect2.getLength() + ", Width = " + rect2.getWidth());
        System.out.println("Rectangle 3: Length = " + rect3.getLength() + ", Width = " + rect3.getWidth());
    }
}
```

In this example, the Rectangle class has three constructors: a default constructor, a constructor that takes one argument (for creating a square), and a constructor that takes two arguments (for creating a general rectangle).

#### <a name="chapter6part2"></a>Chapter 6 - Part 2: Method Parameters and Return Types

Method parameters and return types are fundamental concepts in Java programming. They define how methods receive data and how they provide results back to the calling code. Understanding these concepts is crucial for writing modular, reusable, and well-structured programs. This lesson will delve into the details of method parameters and return types, providing a comprehensive understanding of their usage and importance.

#### <a name="chapter6part2.1"></a>Chapter 6 - Part 2.1: Understanding Method Parameters

Method parameters are variables that receive values when a method is called. They allow you to pass data into a method, enabling the method to operate on different inputs and produce different results.

**Formal vs. Actual Parameters**

It's important to distinguish between formal and actual parameters:

- **Formal Parameters**: These are the parameters declared in the method signature. They define the type and name of the data that the method expects to receive.
- **Actual Parameters (Arguments)**: These are the values passed to the method when it is called. They must match the type and order of the formal parameters.

Consider the following example:

```java
public class Calculator {
    // Formal parameters: int a, int b
    public int add(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        Calculator calc = new Calculator();
        // Actual parameters: 5, 3
        int sum = calc.add(5, 3);
        System.out.println("Sum: " + sum); // Output: Sum: 8
    }
}
```

In this example, a and b are the formal parameters of the add method. When the add method is called in main, the values 5 and 3 are the actual parameters (or arguments) passed to the method.

**Parameter Passing Mechanisms: Pass by Value**

Java uses a "pass by value" mechanism for passing parameters. This means that when a method is called, a copy of the actual parameter's value is passed to the formal parameter. Any changes made to the formal parameter inside the method do not affect the original actual parameter.

- **Primitive Types**: For primitive types (e.g., int, double, boolean), the value of the variable is copied.
- **Reference Types**: For reference types (e.g., objects, arrays), the reference to the object is copied, not the object itself. This means that if the method modifies the object that the reference points to, the changes will be visible outside the method. However, if the method reassigns the reference to a new object, the original reference outside the method will not be affected.

Let's illustrate this with an example:

```java
public class ParameterPassing {

    public static void modifyPrimitive(int x) {
        x = x + 10;
        System.out.println("Inside modifyPrimitive: x = " + x); // Output: Inside modifyPrimitive: x = 20
    }

    public static void modifyObject(StringBuilder sb) {
        sb.append(" World");
        System.out.println("Inside modifyObject: sb = " + sb); // Output: Inside modifyObject: sb = Hello World
    }

    public static void reassignObject(StringBuilder sb) {
        sb = new StringBuilder("Goodbye");
        System.out.println("Inside reassignObject: sb = " + sb); // Output: Inside reassignObject: sb = Goodbye
    }

    public static void main(String[] args) {
        int num = 10;
        System.out.println("Before modifyPrimitive: num = " + num); // Output: Before modifyPrimitive: num = 10
        modifyPrimitive(num);
        System.out.println("After modifyPrimitive: num = " + num);  // Output: After modifyPrimitive: num = 10

        StringBuilder message = new StringBuilder("Hello");
        System.out.println("Before modifyObject: message = " + message); // Output: Before modifyObject: message = Hello
        modifyObject(message);
        System.out.println("After modifyObject: message = " + message);  // Output: After modifyObject: message = Hello World

        System.out.println("Before reassignObject: message = " + message); // Output: Before reassignObject: message = Hello World
        reassignObject(message);
        System.out.println("After reassignObject: message = " + message);  // Output: After reassignObject: message = Hello World
    }
}
```

In this example:

- modifyPrimitive does not change the value of num in the main method because it receives a copy of the value.
- modifyObject modifies the StringBuilder object because it receives a copy of the reference to the object.
- reassignObject does not change the message object in the main method because it reassigns the copy of the reference to a new StringBuilder object. The original message reference still points to the original "Hello World" object.

**Number of Parameters**

A method can have zero or more parameters. If a method has no parameters, the parentheses in the method declaration are empty.

```java
public class Greeter {
    public void greet() {
        System.out.println("Hello!");
    }

    public void greet(String name) {
        System.out.println("Hello, " + name + "!");
    }

    public static void main(String[] args) {
        Greeter greeter = new Greeter();
        greeter.greet();        // Output: Hello!
        greeter.greet("Alice"); // Output: Hello, Alice!
    }
}
```

In this example, the greet() method has no parameters, while the greet(String name) method has one parameter.

**Parameter Order**

The order of parameters in a method declaration is crucial. When calling the method, the actual parameters must be provided in the same order as the formal parameters.

```java
public class Point {
    private int x;
    private int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void display() {
        System.out.println("Point: (" + x + ", " + y + ")");
    }

    public static void main(String[] args) {
        Point p = new Point(10, 20); // x = 10, y = 20
        p.display(); // Output: Point: (10, 20)
    }
}
```

In this example, the Point constructor expects the x coordinate as the first parameter and the y coordinate as the second parameter. Passing the values in the wrong order would result in incorrect initialization of the Point object.

#### <a name="chapter6part2.2"></a>Chapter 6 - Part 2.2: Understanding Return Types

A return type specifies the type of data that a method returns after it has finished executing. The return type is declared in the method signature before the method name.

**Void Return Type**

If a method does not return any value, its return type is void. A void method performs some action but does not produce a result that needs to be passed back to the calling code.

```java
public class Printer {
    public void printMessage(String message) {
        System.out.println(message);
        // No return statement needed for void methods
    }

    public static void main(String[] args) {
        Printer printer = new Printer();
        printer.printMessage("This is a message."); // Output: This is a message.
    }
}
```

In this example, the printMessage method has a void return type because it simply prints a message to the console and does not return any value.

**Non-Void Return Types**

If a method returns a value, its return type must be a valid Java data type (e.g., int, double, String, boolean, or a class type). The method must include a return statement that returns a value of the specified type.

```java
public class NumberUtils {
    public int square(int num) {
        return num * num; // Returns an integer value
    }

    public boolean isEven(int num) {
        return num % 2 == 0; // Returns a boolean value
    }

    public static void main(String[] args) {
        NumberUtils utils = new NumberUtils();
        int squaredValue = utils.square(5);
        System.out.println("Square of 5: " + squaredValue); // Output: Square of 5: 25

        boolean isEven = utils.isEven(10);
        System.out.println("Is 10 even? " + isEven); // Output: Is 10 even? true
    }
}
```

In this example:

- The square method returns an int value, which is the square of the input number.
- The isEven method returns a boolean value, indicating whether the input number is even.

**Return Statement**

The return statement is used to return a value from a method. When a return statement is executed, the method terminates immediately, and the value specified in the return statement is passed back to the calling code.

- **Void Methods**: void methods can have a return statement without a value, which simply terminates the method's execution. This is often used to exit the method early based on some condition.
- **Non-Void Methods**: Non-void methods must have a return statement that returns a value of the specified type. If a non-void method does not have a return statement, or if the return statement does not return a value of the correct type, the compiler will generate an error.

```java
public class Validator {
    public boolean isValidAge(int age) {
        if (age < 0 || age > 120) {
            System.out.println("Invalid age!");
            return false; // Early exit if age is invalid
        }
        return true; // Returns true if age is valid
    }

    public static void main(String[] args) {
        Validator validator = new Validator();
        boolean isValid = validator.isValidAge(25);
        System.out.println("Is age valid? " + isValid); // Output: Is age valid? true

        isValid = validator.isValidAge(-5);
        System.out.println("Is age valid? " + isValid); // Output: Invalid age! \n Is age valid? false
    }
}
```

In this example, the isValidAge method uses a return statement to exit the method early if the age is invalid.

**Returning Objects**

Methods can also return objects. The return type in this case is the class of the object being returned.

```java
public class Rectangle {
    private int width;
    private int height;

    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }

    public int getWidth() {
        return width;
    }

    public int getHeight() {
        return height;
    }

    public Rectangle createSquare(int side) {
        return new Rectangle(side, side);
    }

    public static void main(String[] args) {
        Rectangle rect = new Rectangle(5, 10);
        Rectangle square = rect.createSquare(7);

        System.out.println("Rectangle width: " + rect.getWidth() + ", height: " + rect.getHeight()); // Output: Rectangle width: 5, height: 10
        System.out.println("Square width: " + square.getWidth() + ", height: " + square.getHeight());   // Output: Square width: 7, height: 7
    }
}
```

In this example, the createSquare method returns a new Rectangle object representing a square with the given side length.

#### <a name="chapter6part2.3"></a>Chapter 6 - Part 2.3: Practical Examples and Demonstrations

Let's consider a more complex example involving a Student class and methods that operate on student data.

```java
public class Student {
    private String name;
    private int age;
    private double gpa;

    public Student(String name, int age, double gpa) {
        this.name = name;
        this.age = age;
        this.gpa = gpa;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public double getGpa() {
        return gpa;
    }

    public boolean isHonorStudent(double honorGpaThreshold) {
        return gpa >= honorGpaThreshold;
    }

    public static void main(String[] args) {
        Student student1 = new Student("Alice", 20, 3.8);
        Student student2 = new Student("Bob", 22, 3.5);

        System.out.println(student1.getName() + " is " + student1.getAge() + " years old and has a GPA of " + student1.getGpa()); // Output: Alice is 20 years old and has a GPA of 3.8
        System.out.println(student2.getName() + " is " + student2.getAge() + " years old and has a GPA of " + student2.getGpa()); // Output: Bob is 22 years old and has a GPA of 3.5

        double honorGpaThreshold = 3.7;
        boolean isAliceHonor = student1.isHonorStudent(honorGpaThreshold);
        boolean isBobHonor = student2.isHonorStudent(honorGpaThreshold);

        System.out.println("Is " + student1.getName() + " an honor student? " + isAliceHonor); // Output: Is Alice an honor student? true
        System.out.println("Is " + student2.getName() + " an honor student? " + isBobHonor);   // Output: Is Bob an honor student? false
    }
}
```

In this example:

- The Student class has methods like getName(), getAge(), and getGpa() that return the student's name, age, and GPA, respectively.
- The isHonorStudent(double honorGpaThreshold) method takes a double parameter representing the GPA threshold for honor students and returns a boolean value indicating whether the student's GPA meets the threshold.

#### <a name="chapter6part3"></a>Chapter 6 - Part 3: Static Variables and Methods: Class-Level Members

Static variables and methods are powerful tools in Java that allow you to associate data and behavior with a class itself, rather than with individual instances of that class. This lesson will explore the concept of class-level members, their characteristics, and how they differ from instance-level members. Understanding static members is crucial for designing efficient and well-organized Java applications.

#### <a name="chapter6part3.1"></a>Chapter 6 - Part 3.1: Understanding Static Variables

Static variables, also known as class variables, are variables that belong to the class itself rather than to any specific instance of the class. This means that there is only one copy of a static variable, regardless of how many objects of the class are created. All instances of the class share the same static variable.

**Declaring Static Variables**

To declare a static variable, you use the static keyword before the variable declaration.

```java
class MyClass {
    static int count = 0; // A static variable
    int instanceVariable; // An instance variable
}
```

In this example, count is a static variable, while instanceVariable is an instance variable.

**Accessing Static Variables**

Static variables can be accessed directly using the class name, without creating an object of the class. They can also be accessed through an object of the class, but it is generally recommended to use the class name for clarity.

```java
public class StaticVariableExample {
    static int counter = 0;

    public StaticVariableExample() {
        counter++;
    }

    public static void main(String[] args) {
        System.out.println("Counter before object creation: " + StaticVariableExample.counter); // Accessing using class name

        StaticVariableExample obj1 = new StaticVariableExample();
        System.out.println("Counter after first object creation: " + StaticVariableExample.counter);

        StaticVariableExample obj2 = new StaticVariableExample();
        System.out.println("Counter after second object creation: " + StaticVariableExample.counter);

        System.out.println("Counter accessed through object: " + obj1.counter); // Accessing through object (not recommended)
    }
}
```

```
Counter before object creation: 0
Counter after first object creation: 1
Counter after second object creation: 2
Counter accessed through object: 2
```

As you can see, the counter variable is incremented each time a new object is created, and all objects share the same counter value.

**Static Variables vs. Instance Variables**


|Feature|	Static Variable|	Instance Variable|
| :-----------: | :-----------: | :-----------: |
|Ownership|	Belongs to the class|	Belongs to each instance of the class|
|Memory Allocation|	Allocated only once, when the class is loaded|	Allocated each time an object is created|
|Access|	Accessed using the class name (recommended)|	Accessed using the object reference|
|Sharing|	Shared by all instances of the class|	Each instance has its own copy|
|Lifetime|	Exists for the lifetime of the class|	Exists for the lifetime of the object|

**Example: Tracking the Number of Objects**

A common use case for static variables is to track the number of objects created from a class.

```java
class Dog {
    private static int dogCount = 0; // Static variable to track the number of dogs

    public Dog() {
        dogCount++; // Increment the count when a new Dog object is created
    }

    public static int getDogCount() {
        return dogCount;
    }

    public static void main(String[] args) {
        System.out.println("Number of dogs before creation: " + Dog.getDogCount());
        Dog dog1 = new Dog();
        Dog dog2 = new Dog();
        Dog dog3 = new Dog();
        System.out.println("Number of dogs after creation: " + Dog.getDogCount());
    }
}
```

Output:

```
Number of dogs before creation: 0
Number of dogs after creation: 3
```

**Exercise: Implementing a Unique ID Generator**

Create a class called Employee with instance variables for name and employeeId. Use a static variable to automatically assign a unique ID to each employee when they are created. The first employee should have an ID of 1, the second an ID of 2, and so on.

#### <a name="chapter6part3.2"></a>Chapter 6 - Part 3.2: Understanding Static Methods

Static methods, also known as class methods, are methods that belong to the class itself rather than to any specific instance of the class. Like static variables, static methods can be called directly using the class name, without creating an object of the class.

**Declaring Static Methods**

To declare a static method, you use the static keyword before the method declaration.

```java
class MyClass {
    static void myStaticMethod() {
        System.out.println("This is a static method.");
    }

    void myInstanceMethod() {
        System.out.println("This is an instance method.");
    }
}
```

In this example, myStaticMethod is a static method, while myInstanceMethod is an instance method.

**Calling Static Methods**

Static methods are called using the class name, followed by the dot operator (.), and the method name.

```java
public class StaticMethodExample {

    public static void displayMessage() {
        System.out.println("Hello from the static method!");
    }

    public static void main(String[] args) {
        StaticMethodExample.displayMessage(); // Calling the static method using the class name
    }
}
```

**Output**:

```
Hello from the static method!
```

**Restrictions on Static Methods**

- Static methods can only directly access static variables and other static methods of the same class.
- Static methods cannot directly access instance variables or instance methods because they are not associated with any specific object.
- The this keyword cannot be used inside a static method because this refers to the current object, and static methods are not associated with any object.

**Example: Utility Methods**

Static methods are often used to create utility methods that perform operations that are not specific to any particular object.

```java
class MathUtils {
    public static int add(int a, int b) {
        return a + b;
    }

    public static double calculateCircleArea(double radius) {
        return Math.PI * radius * radius;
    }

    public static void main(String[] args) {
        int sum = MathUtils.add(5, 3);
        System.out.println("Sum: " + sum);

        double area = MathUtils.calculateCircleArea(5.0);
        System.out.println("Circle area: " + area);
    }
}
```

**Output**:

```
Sum: 8
Circle area: 78.53981633974483
```

**Static Methods vs. Instance Methods**

|Feature	|Static Method	|Instance Method|
| :-----------: | :-----------: | :-----------: |
|Association|	Associated with the class|	Associated with an instance of the class|
|Access|	Accessed using the class name (recommended)|	Accessed using the object reference|
|Access to Members|	Can only access static members|	Can access both static and instance members|
|this Keyword|	Not available|	Available|

**Example: Converting Temperature**

```java
class TemperatureConverter {
    public static double celsiusToFahrenheit(double celsius) {
        return (celsius * 9 / 5) + 32;
    }

    public static double fahrenheitToCelsius(double fahrenheit) {
        return (fahrenheit - 32) * 5 / 9;
    }

    public static void main(String[] args) {
        double celsius = 25.0;
        double fahrenheit = TemperatureConverter.celsiusToFahrenheit(celsius);
        System.out.println(celsius + " Celsius is equal to " + fahrenheit + " Fahrenheit");

        fahrenheit = 77.0;
        celsius = TemperatureConverter.fahrenheitToCelsius(fahrenheit);
        System.out.println(fahrenheit + " Fahrenheit is equal to " + celsius + " Celsius");
    }
}
```

**Output:**

```
25.0 Celsius is equal to 77.0 Fahrenheit
77.0 Fahrenheit is equal to 25.0 Celsius
```

**Exercise: Creating a String Utility Class**

Create a class called StringUtils with static methods for the following operations:

- reverseString(String str): Reverses the given string.
- isPalindrome(String str): Checks if the given string is a palindrome (reads the same forwards and backward).
- countVowels(String str): Counts the number of vowels (a, e, i, o, u) in the given string.

#### <a name="chapter6part3.3"></a>Chapter 6 - Part 3.3: Static Blocks

Static blocks are blocks of code that are executed only once when the class is first loaded into memory. They are used to initialize static variables or perform any other static initialization tasks.

**Declaring Static Blocks**

To declare a static block, you use the static keyword followed by a block of code enclosed in curly braces {}.

```java
class MyClass {
    static int staticVariable;

    static {
        // Static initialization code here
        staticVariable = 10;
        System.out.println("Static block executed.");
    }
}
```

**Execution of Static Blocks**

Static blocks are executed in the order they appear in the class definition. They are executed before any objects of the class are created and before the main method is executed.

```java
public class StaticBlockExample {
    static int staticVariable;

    static {
        System.out.println("Static block 1 executed.");
        staticVariable = 10;
    }

    static {
        System.out.println("Static block 2 executed.");
        staticVariable = staticVariable * 2;
    }

    public static void main(String[] args) {
        System.out.println("Main method executed.");
        System.out.println("Static variable: " + staticVariable);
    }
}
```

Output:

```
Static block 1 executed.
Static block 2 executed.
Main method executed.
Static variable: 20
```

**Use Cases for Static Blocks**

- Initializing static variables that require complex logic.
- Loading resources or configuration files that are needed by the class.
- Performing any one-time setup tasks for the class.

**Example: Loading Configuration**

```java
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

class Configuration {
    static Properties properties = new Properties();

    static {
        try (FileInputStream input = new FileInputStream("config.properties")) {
            properties.load(input);
            System.out.println("Configuration loaded from config.properties");
        } catch (IOException e) {
            System.err.println("Error loading configuration: " + e.getMessage());
        }
    }

    public static String getProperty(String key) {
        return properties.getProperty(key);
    }

    public static void main(String[] args) {
        String databaseUrl = Configuration.getProperty("database.url");
        System.out.println("Database URL: " + databaseUrl);
    }
}
```

Create a file named config.properties with the following content:

```
database.url=jdbc:mysql://localhost:3306/mydb
```

**Output:**

```
Configuration loaded from config.properties
Database URL: jdbc:mysql://localhost:3306/mydb
```

**Exercise: Initializing a Lookup Table**

Create a class called CountryCodes that uses a static block to initialize a static HashMap containing country codes and their corresponding names. Provide a static method to retrieve the country name for a given country code.

#### <a name="chapter6part3.4"></a>Chapter 6 - Part 3.4: Real-World Applications

Static variables and methods are used extensively in Java libraries and frameworks. Here are a few examples:

- java.lang.Math Class: The Math class provides static methods for performing mathematical operations, such as Math.sqrt(), Math.sin(), and Math.cos(). These methods are not associated with any specific object and can be called directly using the class name.
- Singleton Pattern: Static variables and methods are often used to implement the Singleton design pattern, which ensures that only one instance of a class is created.
- Logger Classes: Logger classes often use static variables and methods to provide a global logging facility for an application.

#### <a name="chapter6part4"></a>Chapter 6 - Part 4: Understanding Access Modifiers: public, private, protected, default

Access modifiers are a fundamental aspect of object-oriented programming in Java. They control the visibility and accessibility of classes, methods, and variables, playing a crucial role in encapsulation and information hiding. Understanding access modifiers is essential for writing robust, maintainable, and secure Java code. They allow you to define clear boundaries between different parts of your program, preventing unintended modifications and promoting modularity. This lesson will delve into the four access modifiers available in Java: public, private, protected, and the default (package-private) access level. We'll explore their meanings, usage scenarios, and implications for class design.

#### <a name="chapter6part4.1"></a>Chapter 6 - Part 4.1: Understanding Access Modifiers

Access modifiers in Java determine the visibility of class members (fields and methods) and classes themselves. They are keywords placed before the declaration of a member or class, specifying the level of access that other parts of the program have to that member or class. Java provides four access modifiers:

- ```public```: Accessible from anywhere.
- ```private```: Accessible only within the declaring class.
- ```protected```: Accessible within the declaring class, within the same package, and by subclasses (even in different packages).
- Default (no modifier): Accessible within the same package. This is also known as package-private access.

Let's examine each of these in detail.

**```public``` Access Modifier**

The public access modifier grants the widest level of accessibility. A public class, method, or variable can be accessed from any other class, regardless of its package. This is useful for defining the public interface of a class, which is the set of methods and variables that are intended to be used by other classes.

```java
package com.example;

public class PublicClass { // Accessible from any class
    public int publicVariable; // Accessible from any class
    public void publicMethod() { // Accessible from any class
        System.out.println("This is a public method.");
    }
}

package com.example.another;

import com.example.PublicClass;

public class AnotherClass {
    public void accessPublicMembers() {
        PublicClass obj = new PublicClass();
        obj.publicVariable = 10; // Accessing public variable
        obj.publicMethod(); // Accessing public method
    }
}
```

In this example, PublicClass, publicVariable, and publicMethod are all declared as public. Therefore, they can be accessed from AnotherClass in a different package.

**```private``` Access Modifier**

The private access modifier provides the most restrictive level of accessibility. A private member (method or variable) can only be accessed from within the class in which it is declared. This is a key aspect of encapsulation, as it allows you to hide the internal implementation details of a class and prevent other classes from directly manipulating its data.

```java
package com.example;

public class PrivateClass {
    private int privateVariable; // Accessible only within PrivateClass
    private void privateMethod() { // Accessible only within PrivateClass
        System.out.println("This is a private method.");
    }

    public void accessPrivateMembers() {
        privateVariable = 20; // Accessing private variable within the class
        privateMethod(); // Accessing private method within the class
    }
}

package com.example.another;

import com.example.PrivateClass;

public class AnotherClass {
    public void tryAccessPrivateMembers() {
        PrivateClass obj = new PrivateClass();
        // The following lines would cause compilation errors:
        // obj.privateVariable = 30; // Cannot access private variable
        // obj.privateMethod(); // Cannot access private method
    }
}
```

In this example, privateVariable and privateMethod are declared as private. Therefore, they cannot be accessed from AnotherClass, even though it's in a different package. Attempting to do so will result in a compilation error.

**```protected``` Access Modifier**

The protected access modifier provides a level of accessibility that is intermediate between public and private. A protected member can be accessed from within the same package as the declaring class, as well as from subclasses of the declaring class, even if the subclasses are in different packages.

```java
package com.example;

public class ProtectedClass {
    protected int protectedVariable; // Accessible within the package and by subclasses
    protected void protectedMethod() { // Accessible within the package and by subclasses
        System.out.println("This is a protected method.");
    }
}

package com.example.another;

import com.example.ProtectedClass;

public class Subclass extends ProtectedClass {
    public void accessProtectedMembers() {
        protectedVariable = 40; // Accessing protected variable from a subclass
        protectedMethod(); // Accessing protected method from a subclass
    }
}

package com.example;

public class AnotherClassInSamePackage {
    public void accessProtectedMembers() {
        ProtectedClass obj = new ProtectedClass();
        obj.protectedVariable = 50; // Accessing protected variable from within the same package
        obj.protectedMethod(); // Accessing protected method from within the same package
    }
}
```

In this example, protectedVariable and protectedMethod are declared as protected. Subclass in a different package can access these members because it is a subclass of ProtectedClass. AnotherClassInSamePackage can also access these members because it is in the same package as ProtectedClass.

**Default (Package-Private) Access Modifier**

If no access modifier is specified, the member or class has default (package-private) access. This means that it can only be accessed from within the same package. It is more restrictive than protected (as it doesn't allow access from subclasses in different packages) but less restrictive than private.

```java
package com.example;

class DefaultClass { // Accessible only within the package
    int defaultVariable; // Accessible only within the package
    void defaultMethod() { // Accessible only within the package
        System.out.println("This is a default method.");
    }
}

package com.example.another;

import com.example.DefaultClass; // Compilation error: The type com.example.DefaultClass is not visible

public class AnotherClass {
    public void tryAccessDefaultMembers() {
        // The following lines would cause compilation errors:
        // DefaultClass obj = new DefaultClass(); // Cannot access DefaultClass
        // obj.defaultVariable = 60; // Cannot access default variable
        // obj.defaultMethod(); // Cannot access default method
    }
}

package com.example;

public class AnotherClassInSamePackage {
    public void accessDefaultMembers() {
        DefaultClass obj = new DefaultClass();
        obj.defaultVariable = 70; // Accessing default variable from within the same package
        obj.defaultMethod(); // Accessing default method from within the same package
    }
}
```

In this example, DefaultClass, defaultVariable, and defaultMethod have default access. Therefore, they can be accessed from AnotherClassInSamePackage because it is in the same package as DefaultClass. However, they cannot be accessed from AnotherClass because it is in a different package.

#### <a name="chapter6part4.2"></a>Chapter 6 - Part 4.2: Access Levels: A Summary


|Modifier	|Class	|Package	|Subclass	|World|
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
|public	   |Yes	|Yes	|Yes	|Yes|
|protected	|Yes	|Yes	|Yes	|No|
|Default	|Yes	|Yes	|No	|No|
|private	|Yes	|No	|No	|No|

#### <a name="chapter6part4.3"></a>Chapter 6 - Part 4.3: Practical Examples and Demonstrations

Let's consider a scenario involving a BankAccount class to illustrate the use of access modifiers.

```java
package com.example.bank;

public class BankAccount {
    private String accountNumber;
    protected double balance;
    public String accountHolderName;

    public BankAccount(String accountNumber, String accountHolderName, double initialBalance) {
        this.accountNumber = accountNumber;
        this.accountHolderName = accountHolderName;
        this.balance = initialBalance;
    }

    public void deposit(double amount) {
        balance += amount;
    }

    public void withdraw(double amount) {
        if (amount <= balance) {
            balance -= amount;
        } else {
            System.out.println("Insufficient funds.");
        }
    }

    private String getAccountNumber() {
        return accountNumber;
    }

    protected double getBalance() {
        return balance;
    }
}
```

In this example:

- accountNumber is private: Only the BankAccount class can directly access or modify the account number. This ensures that the account number cannot be changed from outside the class, maintaining data integrity.
- balance is protected: The balance can be accessed and modified by classes within the same package (e.g., other bank-related classes) and by subclasses (e.g., a SavingsAccount class in a different package). This allows for controlled access to the balance for - ------ specific purposes, such as calculating interest in a subclass.
- accountHolderName is public: The accountHolderName can be accessed and modified from anywhere. This might be appropriate if the account holder's name needs to be displayed in various parts of the application.
- getAccountNumber() is private: This method is only used internally within the BankAccount class and is not exposed to other classes. This is a good practice for hiding implementation details.
- getBalance() is protected: This method can be accessed by classes within the same package and by subclasses. This allows subclasses to access the balance for specific purposes, such as calculating interest.

Now, let's create a SavingsAccount class that extends BankAccount.

```java
package com.example.bank.accounts;

import com.example.bank.BankAccount;

public class SavingsAccount extends BankAccount {
    private double interestRate;

    public SavingsAccount(String accountNumber, String accountHolderName, double initialBalance, double interestRate) {
        super(accountNumber, accountHolderName, initialBalance);
        this.interestRate = interestRate;
    }

    public void applyInterest() {
        // balance is protected, so we can access it directly in the subclass
        balance += balance * interestRate;
    }

    public void displayBalance() {
        // getBalance() is protected, so we can access it directly in the subclass
        System.out.println("Current balance: " + getBalance());
    }
}
```

In this example, the SavingsAccount class extends BankAccount. Because balance and getBalance() are protected, the SavingsAccount class can access them directly. The accountNumber is private in the BankAccount class, so the SavingsAccount class cannot access it directly.

#### <a name="chapter6part5"></a>Chapter 6 - Part 5: Introduction to Inheritance: Creating Hierarchies of Classes

Inheritance is a fundamental concept in object-oriented programming (OOP) that allows you to create new classes based on existing ones. This promotes code reuse, reduces redundancy, and establishes a clear hierarchy among classes. By inheriting from a parent class, a child class gains access to the parent's attributes and methods, enabling you to build upon existing functionality and create more specialized classes. This lesson will delve into the core principles of inheritance, focusing on how to create class hierarchies using the extends keyword, override methods to customize behavior, and utilize the super keyword to access parent class members.

#### <a name="chapter6part5.1"></a>Chapter 6 - Part 5.1: Object Class

**Object Class in Java**

The **Object class** is the parent class of all the classes in java by default. In other words, it is the topmost class of java.

The Object class is beneficial if you want to refer any object whose type you don't know. Notice that parent class reference variable can refer the child class object, know as upcasting.

<br>

<div align="center"><img src="img/objectclass2-w612-h314.png" width=612 height=314><br><sub>Fig 30 - Class Object Inheritance in Java - (<a href='https://www.javatpoint.com/object-class'>Work by  java T Point</a>) </sub></div>

<br>

Let's take an example, there is getObject() method that returns an object but it can be of any type like Employee,Student etc, we can use Object class reference to refer that object. For example:

```java

Object obj=getObject();//we don't know what object will be returned from this method  

```

The Object class provides some common behaviors to all the objects such as object can be compared, object can be cloned, object can be notified etc. 


<br>

<div align="center"><img src="img/objectclass1-w696-h476.png" width=696 height=476><br><sub>Fig 31 - Class Object Methods in Java - (<a href='https://www.javatpoint.com/object-class'>Work by  java T Point</a>) </sub></div>

<br>

**Methods of Object class**

| Method                                                                      | Description     |
| :--------------------------------------------------------------------------:| :--------------:|
| public final Class getClass()                                               | returns the Class class object of this object. The Class class can further be used to get the metadata of this class.       |
| public int hashCode()                                                       | returns the hashcode number for this object. | 
| public boolean equals(Object obj)                                           | compares the given object to this object.             |
| protected Object clone() throws CloneNotSupportedException                  | creates and returns the exact copy (clone) of this object.       |
| public String toString()                                                    |returns the string representation of this object.       |
| public final void notify()                                                  | wakes up single thread, waiting on this object's monitor.       |
| public final void notifyAll()                                               | wakes up all the threads, waiting on this object's monitor.       |
| public final void wait(long timeout)throws InterruptedException             | causes the current thread to wait for the specified milliseconds, until another thread notifies (invokes notify() or notifyAll() method).       |
| public final void wait(long timeout,int nanos)throws InterruptedException   | causes the current thread to wait for the specified milliseconds and nanoseconds, until another thread notifies (invokes notify() or notifyAll() method).       |
| public final void wait()throws InterruptedException                         | causes the current thread to wait, until another thread notifies (invokes notify() or notifyAll() method).       |
| protected void finalize()throws Throwable                                   | is invoked by the garbage collector before object is being garbage collected.       |


Now, we will use the method ```toString()``` that will be able to display the name and attributes of the Product.

**Class Product**

```java

public class Product {

	public String name;
	public double price;
	public int quantity;

	public double totalValueInStock() {
		return price * quantity;
	}

	public void addProducts(int quantity) {
		this.quantity += quantity;
	}

	public void removeProducts(int quantity) {
		this.quantity -= quantity;
	}
	
	public String toString() {
		return name
		+ ", $ "
		+ String.format("%.2f", price)
		+ ", "
		+ quantity
		+ " units, Total: $ "
		+ String.format("%.2f", totalValueInStock());
	}

}

```

**Program**

```java

import java.util.Locale;
import java.util.Scanner;

public class Program {
	
	public static void main(String[] args) {
		
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		Product product = new Product();
		System.out.println("Enter product data: ");
		System.out.print("Name: ");
		product.name = sc.nextLine();
		System.out.print("Price: ");
		product.price = sc.nextDouble();
		System.out.print("Quantity in stock: ");
		product.quantity = sc.nextInt();
		
		System.out.println();
		System.out.println("Product data: " + product);
		
		System.out.println();
		System.out.print("Enter the number of products to be added in stock: ");
		int quantity = sc.nextInt();
		product.addProducts(quantity);
		
		System.out.println();
		System.out.println("Updated data: " + product);
		
		System.out.println();
		System.out.print("Enter the number of products to be removed from stock: ");
		quantity = sc.nextInt();
		product.removeProducts(quantity);
		
		System.out.println();
		System.out.println("Updated data: " + product);
		
		sc.close();
	}
}

```

#### <a name="chapter6part5.2"></a>Chapter 6 - Part 5.2: Understanding Inheritance

Inheritance is a mechanism where a new class (called a subclass or child class) acquires the properties and behaviors of an existing class (called a superclass or parent class). The subclass inherits the attributes (fields) and methods of the superclass. This allows you to create a hierarchy of classes, where subclasses represent more specialized versions of their superclasses.

**Key Benefits of Inheritance**:

- **Code Reusability**: Avoid writing the same code multiple times. Subclasses inherit the code from their superclass, reducing redundancy.
- **Extensibility**: Easily extend the functionality of existing classes by adding new attributes and methods in subclasses.
- **Organization**: Create a clear hierarchy of classes, making your code more organized and easier to understand.
- **Polymorphism**: (Covered in a later module) Inheritance is a prerequisite for polymorphism, which allows you to treat objects of different classes in a uniform way.

**Real-World Examples:**

- **Vehicles**: Consider a Vehicle class with attributes like speed, color, and methods like startEngine() and stopEngine(). You can create subclasses like Car, Truck, and Motorcycle that inherit these attributes and methods. Each subclass can then add its own specific attributes and methods, such as numberOfDoors for Car or cargoCapacity for Truck.

- **Animals**: An Animal class can have attributes like name, age, and methods like eat() and sleep(). Subclasses like Dog, Cat, and Bird can inherit these and add their own specific behaviors, such as bark() for Dog or fly() for Bird.

**Hypothetical Scenario:**

Imagine you're developing a game. You have a base class called GameObject with attributes like x, y (coordinates), and methods like draw() and update(). You can create subclasses like Player, Enemy, and Projectile that inherit from GameObject. Each subclass can then implement its own specific draw() and update() methods to handle its unique behavior in the game.

#### <a name="chapter6part5.3"></a>Chapter 6 - Part 5.3: The extends Keyword

In Java, the extends keyword is used to establish an inheritance relationship between two classes. The syntax is as follows:

```java
class Subclass extends Superclass {
    // Subclass members (attributes and methods)
}
```

This declares that Subclass inherits from Superclass. The Subclass automatically gains all non-private members (attributes and methods) of the Superclass.

Example:

Let's create a simple example with a Animal class and a Dog subclass:

```java
// Superclass (Parent Class)
class Animal {
    String name;

    public Animal(String name) {
        this.name = name;
    }

    public void eat() {
        System.out.println(name + " is eating.");
    }

    public void sleep() {
        System.out.println(name + " is sleeping.");
    }
}

// Subclass (Child Class) inheriting from Animal
class Dog extends Animal {
    String breed;

    public Dog(String name, String breed) {
        super(name); // Call the constructor of the superclass
        this.breed = breed;
    }

    public void bark() {
        System.out.println("Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy", "Golden Retriever");
        myDog.eat();   // Inherited from Animal
        myDog.sleep(); // Inherited from Animal
        myDog.bark();  // Specific to Dog
        System.out.println(myDog.name); // Accessing inherited attribute
    }
}
```

**Explanation**:

- The Dog class extends the Animal class, meaning it inherits the name, eat(), and sleep() members.
- The Dog class has its own attribute, breed, and its own method, bark().
- The super(name) call in the Dog constructor calls the constructor of the Animal class, initializing the name attribute. This is crucial for proper initialization of inherited attributes.

#### <a name="chapter6part5.4"></a>Chapter 6 - Part 5.4: Method Overriding

Method overriding allows a subclass to provide a specific implementation for a method that is already defined in its superclass. This enables you to customize the behavior of inherited methods in the subclass.

**Rules for Method Overriding:**

- The method in the subclass must have the same name, return type, and parameter list as the method in the superclass.
- The access modifier of the overriding method in the subclass must be the same or more accessible than the method in the superclass (e.g., you can override a protected method with a public method, but not with a private method).
- The @Override annotation is optional but highly recommended. It tells the compiler that you intend to override a method, and it will generate an error if the method does not actually override a method in the superclass.

**Example**:

Let's modify the Animal and Dog classes to demonstrate method overriding:

```java
class Animal {
    String name;

    public Animal(String name) {
        this.name = name;
    }

    public void makeSound() {
        System.out.println("Generic animal sound");
    }

    public void eat() {
        System.out.println(name + " is eating.");
    }

    public void sleep() {
        System.out.println(name + " is sleeping.");
    }
}

class Dog extends Animal {
    String breed;

    public Dog(String name, String breed) {
        super(name);
        this.breed = breed;
    }

    @Override
    public void makeSound() {
        System.out.println("Woof!"); // Overriding the makeSound() method
    }

    public void bark() {
        System.out.println("Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal("Generic Animal");
        Dog myDog = new Dog("Buddy", "Golden Retriever");

        myAnimal.makeSound(); // Output: Generic animal sound
        myDog.makeSound();    // Output: Woof! (Overridden method)
    }
}
```

**Explanation**:

- The Dog class overrides the makeSound() method from the Animal class.
- When myAnimal.makeSound() is called, the makeSound() method in the Animal class is executed.
- When myDog.makeSound() is called, the makeSound() method in the Dog class is executed, demonstrating method overriding.

#### <a name="chapter6part5.5"></a>Chapter 6 - Part 5.5: The super Keyword

The super keyword is used to access members (attributes and methods) of the superclass from within the subclass. It has two main uses:

- **Calling the Superclass Constructor**: As seen in the previous examples, super(arguments) is used to call the constructor of the superclass. This is essential for initializing inherited attributes. It must be the first statement in the subclass constructor.

- **Accessing Superclass Members**: super.member is used to access a specific attribute or method of the superclass. This is useful when you want to use the superclass's implementation of a method in addition to the subclass's implementation.

**Example**:

Let's extend the previous example to demonstrate both uses of super:

```java
class Animal {
    String name;

    public Animal(String name) {
        this.name = name;
        System.out.println("Animal constructor called");
    }

    public void makeSound() {
        System.out.println("Generic animal sound");
    }

    public void eat() {
        System.out.println(name + " is eating.");
    }

    public void sleep() {
        System.out.println(name + " is sleeping.");
    }
}

class Dog extends Animal {
    String breed;

    public Dog(String name, String breed) {
        super(name); // Calling the Animal constructor
        System.out.println("Dog constructor called");
        this.breed = breed;
    }

    @Override
    public void makeSound() {
        super.makeSound(); // Calling the Animal's makeSound() method
        System.out.println("Woof!"); // Adding Dog-specific sound
    }

    public void displayBreed() {
        System.out.println("Breed: " + breed);
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy", "Golden Retriever");
        myDog.makeSound();
        myDog.displayBreed();
    }
}
```

**Explanation**:

- In the Dog constructor, super(name) calls the Animal constructor, initializing the name attribute. The output will show "Animal constructor called" before "Dog constructor called".

- In the Dog's makeSound() method, super.makeSound() calls the makeSound() method of the Animal class, which prints "Generic animal sound". Then, the Dog's specific sound "Woof!" is printed.

#### <a name="chapter6part6"></a>Chapter 6 - Part 6: The `extends` Keyword: Inheriting from a Parent Class

Inheritance is a cornerstone of object-oriented programming, allowing you to create new classes based on existing ones. This promotes code reuse, reduces redundancy, and establishes a clear hierarchy among your classes. The extends keyword in Java is the mechanism for implementing inheritance, enabling a class to inherit the properties and behaviors of another class. Understanding how to effectively use extends is crucial for building robust and maintainable Java applications.

#### <a name="chapter6part6.1"></a>Chapter 6 - Part 6.1: Understanding the extends Keyword

The extends keyword in Java is used to create a new class that is a subclass (also known as a derived class or child class) of an existing class, called the superclass (also known as a base class or parent class). The subclass inherits the non-private members (fields and methods) of the superclass. This means the subclass automatically has those members as if they were declared within the subclass itself.

**Syntax**

The basic syntax for using extends is:

```java
class SubclassName extends SuperclassName {
    // Class body with additional fields and methods,
    // or overridden methods from the superclass
}
```

- ```SubclassName```: The name of the new class you are creating.
- ```SuperclassName```: The name of the existing class you are inheriting from.
- The curly braces {} enclose the body of the subclass, where you can define new fields and methods, or override existing methods from the superclass.

**Example: A Simple Inheritance Scenario**

Let's consider a simple example with Animal and Dog classes:

```java
// Superclass (Parent Class)
class Animal {
    String name;

    public Animal(String name) {
        this.name = name;
    }

    public void eat() {
        System.out.println(name + " is eating.");
    }

    public void sleep() {
        System.out.println(name + " is sleeping.");
    }
}

// Subclass (Child Class) inheriting from Animal
class Dog extends Animal {
    String breed;

    public Dog(String name, String breed) {
        super(name); // Call the constructor of the Animal class
        this.breed = breed;
    }

    public void bark() {
        System.out.println("Woof! Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy", "Golden Retriever");
        myDog.eat();   // Inherited from Animal
        myDog.sleep(); // Inherited from Animal
        myDog.bark();  // Defined in Dog
    }
}
```

In this example:

- Animal is the superclass, with a name field, an eat() method, and a sleep() method.
- Dog is the subclass, inheriting from Animal. It adds its own breed field and bark() method.
- The Dog constructor uses super(name) to call the Animal constructor, initializing the inherited name field.
- In the Main class, we create a Dog object and call methods inherited from Animal (eat() and sleep()) as well as the Dog-specific method (bark()).

**The super Keyword**

The super keyword is used in a subclass to refer to the superclass. It has two primary uses:

- **Calling the Superclass Constructor**: As seen in the Dog constructor, super(name) calls the constructor of the Animal class. This is necessary to initialize the inherited fields. If a subclass constructor does not explicitly call a superclass constructor, Java automatically inserts a call to the superclass's no-argument constructor (super()). If the superclass does not have a no-argument constructor, you must explicitly call one of the superclass's constructors using super().

- **Accessing Superclass Members**: super can also be used to access fields and methods of the superclass that have been hidden or overridden in the subclass. We will explore method overriding in the next lesson.

**Inheritance and Constructors**

Constructors are not inherited. However, as mentioned above, the subclass constructor must call a superclass constructor, either explicitly using super() or implicitly (if the superclass has a no-argument constructor). If the superclass only defines parameterized constructors, the subclass must explicitly call one of them using super(arguments).

**Single Inheritance**

Java supports single inheritance, meaning a class can only inherit from one direct superclass. This is enforced by the extends keyword; you can only specify one class after extends. This restriction helps to avoid the complexities and ambiguities associated with multiple inheritance (where a class inherits from multiple superclasses).

**Example: Inheritance with Multiple Levels**

Inheritance can be multi-level. For example:

```java
// Superclass
class Animal {
    String name;

    public Animal(String name) {
        this.name = name;
    }

    public void eat() {
        System.out.println(name + " is eating.");
    }
}

// Subclass of Animal
class Mammal extends Animal {
    public Mammal(String name) {
        super(name);
    }

    public void giveBirth() {
        System.out.println(name + " is giving birth to live young.");
    }
}

// Subclass of Mammal
class Dog extends Mammal {
    String breed;

    public Dog(String name, String breed) {
        super(name);
        this.breed = breed;
    }

    public void bark() {
        System.out.println("Woof! Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy", "Golden Retriever");
        myDog.eat();        // Inherited from Animal
        myDog.giveBirth();  // Inherited from Mammal
        myDog.bark();       // Defined in Dog
    }
}
```

Here, Dog inherits from Mammal, which in turn inherits from Animal. Dog inherits members from both Mammal and Animal.

**```protected``` Access Modifier and Inheritance**

The protected access modifier plays a significant role in inheritance. Members declared as protected in a superclass are accessible to:

- All classes within the same package.
- All subclasses, regardless of the package they are in.

This provides a level of access that is more restrictive than public (accessible everywhere) but less restrictive than private (accessible only within the class itself).

```java
// Superclass
package com.example;

class Animal {
    protected String name; // Accessible to subclasses and classes in the same package

    public Animal(String name) {
        this.name = name;
    }

    protected void eat() { // Accessible to subclasses and classes in the same package
        System.out.println(name + " is eating.");
    }
}

// Subclass in a different package
package com.example.pets;

import com.example.Animal;

class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }

    public void displayAnimalName() {
        System.out.println("The animal's name is: " + name); // Accessing protected member
        eat(); // Accessing protected method
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy");
        myDog.displayAnimalName();
    }
}
```

In this example, even though Dog is in a different package, it can access the protected members (name and eat()) of the Animal class.

**The Object Class**

In Java, every class implicitly inherits from the Object class. If you don't explicitly use the extends keyword, your class still inherits from Object. The Object class provides fundamental methods like equals(), hashCode(), and toString(), which can be overridden in your classes to provide custom behavior.

#### <a name="chapter6part6.2"></a>Chapter 6 - Part 6.2: Practical Examples and Demonstrations

Let's explore some more practical examples to solidify your understanding of inheritance.

**Example 1: Shapes**

```java
// Superclass
class Shape {
    private String color;

    public Shape(String color) {
        this.color = color;
    }

    public String getColor() {
        return color;
    }

    public double getArea() {
        return 0.0; // Default implementation
    }
}

// Subclass: Circle
class Circle extends Shape {
    private double radius;

    public Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }

    public double getRadius() {
        return radius;
    }

    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
}

// Subclass: Rectangle
class Rectangle extends Shape {
    private double width;
    private double height;

    public Rectangle(String color, double width, double height) {
        super(color);
        this.width = width;
        this.height = height;
    }

    public double getWidth() {
        return width;
    }

    public double getHeight() {
        return height;
    }

    @Override
    public double getArea() {
        return width * height;
    }
}

public class Main {
    public static void main(String[] args) {
        Circle myCircle = new Circle("Red", 5.0);
        Rectangle myRectangle = new Rectangle("Blue", 4.0, 6.0);

        System.out.println("Circle Area: " + myCircle.getArea());
        System.out.println("Rectangle Area: " + myRectangle.getArea());
    }
}
```

In this example:

- Shape is the superclass, defining a common color attribute and a default getArea() method.
- Circle and Rectangle are subclasses that inherit from Shape and provide their own implementations of getArea() based on their specific properties (radius, width, and height).
- The @Override annotation indicates that the getArea() method is overriding a method from the superclass (we will discuss method overriding in detail in the next lesson).

**Example 2: Vehicles**

```java
// Superclass
class Vehicle {
    private String modelName;
    private String brand;

    public Vehicle(String modelName, String brand) {
        this.modelName = modelName;
        this.brand = brand;
    }

    public String getModelName() {
        return modelName;
    }

     public String getBrand() {
        return brand;
    }

    public void startEngine() {
        System.out.println("Engine started.");
    }
}

// Subclass: Car
class Car extends Vehicle {
    private int numberOfDoors;

    public Car(String modelName, String brand, int numberOfDoors) {
        super(modelName, brand);
        this.numberOfDoors = numberOfDoors;
    }

    public int getNumberOfDoors() {
        return numberOfDoors;
    }

    public void drive() {
        System.out.println("Driving the car.");
    }
}

// Subclass: Motorcycle
class Motorcycle extends Vehicle {
    private boolean hasSidecar;

    public Motorcycle(String modelName, String brand, boolean hasSidecar) {
        super(modelName, brand);
        this.hasSidecar = hasSidecar;
    }

    public boolean hasSidecar() {
        return hasSidecar;
    }

    public void wheelie() {
        System.out.println("Performing a wheelie!");
    }
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car("Sedan", "Toyota", 4);
        Motorcycle myMotorcycle = new Motorcycle("Sportbike", "Honda", false);

        myCar.startEngine();
        myCar.drive();

        myMotorcycle.startEngine();
        myMotorcycle.wheelie();
    }
}
```

In this example:

- Vehicle is the superclass, defining common attributes like modelName and brand, and a startEngine() method.
- Car and Motorcycle are subclasses that inherit from Vehicle and add their own specific attributes (e.g., numberOfDoors for Car, hasSidecar for Motorcycle) and methods (e.g., drive() for Car, wheelie() for Motorcycle).

#### <a name="chapter6part7"></a>Chapter 6 - Part 7: Method Overriding: Changing Inherited Behavior

Method overriding is a cornerstone of object-oriented programming, allowing subclasses to provide specific implementations of methods that are already defined in their parent classes. This capability is crucial for achieving polymorphism and creating flexible, extensible software systems. By understanding method overriding, you can design classes that adapt and specialize inherited behavior to meet specific requirements, leading to more maintainable and reusable code. This lesson will delve into the mechanics of method overriding, its benefits, and how to use it effectively in Java.

#### <a name="chapter6part7.1"></a>Chapter 6 - Part 7.1: Understanding Method Overriding

Method overriding occurs when a subclass provides a different implementation for a method that is already defined in its superclass. The overriding method in the subclass must have the same method signature as the method in the superclass: the same name, the same parameters (including the order and type), and the same return type.

**Key Principles of Method Overriding**

- **Same Method Signature**: The overriding method must have the exact same name, parameters, and return type as the overridden method in the superclass. This ensures that the subclass method can be used wherever the superclass method is expected.
- **Access Modifiers**: The access modifier of the overriding method in the subclass cannot be more restrictive than the access modifier of the overridden method in the superclass. For example, if the superclass method is protected, the overriding method can be protected or public, but not private. It can, however, be less restrictive.
- **```@Override``` Annotation**: While not strictly required, it is highly recommended to use the @Override annotation when overriding a method. This annotation tells the compiler that you intend to override a method, and the compiler will generate an error if the method does not actually override a method in the superclass. This helps to catch errors early and ensures that your code is doing what you intend.
- **Inheritance Requirement**: Method overriding can only occur in the context of inheritance. The subclass must inherit from the superclass in order to override its methods.
- **Return Type Covariance**: In Java 5 and later, overriding methods can have covariant return types. This means that the return type of the overriding method can be a subclass of the return type of the overridden method.

**Example: Basic Method Overriding**

Consider a simple example with a Vehicle class and a Car class that extends Vehicle.

```java
class Vehicle {
    public void startEngine() {
        System.out.println("Generic vehicle engine starting.");
    }

    public String getDescription() {
        return "Generic vehicle";
    }
}

class Car extends Vehicle {
    @Override
    public void startEngine() {
        System.out.println("Car engine starting.");
    }

    @Override
    public String getDescription() {
        return "Car";
    }
}

public class Main {
    public static void main(String[] args) {
        Vehicle vehicle = new Vehicle();
        Car car = new Car();

        vehicle.startEngine(); // Output: Generic vehicle engine starting.
        System.out.println(vehicle.getDescription()); // Output: Generic vehicle

        car.startEngine(); // Output: Car engine starting.
        System.out.println(car.getDescription()); // Output: Car
    }
}
```

In this example:

- The Car class extends the Vehicle class.
- The startEngine() and getDescription() methods are overridden in the Car class to provide a car-specific implementation.
- The @Override annotation is used to indicate that these methods are intended to override methods in the superclass.
- When startEngine() is called on a Car object, the Car's implementation is executed, not the Vehicle's.

**Example: Access Modifiers and Overriding**

```java
class Animal {
    protected void makeSound() {
        System.out.println("Generic animal sound");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() { // Can be protected or public, but not private
        System.out.println("Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal();
        Dog dog = new Dog();

        animal.makeSound(); // Output: Generic animal sound
        dog.makeSound(); // Output: Woof!
    }
}
```

In this example, the makeSound() method in the Animal class is protected. The overriding method in the Dog class can be protected or public, but not private. If you try to make it private, you will get a compile-time error.

**Example: Return Type Covariance**

```java
class Food {
    public String getName() {
        return "Generic Food";
    }
}

class Fruit extends Food {
    @Override
    public String getName() {
        return "Generic Fruit";
    }
}

class Apple extends Fruit {
    @Override
    public String getName() {
        return "Apple";
    }
}

class Tree {
    public Food produce() {
        return new Food();
    }
}

class AppleTree extends Tree {
    @Override
    public Apple produce() {
        return new Apple();
    }
}

public class Main {
    public static void main(String[] args) {
        Tree tree = new Tree();
        AppleTree appleTree = new AppleTree();

        Food food = tree.produce();
        Apple apple = appleTree.produce();

        System.out.println(food.getName()); // Output: Generic Food
        System.out.println(apple.getName()); // Output: Apple
    }
}
```

In this example:

- The produce() method in the Tree class returns a Food object.
- The produce() method in the AppleTree class overrides the produce() method in the Tree class and returns an Apple object, which is a subclass of Food.
- This is an example of return type covariance, where the return type of the overriding method is a subclass of the return type of the overridden method.

#### <a name="chapter6part7.2"></a>Chapter 6 - Part 7.2: The super Keyword and Method Overriding

The super keyword allows you to access members (methods and fields) of the superclass from within the subclass. In the context of method overriding, super is often used to call the overridden method in the superclass from within the overriding method in the subclass. This is useful when you want to extend the behavior of the superclass method rather than completely replace it.

**Example: Using super to Extend Functionality**

```java
class Animal {
    public void makeSound() {
        System.out.println("Generic animal sound");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        super.makeSound(); // Call the superclass method
        System.out.println("Woof!"); // Add additional behavior
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.makeSound();
        // Output:
        // Generic animal sound
        // Woof!
    }
}
```

In this example:

- The makeSound() method in the Dog class overrides the makeSound() method in the Animal class.
- The super.makeSound() call invokes the makeSound() method in the Animal class, which prints "Generic animal sound".
- The System.out.println("Woof!") statement then adds additional behavior, printing "Woof!".
- This allows the Dog class to extend the behavior of the Animal class without completely replacing it.

**When to Use super**

- **Extending Behavior**: Use super when you want to add additional behavior to the overridden method while still retaining the original behavior of the superclass method.
- **Accessing Superclass Members**: Use super to access fields or methods in the superclass that have been hidden or overridden in the subclass.
- **Calling Superclass Constructors**: Use super() to call the superclass constructor from within the subclass constructor. This is necessary to ensure that the superclass is properly initialized.

#### <a name="chapter6part7.3"></a>Chapter 6 - Part 7.3: Method Overriding vs. Method Overloading

It's important to distinguish between method overriding and method overloading, as they are often confused.

|Feature	|Method Overriding	|Method Overloading|
| :-------: | :-------: | :-------: |
|Definition|	Providing a different implementation in a subclass|	Providing multiple methods with the same name in the same class|
|Relationship|	Occurs between a superclass and a subclass|	Occurs within the same class|
|Signature|	Must have the same name, parameters, and return type|	Must have the same name but different parameters|
|Purpose|	To change the behavior of an inherited method|	To provide different ways to call a method|
|Compile-time|	Resolved at runtime (dynamic binding)|	Resolved at compile time (static binding)|

**Example: Overloading vs. Overriding**

```java
class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    // Method Overloading: Same name, different parameters
    public double add(double a, double b) {
        return a + b;
    }
}

class ScientificCalculator extends Calculator {
    // Method Overriding: Same name, same parameters, same return type
    @Override
    public int add(int a, int b) {
        System.out.println("Adding integers in ScientificCalculator");
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator calculator = new Calculator();
        ScientificCalculator scientificCalculator = new ScientificCalculator();

        System.out.println(calculator.add(2, 3)); // Output: 5
        System.out.println(calculator.add(2.5, 3.5)); // Output: 6.0

        System.out.println(scientificCalculator.add(2, 3));
        // Output:
        // Adding integers in ScientificCalculator
        // 5
    }
}
```

In this example:

- The Calculator class has two add() methods with different parameters, which is method overloading.
- The ScientificCalculator class overrides the add(int a, int b) method from the Calculator class, which is method overriding.

#### <a name="chapter6part7.4"></a>Chapter 6 - Part 7.4: Practical Examples and Demonstrations

**Example: Polymorphism and Method Overriding**

Method overriding is a key enabler of polymorphism, which allows you to treat objects of different classes in a uniform way.

```java
class Animal {
    public void makeSound() {
        System.out.println("Generic animal sound");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Woof!");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Meow!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal[] animals = new Animal[3];
        animals[0] = new Animal();
        animals[1] = new Dog();
        animals[2] = new Cat();

        for (Animal animal : animals) {
            animal.makeSound();
        }
        // Output:
        // Generic animal sound
        // Woof!
        // Meow!
    }
}
```

In this example:

- An array of Animal objects is created, containing instances of Animal, Dog, and Cat.
- The makeSound() method is called on each element of the array.
- Due to method overriding, the appropriate makeSound() method is called for each object, resulting in different outputs for each animal.
- This demonstrates polymorphism, where objects of different classes can be treated as objects of a common type (Animal) and respond differently to the same method call.

**Example: Overriding toString() Method**

The toString() method is a special method in Java that is used to provide a string representation of an object. It is defined in the Object class, which is the ultimate superclass of all Java classes. You can override the toString() method in your classes to provide a more meaningful string representation of your objects.

```java
class Point {
    private int x;
    private int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public String toString() {
        return "Point [x=" + x + ", y=" + y + "]";
    }
}

public class Main {
    public static void main(String[] args) {
        Point point = new Point(10, 20);
        System.out.println(point); // Output: Point [x=10, y=20]
    }
}
```

In this example:

- The toString() method is overridden in the Point class to provide a string representation of the Point object that includes the values of its x and y coordinates.
- When System.out.println(point) is called, the toString() method is automatically invoked, and the resulting string is printed to the console.

#### <a name="chapter6part8"></a>Chapter 6 - Part 8: The `super` Keyword: Accessing Parent Class Members

The super keyword in Java is a crucial element in object-oriented programming, particularly when dealing with inheritance. It allows a subclass to access members (methods and variables) of its parent class, enabling code reuse and extension of functionality. Understanding super is essential for creating robust and maintainable class hierarchies. It's not just about accessing parent class members; it's about controlling how you access them, especially when method overriding is involved.

#### <a name="chapter6part8.1"></a>Chapter 6 - Part 8.1: Understanding the super Keyword

The super keyword serves two primary purposes:

- **Calling the Parent Class Constructor**: super() is used to invoke the constructor of the parent class. This is often necessary to initialize the inherited members of the subclass.
- **Accessing Parent Class Members**: super.member is used to access methods or variables defined in the parent class, even if they are hidden or overridden in the subclass.

**Calling the Parent Class Constructor**

When a subclass is instantiated, the constructor of its parent class is automatically called before the subclass constructor. If you don't explicitly call a parent class constructor using super(), Java implicitly calls the no-argument constructor (the constructor with no parameters) of the parent class.

- **Why is this important?** The parent class constructor often initializes important state for the object. Failing to call it can lead to unexpected behavior or errors.

```java
class Animal {
    String name;

    Animal() {
        this("Generic Animal"); // Calls the other constructor in Animal
        System.out.println("Animal constructor called");
    }

    Animal(String name) {
        this.name = name;
        System.out.println("Animal constructor with name called: " + name);
    }
}

class Dog extends Animal {
    Dog() {
        super("Dog"); // Explicitly calls the Animal(String name) constructor
        System.out.println("Dog constructor called");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        System.out.println("Dog's name: " + myDog.name);
    }
}
```

**Explanation**:

- The Dog constructor calls super("Dog"), which invokes the Animal(String name) constructor.
- This initializes the name field in the Animal class to "Dog".
- If we didn't call super("Dog"), Java would try to call the Animal() constructor. If Animal only had the constructor with the name parameter, the code would not compile.
- The output demonstrates the order of constructor calls: first the parent, then the child.

- **Important Note**: The call to super() must be the first statement in the subclass constructor. This ensures that the parent class is properly initialized before the subclass attempts to initialize its own members.

**Accessing Parent Class Members (Methods and Variables)**

The super keyword can also be used to access methods and variables defined in the parent class. This is particularly useful when a subclass overrides a method from the parent class but still needs to access the original implementation.

- **Why is this important?** Method overriding allows a subclass to provide its own specific implementation of a method inherited from the parent class. However, sometimes you need to extend the parent's behavior rather than completely replacing it. super allows you to do this.

```java
class Animal {
    public void makeSound() {
        System.out.println("Generic animal sound");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        super.makeSound(); // Calls the makeSound() method in the Animal class
        System.out.println("Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        myDog.makeSound();
    }
}
```

**Explanation:**

- The Dog class overrides the makeSound() method from the Animal class.
- Inside the Dog's makeSound() method, super.makeSound() is called. This executes the makeSound() method defined in the Animal class, printing "Generic animal sound".
- Then, the Dog's makeSound() method prints "Woof!".
- The output shows that both the parent and child class methods are executed.

- **Accessing Variables**: super can also be used to access variables (fields) of the parent class, even if they are hidden by variables with the same name in the subclass.

```java
class Animal {
    String name = "Animal";
}

class Dog extends Animal {
    String name = "Dog";

    public void printNames() {
        System.out.println("Dog's name: " + name); // Accesses the Dog's name variable
        System.out.println("Animal's name: " + super.name); // Accesses the Animal's name variable
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        myDog.printNames();
    }
}
```

**Explanation:**

- Both Animal and Dog have a variable named name.
- Inside Dog's printNames() method, name refers to the Dog's name variable, while super.name refers to the Animal's name variable.
- This demonstrates how super can be used to disambiguate between variables with the same name in the parent and child classes.

**Practical Considerations and Best Practices**

- **When to use super()**: Always use super() in a subclass constructor if the parent class requires initialization parameters. Even if the parent class has a no-argument constructor, it's often good practice to explicitly call super() to ensure proper initialization.
- **When to use super.member**: Use super.member when you need to access a specific member (method or variable) of the parent class that has been hidden or overridden in the subclass. This is particularly useful when you want to extend the functionality of the parent class rather than completely replacing it.
- **Avoiding Ambiguity**: If a class inherits from multiple levels of parent classes, using super will always refer to the immediate parent class. There's no direct way to access members of grandparent classes using super directly.
- **Access Modifiers**: The ability to access parent class members using super is subject to access modifiers (public, protected, private, default). You cannot access private members of the parent class using super. protected members are accessible within the subclass and within the same package. public members are accessible everywhere. Default (package-private) members are accessible within the same package.

#### <a name="chapter6part9"></a>Chapter 6 - Part 9: Class Composition and Polymorphism

#### <a name="chapter6part9.1"></a>Chapter 9 - Part 6.1: Modifiers in Java

By now, you are quite familiar with the ```public``` keyword that appears in almost all of our examples:

```java

public class Main

```

The ```public``` keyword is an **access modifier**, meaning that it is used to set the access level for classes, attributes, methods and constructors.

We divide modifiers into two groups:

- Access Modifiers - controls the access level
- Non-Access Modifiers - do not control access level, but provides other functionality

**Access Modifiers**

For **classes**, you can use either ```public``` or default:

| Modifier | Description                                                                                                   |
| :-------:| :------------------------------------------------------------------------------------------------------------:|
| public   | The class is accessible by any other class                                                                    |
| default  | The class is only accessible by classes in the same package. This is used when you don't specify a modifier.  | 

For **attributes, methods and constructors**, you can use the one of the following:

| Modifier   | Description                                                                                       |
| :---------:| :------------------------------------------------------------------------------------------------:|
| public     | The code is accessible for all classes                                                            |
| private    | The code is only accessible within the declared class                                             |
| default    | The code is only accessible in the same package. This is used when you don't specify a modifier.  | 
| protected  | The code is accessible in the same package and subclasses.                                        | 

<br>

<div align="center"><img src="img/modifiers-w1046-h434.png" width=1046 height=434><br><sub>Fig 32 - Modifiers in Java - (<a href='https://stackoverflow.com/questions/215497/what-is-the-difference-between-public-protected-package-private-and-private-in'>Work by  aioobe</a>) </sub></div>

<br>

**Non-Access Modifiers**

For **classes**, you can use either ```final``` or ```abstract```:

| Modifier  | Description                                                                                                       |
| :--------:| :----------------------------------------------------------------------------------------------------------------:|
| final     | The class cannot be inherited by other classes                                                                    |
| abstract  | The class cannot be used to create objects (To access an abstract class, it must be inherited from another class. | 

For **attributes and methods**, you can use the one of the following:

| Modifier      | Description                                                                                                       |
| :------------:| :----------------------------------------------------------------------------------------------------------------:|
| final         | Attributes and methods cannot be overridden/modified                                                                    |
| static        | Attributes and methods belongs to the class, rather than an object |
| abstract      | Can only be used in an abstract class, and can only be used on methods. The method does not have a body, for example **abstract void run();**. The body is provided by the subclass (inherited from).  | 
| transient     | Attributes and methods are skipped when serializing the object containing them | 
| synchronized  | Methods can only be accessed by one thread at a time | 
| volatile      | The value of an attribute is not cached thread-locally, and is always read from the "main memory" |

**Final**

If you don't want the ability to override existing attribute values, declare attributes as ```final```:

```java

public class Main {
  final int x = 10;
  final double PI = 3.14;

  public static void main(String[] args) {
    Main myObj = new Main();
    myObj.x = 50; // will generate an error: cannot assign a value to a final variable
    myObj.PI = 25; // will generate an error: cannot assign a value to a final variable
    System.out.println(myObj.x);
  }
}

```

**Static**

A ```static``` method means that it can be accessed without creating an object of the class, unlike ```public```:

An example to demonstrate the differences between ```static``` and ```public``` methods:

```java

public class Main {
  // Static method
  static void myStaticMethod() {
    System.out.println("Static methods can be called without creating objects");
  }

  // Public method
  public void myPublicMethod() {
    System.out.println("Public methods must be called by creating objects");
  }

  // Main method
  public static void main(String[ ] args) {
    myStaticMethod(); // Call the static method
    // myPublicMethod(); This would output an error

    Main myObj = new Main(); // Create an object of Main
    myObj.myPublicMethod(); // Call the public method
  }
}

```

**Abstract**

An ```abstract``` method belongs to an ```abstract``` class, and it does not have a body. The body is provided by the subclass:

```java

// Code from filename: Main.java
// abstract class
abstract class Main {
  public String fname = "John";
  public int age = 24;
  public abstract void study(); // abstract method
}

// Subclass (inherit from Main)
class Student extends Main {
  public int graduationYear = 2018;
  public void study() { // the body of the abstract method is provided here
    System.out.println("Studying all day long");
  }
}
// End code from filename: Main.java

// Code from filename: Second.java
class Second {
  public static void main(String[] args) {
    // create an object of the Student class (which inherits attributes and methods from Main)
    Student myObj = new Student();

    System.out.println("Name: " + myObj.fname);
    System.out.println("Age: " + myObj.age);
    System.out.println("Graduation Year: " + myObj.graduationYear);
    myObj.study(); // call abstract method
  }
}

```

#### <a name="chapter6part9.2"></a>Chapter 6 - Part 9.2: Encapsulation in Java

It is a principle consisting of hide implementation details of a class, exposing only safe operations and maintain objects in a consistent state.

Golden rule: the object must always be in a consistent state, and the class itself must guarantee this.

**An object must NOT expose any attributes (access modifier private)**

**Attributes must be accessed via get and set methods. [JavaBeans](https://en.wikipedia.org/wiki/JavaBeans)**

The meaning of Encapsulation, is to make sure that "sensitive" data is hidden from users. To achieve this, you must:

- declare class variables/attributes as ```private```.
- provide public get and set methods to access and update the value of a ```private``` variable

**Get and Set**

You learned from the previous chapter that ```private``` variables can only be accessed within the same class (an outside class has no access to it). However, it is possible to access them if we provide public get and set methods.

The ```get``` method returns the variable value, and the ```set``` method sets the value.

Syntax for both is that they start with either ```get``` or ```set```, followed by the name of the variable, with the first letter in upper case:

```java

public class Person {
  private String name; // private = restricted access

  // Getter
  public String getName() {
    return name;
  }

  // Setter
  public void setName(String newName) {
    this.name = newName;
  }
}

```

The ```get``` method returns the value of the variable ```name```.

The ```set``` method takes a parameter (```newName```) and assigns it to the ```name``` variable. The ```this``` keyword is used to refer to the current object.

However, as the ```name``` variable is declared as ```private```, we cannot access it from outside this class:

```java

public class Main {
  public static void main(String[] args) {
    Person myObj = new Person();
    myObj.name = "John";  // error
    System.out.println(myObj.name); // error 
  }
}


```

If the variable was declared as ```public```, we would expect the following output:

```John```

However, as we try to access a ```private``` variable, we get an error:

Instead, we use the ```getName()``` and ```setName()``` methods to access and update the variable:

```java

public class Main {
  public static void main(String[] args) {
    Person myObj = new Person();
    myObj.setName("John"); // Set the value of the name variable to "John"
    System.out.println(myObj.getName());
  }
}

// Outputs "John"

```

**Why Encapsulation?**

- Better control of class attributes and methods
- Class attributes can be made read-only (if you only use the ```get``` method), or write-only (if you only use the set method)
- Flexible: the programmer can change one part of the code without affecting other parts
- Increased security of data


```java

public class Product {

	private String name;
	private double price;
	private int quantity;
	
	public Product() {
	}
	
	public Product(String name, double price, int quantity) {
		this.name = name;
		this.price = price;
		this.quantity = quantity;
	}
	
	public Product(String name, double price) {
		this.name = name;
		this.price = price;
	}
	
	public String getName() {
		return name;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public double getPrice() {
		return price;
	}
	
	public void setPrice(double price) {
		this.price = price;
	}
	
	public int getQuantity() {
		return quantity;
	}

```

#### <a name="chapter6part9.3"></a>Chapter 6 - Part 9.3: Classes Composition in Java

It is a type of association that allows one object to contain another

"has-one" or "has-many" relationship

Advantages
- Organization: division of responsibilities
- Cohesion
- Flexibility
- Reuse

<br>

<div align="center"><img src="img/compostion1-w865-h453.png" width=865 height=453><br><sub>Fig 39 - Composition - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Exercise: Read data from a worker with N contracts (N provided by the user). then request a month and show the employee's salary in that month, as shown in the example

<br>

<div align="center"><img src="img/compostion2-w766-h399.png" width=766 height=399><br><sub>Fig 39 - Compostion Exercise - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

<div align="center"><img src="img/compostion3-w658-h553.png" width=658 height=553><br><sub>Fig 39 - Compostion Exercise - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Resolution:

**WorkerLevel Class (enum)**

```java

package entities.enums;

public enum WorkerLevel {

	JUNIOR,
	MID_LEVEL,
	SENIOR;
}

```

**Department Class**

```java

package entities;

public class Department {

	private String name;
	
	public Department() {
	}

	public Department(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}

```

**HourContract Class**

```java

package entities;

import java.util.Date;

public class HourContract {

	private Date date;
	private Double valuePerHour;
	private Integer hours;
	
	public HourContract() {
	}

	public HourContract(Date date, Double valuePerHour, Integer hours) {
		this.date = date;
		this.valuePerHour = valuePerHour;
		this.hours = hours;
	}

	public Date getDate() {
		return date;
	}

	public void setDate(Date date) {
		this.date = date;
	}

	public Double getValuePerHour() {
		return valuePerHour;
	}

	public void setValuePerHour(Double valuePerHour) {
		this.valuePerHour = valuePerHour;
	}

	public Integer getHours() {
		return hours;
	}

	public void setHours(Integer hours) {
		this.hours = hours;
	}
	
	public double totalValue() {
		return valuePerHour * hours;
	}
}

```

**Worker Class**

```java

package entities;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;

import entities.enums.WorkerLevel;

public class Worker {

	private String name;
	private WorkerLevel level;
	private Double baseSalary;
	
	private Department department;
	private List<HourContract> contracts = new ArrayList<>();
	
	public Worker() {
	}

	public Worker(String name, WorkerLevel level, Double baseSalary, Department department) {
		this.name = name;
		this.level = level;
		this.baseSalary = baseSalary;
		this.department = department;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public WorkerLevel getLevel() {
		return level;
	}

	public void setLevel(WorkerLevel level) {
		this.level = level;
	}

	public Double getBaseSalary() {
		return baseSalary;
	}

	public void setBaseSalary(Double baseSalary) {
		this.baseSalary = baseSalary;
	}

	public Department getDepartment() {
		return department;
	}

	public void setDepartment(Department department) {
		this.department = department;
	}

	public List<HourContract> getContracts() {
		return contracts;
	}

	public void addContract(HourContract contract) {
		contracts.add(contract);
	}
	
	public void removeContract(HourContract contract) {
		contracts.remove(contract);
	}
	
	public double income(int year, int month) {
		double sum = baseSalary;
		Calendar cal = Calendar.getInstance();
		for (HourContract c : contracts) {
			cal.setTime(c.getDate());
			int c_year = cal.get(Calendar.YEAR);
			int c_month = 1 + cal.get(Calendar.MONTH);
			if (year == c_year && month == c_month) {
				sum += c.totalValue();
			}
		}
		return sum;
	}
}

```

**Program**

```java

package application;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.Scanner;

import entities.Department;
import entities.HourContract;
import entities.Worker;
import entities.enums.WorkerLevel;

public class Program {

	public static void main(String[] args) throws ParseException {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
		
		System.out.print("Enter department's name: ");
		String departmentName = sc.nextLine();
		System.out.println("Enter worker data:");
		System.out.print("Name: ");
		String workerName = sc.nextLine();
		System.out.print("Level: ");
		String workerLevel = sc.nextLine();
		System.out.print("Base salary: ");
		double baseSalary = sc.nextDouble();
		Worker worker = new Worker(workerName, WorkerLevel.valueOf(workerLevel), baseSalary, new Department(departmentName));
		
		System.out.print("How many contracts to this worker? ");
		int n = sc.nextInt();
		
		for (int i=1; i<=n; i++) {
			System.out.println("Enter contract #" + i + " data:");
			System.out.print("Date (DD/MM/YYYY): ");
			Date contractDate = sdf.parse(sc.next());
			System.out.print("Value per hour: ");
			double valuePerHour = sc.nextDouble();
			System.out.print("Duration (hours): ");
			int hours = sc.nextInt();
			HourContract contract = new HourContract(contractDate, valuePerHour, hours);
			worker.addContract(contract);
		}
		
		System.out.println();
		System.out.print("Enter month and year to calculate income (MM/YYYY): ");
		String monthAndYear = sc.next();
		int month = Integer.parseInt(monthAndYear.substring(0, 2));
		int year = Integer.parseInt(monthAndYear.substring(3));
		System.out.println("Name: " + worker.getName());
		System.out.println("Department: " + worker.getDepartment().getName());
		System.out.println("Income for " + monthAndYear + ": " + String.format("%.2f", worker.income(year, month)));
		
		sc.close();
	}
}

```

#### <a name="chapter6part9.4"></a>Chapter 6 - Part 9.4: Inheritance in Java

It is an association type that allows a class to inherit all data and behaviors of another

- Benefits
  - reuse
  - Polymorphism
  
In Java, it is possible to inherit attributes and methods from one class to another. We group the "inheritance concept" into two categories:

- **subclass** (child) - the class that inherits from another class
- **superclass** (parent) - the class being inherited from

To inherit from a class, use the ```extends``` keyword.

Example: In the example below, the ```Car``` class (subclass) inherits the attributes and methods from the ```Vehicle``` class (superclass):

```java

class Vehicle {
  protected String brand = "Ford";        // Vehicle attribute
  public void honk() {                    // Vehicle method
    System.out.println("Tuut, tuut!");
  }
}

class Car extends Vehicle {
  private String modelName = "Mustang";    // Car attribute
  public static void main(String[] args) {

    // Create a myCar object
    Car myCar = new Car();

    // Call the honk() method (from the Vehicle class) on the myCar object
    myCar.honk();

    // Display the value of the brand attribute (from the Vehicle class) and the value of the modelName from the Car class
    System.out.println(myCar.brand + " " + myCar.modelName);
  }
}

```

Another Example: Suppose a banking business that has a common account and an account for companies, and the company account has all account members common plus a borrowing limit and a borrowing operation.

<br>

<div align="center"><img src="img/inheritance1-w774-h342.png" width=774 height=342><br><sub>Fig 40 - Inheritance - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>



Important Definitions:

- "is-a" relationship

- generalization/specialization

- Superclass (base class) / subclass (class derivative)

- inheritance / extension

- Inheritance is an association between classes (not between objects)

Class Account

```java

package entities;

public class Account {

	private Integer number;
	private String holder;
	protected Double balance;
		
	public Account() {
	}
	
	public Account(Integer number, String holder, Double balance) {
		this.number = number;
		this.holder = holder;
		this.balance = balance;
	}

	public Integer getNumber() {
		return number;
	}

	public void setNumber(Integer number) {
		this.number = number;
	}

	public String getHolder() {
		return holder;
	}

	public void setHolder(String holder) {
		this.holder = holder;
	}

	public Double getBalance() {
		return balance;
	}

	public void withdraw(double amount) {
		balance -= amount;
	}

	public void deposit(double amount) {
		balance += amount;
	}
}

```

Did you notice the ```protected``` modifier in ```Account```?

We set the ```balance``` attribute in ```Account``` to a ```protected``` access modifier. If it was set to ```private```, the ```BusinessAccount``` class would not be able to access it.

class BussinesAccount

```java

package entities;

public class BusinessAccount extends Account {

	private Double loanLimit;
	
	public BusinessAccount() {
		super();
	}

	public BusinessAccount(Integer number, String holder, Double balance, Double loanLimit) {
		super(number, holder, balance);
		this.loanLimit = loanLimit;
	}

	public Double getLoanLimit() {
		return loanLimit;
	}

	public void setLoanLimit(Double loanLimit) {
		this.loanLimit = loanLimit;
	}
	
	public void loan(double amount) {
		if (amount <= loanLimit) {
			balance += amount - 10.0;
		}
	}
}

```

Program

```java

package application;

import entities.BusinessAccount;

public class Program {

	public static void main(String[] args) {

		BusinessAccount account = new BusinessAccount(8010, "Bob Brown", 0.0, 500.0);

		System.out.println(account.getBalance());
	}
}

```

**Upcasting and downcasting**

- Upcasting
  - Casting from subclass to superclass
  - Common usage: polymorphism

- Downcasting
  - Casting from superclass to subclass
  - instanceof ```keyword```
  - Common usage: methods that take generic parameters (ex: Equals)
  
Example:

<br>

<div align="center"><img src="img/updowncasting-w493-h400.png" width=493 height=400><br><sub>Fig 41 - Upcasting and Downcasting - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Class SavingsAccount

```java

package entities;

public class SavingsAccount extends Account {
	
	private Double interestRate;
	
	public SavingsAccount() {
		super();
	}

	public SavingsAccount(Integer number, String holder, Double balance, Double interestRate) {
		super(number, holder, balance);
		this.interestRate = interestRate;
	}

	public Double getInterestRate() {
		return interestRate;
	}

	public void setInterestRate(Double interestRate) {
		this.interestRate = interestRate;
	}
	
	public void updateBalance() {
		balance += balance * interestRate;
	}
}

```

Program

```java

package application;

import entities.Account;
import entities.BusinessAccount;
import entities.SavingsAccount;

public class Program {

	public static void main(String[] args) {

		Account acc = new Account(1001, "Alex", 0.0);
		BusinessAccount bacc = new BusinessAccount(1002, "Maria", 0.0, 500.0);
		
		// UPCASTING
		
		Account acc1 = bacc;
		Account acc2 = new BusinessAccount(1003, "Bob", 0.0, 200.0);
		Account acc3 = new SavingsAccount(1004, "Anna", 0.0, 0.01);
		
		// DOWNCASTING
		
		BusinessAccount acc4 = (BusinessAccount)acc2;
		acc4.loan(100.0);
		
		// BusinessAccount acc5 = (BusinessAccount)acc3;
		if (acc3 instanceof BusinessAccount) {
			BusinessAccount acc5 = (BusinessAccount)acc3;
			acc5.loan(200.0);
			System.out.println("Loan!");
		}
		
		if (acc3 instanceof SavingsAccount) {
			SavingsAccount acc5 = (SavingsAccount)acc3;
			acc5.updateBalance();
			System.out.println("Update!");
		}
	}
}

```

**Override**

- It is the implementation of a method of a superclass in the subclass
- It is strongly recommended to use the @Override annotation in a method envelope
  - Facilitates reading and understanding of code
  - We notify the compiler (good practice)

class Account

```Java

public void withdraw(double amount) {
	balance -= amount + 5.0;
}

```

SavingsAccount

```java

@Override
public void withdraw(double amount) {
	balance -= amount;
}

```

**Keyword Super**

You can call the superclass implementation using the word super.

Example: suppose that, in the BusinessAccount class, the rule for withdrawal is to perform the draw normally from the superclass, and deduct another 2.0.

In this case, the withdraw method is the same, but with one moddification in the BissinesAccount class, because is tho only diference.

Class BissinesAccount

```java

@Override
public void withdraw(double amount) {
	super.withdraw(amount);
	balance -= 2.0;
}

```

**Keyword Final**

If you don't want other classes to inherit from a class, use the ```final``` keyword:

Example: If you try to access a ```final``` class, Java will generate an error:

```java

final class Vehicle {
  ...
}

class Car extends Vehicle {
  ...
}

// Main.java:9: error: cannot inherit from final Vehicle
//class Main extends Vehicle {
//                  ^
// 1 error)

```

You can use in method. In this case prevents the method under from being overridden

Example: Suppose you don't want the Withdraw method of SavingsAccount is overridden

```java

@Override
public final void withdraw(double amount) {
	balance -= amount;
}

```

why use final?

- Security: Depending on business rules, it is sometimes desirable ensure that a class is not inherited, or that a method is not be superimposed.
  - It is generally convenient to add final in overlapping methods, as Multiple overlays can be a gateway to inconsistencies

- Performance: type attributes of a final class are parsed accordingly. faster at runtime.
  - Classic example: String

#### <a name="chapter6part9.5"></a>Chapter 6 - Part 9.5: Polymorphism in Java

In Object Oriented Programming, polymorphism is a resource that allows variables of the same more generic type to be point to objects of different specific types, thus having different behaviors depending on each specific type.

```java

Account x = new Account(1020, "Alex", 1000.0);
Account y = new SavingsAccount(1023, "Maria", 1000.0, 0.01);

x.withdraw(50.0);
y.withdraw(50.0);

```

Another Example:

For example, think of a superclass called ```Animal``` that has a method called ```animalSound()```. Subclasses of Animals could be Pigs, Cats, Dogs, Birds - And they also have their own implementation of an animal sound (the pig oinks, and the cat meows, etc.):

```java

class Animal {
  public void animalSound() {
    System.out.println("The animal makes a sound");
  }
}

class Pig extends Animal {
  public void animalSound() {
    System.out.println("The pig says: wee wee");
  }
}

class Dog extends Animal {
  public void animalSound() {
    System.out.println("The dog says: bow wow");
  }
}

```
Now we can create ```Pig``` and ```Dog``` objects and call the ```animalSound()``` method on both of them:

```java

class Animal {
  public void animalSound() {
    System.out.println("The animal makes a sound");
  }
}

class Pig extends Animal {
  public void animalSound() {
    System.out.println("The pig says: wee wee");
  }
}

class Dog extends Animal {
  public void animalSound() {
    System.out.println("The dog says: bow wow");
  }
}

class Main {
  public static void main(String[] args) {
    Animal myAnimal = new Animal();  // Create a Animal object
    Animal myPig = new Pig();  // Create a Pig object
    Animal myDog = new Dog();  // Create a Dog object
    myAnimal.animalSound();
    myPig.animalSound();
    myDog.animalSound();
  }
}

```

Why And When To Use "Inheritance" and "Polymorphism"?

- It is useful for code reusability: reuse attributes and methods of an existing class when you create a new class.

Exercise:  A company has its own and outsourced employees. For each employee, you want to record name, hours worked and hourly rate. outsourced employees have an additional expense.

Employee pay corresponds to the hourly rate multiplied by the hours worked, with the outsourced employees still receive a bonus corresponding to 110% of your additional expense.

Write a program to read the data of N employees (N provided by the user) and store them in a list. Later to read all data, show name and payment of each employee in the same order they were entered.

Build the program according to the project on the side. Look example on the next page.

<br>

<div align="center"><img src="img/polymorphism1-w383-h532.png" width=383 height=532><br><sub>Fig 42 - Exercise Polymorphism - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

<div align="center"><img src="img/polymorphism2-w384-h461.png" width=383 height=461><br><sub>Fig 43 - Exercise Polymorphism - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Class Employee

```java

package entities;

public class Employee {

	private String name;
	private Integer hours;
	private Double valuePerHour;
	
	public Employee() {
	}

	public Employee(String name, Integer hours, Double valuePerHour) {
		this.name = name;
		this.hours = hours;
		this.valuePerHour = valuePerHour;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Integer getHours() {
		return hours;
	}

	public void setHours(Integer hours) {
		this.hours = hours;
	}

	public Double getValuePerHour() {
		return valuePerHour;
	}

	public void setValuePerHour(Double valuePerHour) {
		this.valuePerHour = valuePerHour;
	}
	
	public double payment() {
		return hours * valuePerHour;
	}
}

```

Class OutsourcedEmployee

```java

package entities;

public class OutsourcedEmployee extends Employee {

	private Double additionalCharge;

	public OutsourcedEmployee() {
		super();
	}
	
	public OutsourcedEmployee(String name, Integer hours, Double valuePerHour, Double additionalCharge) {
		super(name, hours, valuePerHour);
		this.additionalCharge = additionalCharge;
	}

	public Double getAdditionalCharge() {
		return additionalCharge;
	}

	public void setAdditionalCharge(Double additionalCharge) {
		this.additionalCharge = additionalCharge;
	}
	
	@Override
	public double payment() {
		return super.payment() + additionalCharge * 1.1;
	}
}

```

Program

```java

package application;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Scanner;

import entities.Employee;
import entities.OutsourcedEmployee;

public class Program {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		List<Employee> list = new ArrayList<>();
		
		System.out.print("Enter the number of employees: ");
		int n = sc.nextInt();
		
		for (int i=1; i<=n; i++) {
			System.out.println("Employee #" + i + " data:");
			System.out.print("Outsourced (y/n)? ");
			char ch = sc.next().charAt(0);
			System.out.print("Name: ");
			sc.nextLine();
			String name = sc.nextLine();
			System.out.print("Hours: ");
			int hours = sc.nextInt();
			System.out.print("Value per hour: ");
			double valuePerHour = sc.nextDouble();
			//OBS: A List of Employee can add Employe or OutsourcedEmploye (polymorphism)
			if (ch == 'y') {
				System.out.print("Additional charge: ");
				double additionalCharge = sc.nextDouble();
				list.add(new OutsourcedEmployee(name, hours, valuePerHour, additionalCharge));
			}
			else {
				list.add(new Employee(name, hours, valuePerHour));
			}
		}
		
		System.out.println();
		System.out.println("PAYMENTS:");
		for (Employee emp : list) {
			System.out.println(emp.getName() + " - $ " + String.format("%.2f", emp.payment()));
		}
		
		sc.close();
	}
}

```

#### <a name="chapter6part9.6"></a>Chapter 6 - Part 9.6: Abstraction Class and methods

Data **abstraction** is the process of hiding certain details and showing only essential information to the user.
Abstraction can be achieved with either **abstract classes** or **interfaces** (which you will learn more about in the next chapter).

The ```abstract``` keyword is a non-access modifier, used for classes and methods:
- **Abstract class**: is a restricted class that cannot be used to create objects (to access it, it must be inherited from another class).
- **Abstract method**: can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from).

NOTE: In UML is Italic

An abstract class can have both abstract and regular methods:

```java

abstract class Animal {
  public abstract void animalSound();
  public void sleep() {
    System.out.println("Zzz");
  }
}

```

From the example above, it is not possible to create an object of the Animal class:

```java

Animal myObj = new Animal(); // will generate an error

```

To access the abstract class, it must be inherited from another class. Let's convert the Animal class we used in the Polymorphism chapter to an abstract class:

Remember from the Inheritance chapter that we use the extends keyword to inherit from a class.

```java

// Abstract class
abstract class Animal {
  // Abstract method (does not have a body)
  public abstract void animalSound();
  // Regular method
  public void sleep() {
    System.out.println("Zzz");
  }
}

// Subclass (inherit from Animal)
class Pig extends Animal {
  public void animalSound() {
    // The body of animalSound() is provided here
    System.out.println("The pig says: wee wee");
  }
}

class Main {
  public static void main(String[] args) {
    Pig myPig = new Pig(); // Create a Pig object
    myPig.animalSound();
    myPig.sleep();
  }
}

```

NOTE:  If a class has at least one method abstract, so this class is also abstract

Why And When To Use Abstract Classes and Methods?

To achieve security - hide certain details and only show the important details of an object.

Note: Abstraction can also be achieved with Interfaces, which you will learn more about in the next chapter.

Exercise: Write a program to read data from N figures (N provided by the user), and then show the areas of these figures in the same order in which they were entered.

<br>

<div align="center"><img src="img/abstraction-w1062-h461.png" width=1062 height=461><br><sub>Fig 44 - Exercise Abstraction - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Class Color

```java

package entities.enums;

public enum Color {
	BLACK,
	BLUE,
	RED;
}

```

Class Shape

```java

package entities;

import entities.enums.Color;

public abstract class Shape {

	private Color color;
	
	public Shape() {
	}
	
	public Shape(Color color) {
		this.color = color;
	}

	public Color getColor() {
		return color;
	}

	public void setColor(Color color) {
		this.color = color;
	}
	
	public abstract double area(); //OBS: when you put abstract in the method, you are obligated to put abstract in the class Shape
}

```

Class Circle

```java

package entities;

import entities.enums.Color;

public class Circle extends Shape {

	private Double radius;
	
	public Circle() {
		super();
	}
	
	public Circle(Color color, Double radius) {
		super(color);
		this.radius = radius;
	}

	public Double getRadius() {
		return radius;
	}

	public void setRadius(Double radius) {
		this.radius = radius;
	}

	@Override
	public double area() {
		return Math.PI * radius * radius;
	}
}

```

Class Retangle

```java

package entities;

import entities.enums.Color;

public class Rectangle extends Shape {

	private Double width;
	private Double height;
	
	public Rectangle() {
		super();
	}

	public Rectangle(Color color, Double width, Double height) {
		super(color);
		this.width = width;
		this.height = height;
	}

	public Double getWidth() {
		return width;
	}

	public void setWidth(Double width) {
		this.width = width;
	}

	public Double getHeight() {
		return height;
	}

	public void setHeight(Double height) {
		this.height = height;
	}

	@Override
	public double area() {
		return width * height;
	}
}

```

Program

```java

package application;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Scanner;

import entities.Shape;
import entities.Rectangle;
import entities.Circle;
import entities.enums.Color;

public class Program {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		List<Shape> list = new ArrayList<>();
		
		System.out.print("Enter the number of shapes: ");
		int n = sc.nextInt();
		
		for (int i=1; i<=n; i++) {
			System.out.println("Shape #" + i + " data:");
			System.out.print("Rectangle or Circle (r/c)? ");
			char ch = sc.next().charAt(0);
			System.out.print("Color (BLACK/BLUE/RED): ");
			Color color = Color.valueOf(sc.next());
			if (ch == 'r') {
				System.out.print("Width: ");
				double width = sc.nextDouble();
				System.out.print("Height: ");
				double height = sc.nextDouble();
				list.add(new Rectangle(color, width, height));
			}
			else {
				System.out.print("Radius: ");
				double radius = sc.nextDouble();
				list.add(new Circle(color, radius));
			}
		}
		
		System.out.println();
		System.out.println("SHAPE AREAS:");
		for (Shape shape : list) {
			System.out.println(String.format("%.2f", shape.area()));
		}
		
		sc.close();
	}
}

```

## <a name="chapter7"></a>Chapter 7: Exception Handling and Basic Input/Output

#### <a name="chapter7part1"></a>Chapter 7 - Part 1: Introduction to Exception Handling: Dealing with Errors

Exception handling is a crucial aspect of writing robust and reliable Java programs. It allows you to gracefully manage unexpected events or errors that may occur during program execution, preventing your application from crashing and providing a more user-friendly experience. Without proper exception handling, a single error could halt your entire program, leading to data loss or system instability. This lesson introduces the fundamental concepts of exception handling in Java, focusing on how to anticipate, catch, and handle errors effectively.

**Exceptions**

-  An exception is any error condition or behavior unexpected encountered by a running program

- In Java, an exception is an object inherited from the class:
  - java.lang.Exception - compiler forces to handle or propagate
  - java.lang.RuntimeException - compiler does not force to handle or propagate

- When thrown, an exception is propagated down the call stack of running methods, until it is captured (handled) or the program is terminated

<br>

<div align="center"><img src="img/exceptions-w720-h405.png" width=720 height=405><br><sub>Fig 50 - Exceptions in Java - (<a href='https://medium.com/interviewnoodle/exception-in-java-89a0b41e0c45'>Work by Deepti Swain</a>) </sub></div>

<br>

Error subclass is not handled, but Exception subclass need to be handled

**Why Exceptions?**

The exception handling model allows errors to be dealt with consistently and flexibly, using best practices

Benefits:
  - Delega a lógica do erro para a classe responsável por conhecer as regras que podem ocasionar o erro
  - Handles in an organized (including hierarchical) way exceptions of different types
  - The exception can load any data

#### <a name="chapter7part1.1"></a>Chapter 7 - Part 1.1: Understanding Exceptions

An exception is an event that disrupts the normal flow of a program's execution. It's essentially a signal that indicates a problem has occurred. These problems can arise from various sources, such as invalid user input, network connectivity issues, file access errors, or even programming mistakes.

**Checked vs. Unchecked Exceptions**

Java categorizes exceptions into two main types: checked and unchecked. Understanding the difference is crucial for effective exception handling.

- **Checked Exceptions**: These exceptions are checked by the compiler at compile time. If a method might throw a checked exception, it must either handle the exception using a try-catch block or declare that it throws the exception using the throws keyword in its method signature. This forces the programmer to explicitly acknowledge and deal with the potential exception. Examples include IOException (related to file input/output) and SQLException (related to database operations).

Example: Imagine you're writing a program that reads data from a file. The file might not exist, or the program might not have permission to access it. These are potential IOException scenarios. The compiler forces you to handle these possibilities.

- **Unchecked Exceptions**: These exceptions are not checked by the compiler at compile time. They typically represent programming errors or conditions that are difficult to recover from. Unchecked exceptions are subclasses of RuntimeException or Error.. Examples include NullPointerException, ArrayIndexOutOfBoundsException, and IllegalArgumentException. While you can handle unchecked exceptions, you are not required to do so by the compiler.

Example: Consider accessing an element in an array using an index that is out of bounds. This will result in an ArrayIndexOutOfBoundsException. While you could wrap the array access in a try-catch block, it's generally better to prevent the exception from occurring in the first place by validating the index.

|Feature	|Checked Exceptions	|Unchecked Exceptions|
| :-----------: | :-----------: | :-----------: |
|Compilation Check	|Checked at compile time	|Not checked at compile time|
|Handling	|Must be handled or declared in the method signature	|Handling is optional|
|Common Use Cases	|External resources, recoverable errors	|Programming errors, difficult-to-recover errors|
|Examples	|IOException, SQLException	|NullPointerException, IllegalArgumentException|

**The Exception Hierarchy**

In Java, exceptions are organized in a hierarchy with Throwable as the root class. Throwable has two main subclasses: Exception and Error.

- **Exception**: Represents conditions that a reasonable application might want to catch. This is the base class for both checked and unchecked exceptions (excluding RuntimeException).
- **Error**: Represents more serious problems that a reasonable application should not attempt to catch. These are typically related to the Java Virtual Machine (JVM) or system-level issues, such as OutOfMemoryError or StackOverflowError. Errors are usually unrecoverable.

Understanding this hierarchy helps you choose the appropriate way to handle different types of exceptions. You'll primarily focus on handling Exception and its subclasses.

#### <a name="chapter7part1.2"></a>Chapter 7 - Part 1.2: The try-catch Block: Handling Exceptions

The try-catch block is the fundamental mechanism for handling exceptions in Java. It allows you to isolate a section of code that might throw an exception and specify how to respond if an exception occurs.

**Structure of a try-catch Block**

The try-catch block consists of two main parts:

- **```try``` block**: This block encloses the code that might throw an exception. The JVM monitors this code for any exceptions that are thrown.

- **```catch``` block**: This block contains the code that will be executed if a specific type of exception is thrown within the try block. You can have multiple catch blocks to handle different types of exceptions.

```java
try {
    // Code that might throw an exception
    int result = 10 / 0; // This will throw an ArithmeticException
    System.out.println("This line will not be executed if an exception occurs.");
} catch (ArithmeticException e) {
    // Code to handle the ArithmeticException
    System.err.println("Error: Division by zero occurred.");
    // You can also log the exception, display an error message to the user, etc.
}
System.out.println("Program continues after the try-catch block.");
```

In this example, the try block contains a division by zero, which will throw an ArithmeticException. The catch block specifically catches ArithmeticException objects. When the exception is thrown, the JVM immediately jumps to the catch block, executes the code within it, and then continues execution after the try-catch block. The System.out.println statement inside the try block is skipped because the exception occurred before it could be executed.

**Multiple catch Blocks**

You can include multiple catch blocks to handle different types of exceptions that might be thrown within the try block. The catch blocks are examined in the order they appear. The first catch block that matches the type of the thrown exception will be executed.

```java
try {
    // Code that might throw different types of exceptions
    String str = null;
    System.out.println(str.length()); // Might throw a NullPointerException

    int[] arr = new int[5];
    System.out.println(arr[10]); // Might throw an ArrayIndexOutOfBoundsException
} catch (NullPointerException e) {
    System.err.println("Error: NullPointerException occurred.");
} catch (ArrayIndexOutOfBoundsException e) {
    System.err.println("Error: ArrayIndexOutOfBoundsException occurred.");
} catch (Exception e) {
    System.err.println("An unexpected error occurred: " + e.getMessage());
}
System.out.println("Program continues after the try-catch block.");
```

In this example, the try block contains code that might throw either a NullPointerException or an ArrayIndexOutOfBoundsException. There are separate catch blocks to handle each of these exceptions. If an exception is thrown that doesn't match either of these catch blocks, the final catch block, which catches the generic Exception type, will be executed. This is a good practice to ensure that all exceptions are handled in some way.

**Important**: When using multiple catch blocks, the order matters. You should always place more specific exception types before more general exception types. For example, you should catch NullPointerException before catching Exception, because NullPointerException is a subclass of Exception. If you catch Exception first, the catch block for NullPointerException will never be executed.

**The finally Block: Ensuring Code Executes**

The finally block is an optional part of the try-catch structure. It contains code that will always be executed, regardless of whether an exception is thrown or caught. This is useful for performing cleanup operations, such as closing files or releasing resources, that must be done regardless of the outcome of the try block.

```java
import java.io.*;

public class FinallyExample {
    public static void main(String[] args) {
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader("example.txt"));
            String line = reader.readLine();
            System.out.println(line);
        } catch (IOException e) {
            System.err.println("Error reading file: " + e.getMessage());
        } finally {
            try {
                if (reader != null) {
                    reader.close(); // Ensure the file is closed
                }
            } catch (IOException e) {
                System.err.println("Error closing file: " + e.getMessage());
            }
            System.out.println("Finally block executed.");
        }
    }
}
```

In this example, the finally block ensures that the BufferedReader is closed, even if an IOException is thrown while reading the file. This prevents resource leaks and ensures that the file is properly closed. Note the nested try-catch block within the finally block. This is necessary because the close() method itself can throw an IOException, and we want to handle that possibility as well.

**try-with-resources Statement (Modern Approach)**

Java 7 introduced the try-with-resources statement, which provides a more concise and safer way to manage resources that need to be closed after use. This statement automatically closes resources that implement the AutoCloseable interface (which includes most I/O resources like BufferedReader, FileOutputStream, etc.) at the end of the try block, regardless of whether an exception is thrown or not.

```java
import java.io.*;

public class TryWithResourcesExample {
    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new FileReader("example.txt"))) {
            String line = reader.readLine();
            System.out.println(line);
        } catch (IOException e) {
            System.err.println("Error reading file: " + e.getMessage());
        }
        // The reader is automatically closed here
    }
}
```

In this example, the BufferedReader is declared within the parentheses of the try statement. This ensures that the reader will be automatically closed when the try block completes, even if an IOException is thrown. This eliminates the need for a finally block and makes the code cleaner and less error-prone. This is the preferred way to handle resources in modern Java code.

#### <a name="chapter7part1.3"></a>Chapter 7 - Part 1.3: Common Exception Types

Understanding common exception types is essential for effective exception handling. Here are some of the most frequently encountered exceptions in Java:

- ```NullPointerException```: Thrown when you try to access a member (method or field) of a null object. This is a very common exception and often indicates a programming error.

```java
String str = null;
try {
    System.out.println(str.length()); // Throws NullPointerException
} catch (NullPointerException e) {
    System.err.println("Error: Cannot get length of a null string.");
}
```

- ```ArrayIndexOutOfBoundsException```: Thrown when you try to access an array element using an index that is outside the valid range (0 to array length - 1).

```java
int[] arr = new int[5];
try {
    System.out.println(arr[10]); // Throws ArrayIndexOutOfBoundsException
} catch (ArrayIndexOutOfBoundsException e) {
    System.err.println("Error: Array index out of bounds.");
}
```

- ```ArithmeticException```: Thrown when you perform an invalid arithmetic operation, such as dividing by zero.

```java
try {
    int result = 10 / 0; // Throws ArithmeticException
} catch (ArithmeticException e) {
    System.err.println("Error: Division by zero.");
}
```

- ```IllegalArgumentException```: Thrown when a method receives an argument that is not valid.

```java
public static void setAge(int age) {
    if (age < 0) {
        throw new IllegalArgumentException("Age cannot be negative.");
    }
    // ...
}

public static void main(String[] args) {
    try {
        setAge(-5);
    } catch (IllegalArgumentException e) {
        System.err.println("Error: " + e.getMessage());
    }
}
```

- ```IOException```: Thrown when an input or output operation fails. This is a checked exception.

```java
import java.io.*;

public class IOExceptionExample {
    public static void main(String[] args) {
        try (FileReader reader = new FileReader("nonexistent_file.txt")) {
            // ...
        } catch (IOException e) {
            System.err.println("Error reading file: " + e.getMessage());
        }
    }
}
```

#### <a name="chapter7part1.4"></a>Chapter 7 - Part 1.4: Best Practices for Exception Handling

Effective exception handling is crucial for writing robust and maintainable Java code. Here are some best practices to follow:

- **Be Specific**: Catch specific exception types whenever possible. This allows you to handle different types of errors in different ways and provides more informative error messages. Avoid catching the generic Exception class unless you really need to handle all possible exceptions in the same way.

- **Handle Exceptions Appropriately**: Don't just catch exceptions and ignore them. At a minimum, log the exception so that you can investigate the issue later. Ideally, you should also take some action to recover from the error or provide a meaningful error message to the user.

- **Use try-with-resources**: When working with resources that need to be closed (like files, network connections, etc.), use the try-with-resources statement to ensure that the resources are always closed, even if an exception is thrown.

- **Don't Overuse Exceptions**: Exceptions should be used for exceptional circumstances, not for normal control flow. For example, don't use an exception to signal that a user entered invalid input. Instead, validate the input before processing it.

- **Clean Up Resources in finally**: If you can't use try-with-resources (e.g., because you're using an older version of Java), use a finally block to ensure that resources are cleaned up, even if an exception is thrown.

- **Document Exceptions**: If a method might throw a checked exception, document it using the @throws tag in the Javadoc. This informs other developers that they need to handle the exception when calling your method.

- **Consider Custom Exceptions**: For application-specific errors, consider creating your own custom exception classes. This can make your code more readable and maintainable.

#### <a name="chapter7part2"></a>Chapter 7 - Part 2: The `try-catch` Block: Handling Exceptions

Exception handling is a crucial aspect of writing robust and reliable Java programs. It allows you to gracefully handle unexpected events or errors that may occur during program execution, preventing your application from crashing and providing a more user-friendly experience. The try-catch block is the fundamental mechanism for handling exceptions in Java, enabling you to isolate potentially problematic code and define how to respond when an exception is thrown.

#### <a name="chapter7part2.1"></a>Chapter 7 - Part 2.1: Understanding Exceptions

Before diving into the try-catch block, it's essential to understand what exceptions are. In Java, an exception is an event that disrupts the normal flow of the program's execution. Exceptions can occur for various reasons, such as:

- **Invalid Input**: The user enters data in an incorrect format (e.g., entering text when a number is expected).
- **File Not Found**: The program tries to open a file that doesn't exist.
- **Network Issues**: The program attempts to connect to a server that is unavailable.
- **Arithmetic Errors**: The program tries to divide a number by zero.
- **Null Pointer**: The program tries to access a member of an object that is null.
- **Array Index Out of Bounds**: The program tries to access an array element with an invalid index.

Java provides a hierarchy of exception classes, all derived from the Throwable class. Two main categories of exceptions are:

- **Checked Exceptions**: These exceptions are checked at compile time. If a method might throw a checked exception, it must either handle the exception using a try-catch block or declare that it throws the exception using the throws keyword. Examples include IOException and SQLException.

- **Unchecked Exceptions (Runtime Exceptions)**: These exceptions are not checked at compile time. They typically indicate programming errors and are often caused by issues like null pointers or array index out of bounds. Examples include NullPointerException and ArrayIndexOutOfBoundsException.

#### <a name="chapter7part2.2"></a>Chapter 7 - Part 2.2: The try-catch Block: A Detailed Explanation

The try-catch block is used to handle exceptions in Java. It consists of two main parts:

- **```try``` block**: This block encloses the code that might throw an exception.

- **```catch``` block**: This block contains the code that will be executed if an exception of a specific type occurs within the try block.

Here's the basic syntax of a try-catch block:

```java
try {
    // Code that might throw an exception
} catch (ExceptionType1 e) {
    // Code to handle ExceptionType1
} catch (ExceptionType2 e) {
    // Code to handle ExceptionType2
} // ... more catch blocks if needed
```

**Explanation**:

- The code within the try block is executed.

- If an exception occurs within the try block, the Java runtime system searches for a catch block that can handle the exception.

- The catch block's ExceptionType must be the same as or a superclass of the type of the exception that was thrown.

- If a matching catch block is found, the code within that catch block is executed. The exception object is assigned to the variable e, which can be used to access information about the exception.

- If no matching catch block is found, the exception is passed up the call stack to the calling method. If the exception is not handled there, it continues to propagate up the stack until it is either caught or the program terminates.

- After the catch block (if one is executed), the program continues execution after the try-catch block.

**Example 1: Handling ArithmeticException**

This example demonstrates how to handle an ArithmeticException, which occurs when dividing by zero.

```java
public class DivisionExample {
    public static void main(String[] args) {
        int numerator = 10;
        int denominator = 0;
        int result;

        try {
            result = numerator / denominator; // This will cause an ArithmeticException
            System.out.println("Result: " + result); // This line will not be executed if an exception occurs
        } catch (ArithmeticException e) {
            System.out.println("Error: Cannot divide by zero.");
            System.out.println("Exception details: " + e.getMessage()); // Print the exception message
        }

        System.out.println("Program continues after the try-catch block.");
    }
}
```

**Explanation**:

- The try block contains the division operation, which might throw an ArithmeticException if denominator is zero.
- The catch block specifically handles ArithmeticException. If the exception occurs, the code within the catch block is executed, printing an error message and the exception details.
- The line System.out.println("Result: " + result); inside the try block is skipped because the exception occurs before it can be executed.
- The program continues execution after the try-catch block, printing "Program continues after the try-catch block."

**Example 2: Handling ArrayIndexOutOfBoundsException**

This example demonstrates how to handle an ArrayIndexOutOfBoundsException, which occurs when trying to access an array element with an invalid index.

```java
public class ArrayExample {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};

        try {
            System.out.println("Element at index 10: " + numbers[10]); // This will cause an ArrayIndexOutOfBoundsException
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Error: Array index out of bounds.");
            System.out.println("Exception details: " + e.getMessage());
        }

        System.out.println("Program continues after the try-catch block.");
    }
}
```

**Explanation**:

- The try block attempts to access the element at index 10 of the numbers array. Since the array only has elements at indices 0 to 4, this will throw an ArrayIndexOutOfBoundsException.
- The catch block handles the ArrayIndexOutOfBoundsException, printing an error message and the exception details.
- The program continues execution after the try-catch block.

**Example 3: Multiple catch Blocks**

It's possible to have multiple catch blocks to handle different types of exceptions. This allows you to provide specific error handling for each type of exception that might occur.

```java
public class MultipleCatchExample {
    public static void main(String[] args) {
        try {
            // Simulate different exceptions
            int choice = 2; // Change this value to test different scenarios

            if (choice == 1) {
                int result = 10 / 0; // ArithmeticException
            } else if (choice == 2) {
                int[] numbers = {1, 2, 3};
                System.out.println(numbers[5]); // ArrayIndexOutOfBoundsException
            } else {
                String str = null;
                System.out.println(str.length()); // NullPointerException
            }
        } catch (ArithmeticException e) {
            System.out.println("ArithmeticException caught: " + e.getMessage());
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("ArrayIndexOutOfBoundsException caught: " + e.getMessage());
        } catch (NullPointerException e) {
            System.out.println("NullPointerException caught: " + e.getMessage());
        } catch (Exception e) {
            System.out.println("Generic Exception caught: " + e.getMessage()); // Catch-all block
        }

        System.out.println("Program continues...");
    }
}
```

**Explanation**:

- This example demonstrates how to use multiple catch blocks to handle different types of exceptions.
- The try block contains code that might throw an ArithmeticException, ArrayIndexOutOfBoundsException, or NullPointerException, depending on the value of the choice variable.
- Each catch block handles a specific type of exception.
- The catch (Exception e) block is a generic catch-all block that will catch any exception that is not caught by the more specific catch blocks. It's good practice to include a generic catch block as the last catch block to ensure that all exceptions are handled.

- **Important**: The order of catch blocks matters. More specific exception types should be caught before more general exception types. For example, ArithmeticException should be caught before Exception, because ArithmeticException is a subclass of Exception. If you catch Exception first, the ArithmeticException catch block will never be executed.

**Example 4: Nested try-catch Blocks**

try-catch blocks can be nested within each other. This is useful when you have code that might throw an exception and you want to handle it at different levels.

```java
public class NestedTryCatchExample {
    public static void main(String[] args) {
        try {
            // Outer try block
            int[] numbers = {1, 2, 3};

            try {
                // Inner try block
                System.out.println(numbers[5]); // Potential ArrayIndexOutOfBoundsException
            } catch (ArrayIndexOutOfBoundsException e) {
                System.out.println("Inner catch: ArrayIndexOutOfBoundsException caught");
            }

            System.out.println("Outer try block continues");

        } catch (Exception e) {
            System.out.println("Outer catch: Exception caught");
        }

        System.out.println("Program continues...");
    }
}
```

**Explanation**:

- The outer try block contains an inner try-catch block.
- If an ArrayIndexOutOfBoundsException occurs within the inner try block, the inner catch block will handle it.
- If any other exception occurs within the outer try block (but outside the inner try-catch), the outer catch block will handle it.
- If an exception is caught by the inner catch block, the outer catch block will not be executed.

#### <a name="chapter7part2.3"></a>Chapter 7 - Part 2.3: Best Practices for Using try-catch Blocks

- **Be Specific**: Catch specific exception types whenever possible. This allows you to handle each type of exception appropriately. Avoid using a generic catch (Exception e) block as the only catch block unless you truly want to handle all exceptions in the same way.

- **Handle or Re-throw**: When you catch an exception, you should either handle it (e.g., by logging an error, displaying a message to the user, or retrying the operation) or re-throw it if you cannot handle it at the current level. Re-throwing an exception can be done using the throw keyword.

- **Avoid Empty catch Blocks**: An empty catch block (i.e., a catch block that does nothing) is generally a bad practice. It can hide errors and make it difficult to debug your code. At the very least, you should log the exception.

- **Keep try Blocks Small**: The try block should only contain the code that might throw an exception. This makes it easier to identify the source of the exception and to handle it appropriately.

- **Use finally Blocks**: The finally block (which will be covered in the next lesson) can be used to ensure that certain code is always executed, regardless of whether an exception is thrown or caught. This is often used to release resources, such as closing files or network connections.

#### <a name="chapter7part3"></a>Chapter 7 - Part 3: The `finally` Block: Ensuring Code Executes

The finally block in Java is a crucial part of exception handling. It provides a mechanism to guarantee that a section of code is always executed, regardless of whether an exception is thrown or caught within a try block. This is particularly important for tasks like releasing resources, closing files, or cleaning up connections, ensuring that your program remains stable and avoids resource leaks. Understanding and utilizing the finally block effectively is essential for writing robust and reliable Java applications.

#### <a name="chapter7part3.1"></a>Chapter 7 - Part 3.1: Understanding the finally Block

The finally block is an optional block that follows the try and catch blocks in a try-catch construct. Its primary purpose is to execute code that must run, irrespective of whether an exception occurred or was handled. This makes it ideal for cleanup operations.

**Syntax and Structure**

The basic structure of a try-catch-finally block is as follows:

```java
try {
    // Code that might throw an exception
} catch (ExceptionType1 e1) {
    // Handle ExceptionType1
} catch (ExceptionType2 e2) {
    // Handle ExceptionType2
} finally {
    // Code that always executes
}
```

- **```try``` block**: Encloses the code that might potentially throw an exception.
- **```catch``` block(s)**: Handles specific types of exceptions that might be thrown within the try block. There can be multiple catch blocks to handle different exception types.
- **```finally``` block**: Contains code that is guaranteed to execute, regardless of whether an exception is thrown or caught.

**Execution Flow**

The execution flow within a try-catch-finally block can be summarized as follows:

- The code within the try block is executed.
- If an exception occurs within the try block:
  - The JVM searches for a matching catch block to handle the exception.
  - If a matching catch block is found, the code within that catch block is executed.
  - After the catch block (or if no exception occurred), the code within the finally block is executed.
  - If no matching catch block is found, the finally block is executed, and then the exception is propagated up the call stack.
- If no exception occurs within the try block, the code within the finally block is executed after the try block completes.

**Key Characteristics**

- **Always Executes**: The code in the finally block is always executed, except in very rare circumstances (e.g., the JVM crashes or System.exit() is called).
- **Cleanup Operations**: It's primarily used for releasing resources, closing connections, and performing other cleanup tasks.
- **Optional**: The finally block is optional. You can have a try-catch block without a finally block, or a try-finally block without any catch blocks (though this is less common).
- **Order of Execution**: The finally block is executed after the try block completes normally or after a catch block handles an exception.

#### <a name="chapter7part3.2"></a>Chapter 7 - Part 3.2: Practical Examples of Using finally

**Example 1: Closing a File**

One of the most common uses of the finally block is to ensure that files are closed properly, even if an error occurs while reading or writing to them.

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class FinallyExample {

    public static void main(String[] args) {
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader("example.txt")); // Assume example.txt exists
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
                // Simulate an exception occurring during reading
                if (line.contains("error")) {
                    throw new IOException("Simulated error while reading the file.");
                }
            }
        } catch (IOException e) {
            System.err.println("An IOException occurred: " + e.getMessage());
        } finally {
            try {
                if (reader != null) {
                    reader.close();
                    System.out.println("File reader closed in finally block.");
                }
            } catch (IOException e) {
                System.err.println("Error closing the file: " + e.getMessage());
            }
        }
    }
}
```

In this example:

- A BufferedReader is used to read from a file.
- The try block attempts to read the file line by line.
- An IOException is caught if any error occurs during file reading.
- The finally block ensures that the BufferedReader is closed, regardless of whether an exception was thrown or caught. This prevents resource leaks.
- Note the nested try-catch within the finally block. This is important because the close() method itself can throw an IOException, and we want to handle that possibility without preventing the finally block from completing.

**Example 2: Releasing Database Connections**

Another common use case is releasing database connections. Database connections are a limited resource, and it's crucial to release them when they are no longer needed.

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

public class DatabaseFinallyExample {

    public static void main(String[] args) {
        Connection connection = null;
        Statement statement = null;
        try {
            // Replace with your database URL, username, and password
            String url = "jdbc:mysql://localhost:3306/mydatabase";
            String user = "myuser";
            String password = "mypassword";

            connection = DriverManager.getConnection(url, user, password);
            statement = connection.createStatement();

            // Execute a query
            String sql = "SELECT * FROM users";
            statement.execute(sql);

            // Simulate an exception
            //throw new SQLException("Simulated SQL exception");

        } catch (SQLException e) {
            System.err.println("A SQLException occurred: " + e.getMessage());
        } finally {
            try {
                if (statement != null) {
                    statement.close();
                    System.out.println("Statement closed in finally block.");
                }
                if (connection != null) {
                    connection.close();
                    System.out.println("Connection closed in finally block.");
                }
            } catch (SQLException e) {
                System.err.println("Error closing connection or statement: " + e.getMessage());
            }
        }
    }
}
```

In this example:

- A database connection is established within the try block.
- A Statement is created to execute SQL queries.
- The finally block ensures that both the Statement and the Connection are closed, regardless of whether an SQLException is thrown or caught.
- Again, nested try-catch blocks are used within the finally block to handle potential SQLExceptions during the closing of the resources.

**Example 3: Handling Resources in a Method**

The finally block is also useful when dealing with resources within a method that might throw exceptions.

```java
public class MethodFinallyExample {

    public static String processData() {
        StringBuilder result = new StringBuilder();
        try {
            result.append("Data processing started.\n");
            // Simulate some data processing
            result.append("Data processed successfully.\n");
            // Simulate a potential error
            //throw new RuntimeException("Simulated processing error.");
            return result.toString(); // Return the result if no exception occurs
        } catch (RuntimeException e) {
            result.append("Error during processing: ").append(e.getMessage()).append("\n");
            return result.toString(); // Return the result with the error message
        } finally {
            result.append("Data processing completed (finally block).\n");
            // Note: Returning from the finally block is generally discouraged
            // as it can override returns from try or catch blocks.
        }
    }

    public static void main(String[] args) {
        String output = processData();
        System.out.println(output);
    }
}
```

In this example:

- The processData() method simulates some data processing.
- A RuntimeException is caught if any error occurs during processing.
- The finally block appends a message indicating that data processing is completed, regardless of whether an exception was thrown or caught.

- **Important Note**: While this example demonstrates the execution of the finally block, returning a value from within a finally block is generally discouraged. If a return statement is present in both the try or catch block and the finally block, the return statement in the finally block will override the return statement in the try or catch block. This can lead to unexpected behavior and make debugging difficult.

#### <a name="chapter7part3.3"></a>Chapter 7 - Part 3.3: Best Practices and Considerations

- **Resource Management**: Always use the finally block to release resources such as file handles, database connections, and network sockets.
- **Avoid Returning from finally**: As mentioned earlier, avoid returning values from within a finally block, as it can override return values from try or catch blocks.
- **Nested try-catch**: Use nested try-catch blocks within the finally block to handle exceptions that might be thrown by the cleanup code itself (e.g., when closing a file).
- **try-with-resources**: In Java 7 and later, the try-with-resources statement provides a more concise and safer way to manage resources. It automatically closes resources that implement the AutoCloseable interface, eliminating the need for a finally block in many cases. We will cover this in a later lesson.
- **Logging**: Consider adding logging statements within the finally block to track resource release and cleanup operations. This can be helpful for debugging and auditing purposes.

#### <a name="chapter7part3.4"></a>Chapter 7 - Part 3.4: Exercises

#### <a name="chapter7part4"></a>Chapter 7 - Part 4: Common Exception Types: NullPointerException, ArrayIndexOutOfBoundsException

#### <a name="chapter7part4.1"></a>Chapter 7 - Part 4.1: Understanding Exceptions

#### <a name="chapter7part4.2"></a>Chapter 7 - Part 4.2: The NullPointerException

#### <a name="chapter7part4.3"></a>Chapter 7 - Part 4.3: The ArrayIndexOutOfBoundsException

#### <a name="chapter7part4.4"></a>Chapter 7 - Part 4.4: Exercises

#### <a name="chapter7part4.5"></a>Chapter 7 - Part 4.5: Summary

#### <a name="chapter7part5"></a>Chapter 7 - Part 5: Custom Exceptions

#### <a name="chapter7part5.1"></a>Chapter 7 - Part 5.1: What is Custom Exception

#### <a name="chapter7part5.2"></a>Chapter 7 - Part 5.2: Creating Custom Exceptions

#### <a name="chapter7part6"></a>Chapter 7 - Part 6: Reading Input from the Console: Using the `Scanner` Class

#### <a name="chapter7part6.1"></a>Chapter 7 - Part 6.1: Introduction to the Scanner Class

#### <a name="chapter7part6.2"></a>Chapter 7 - Part 6.2: Reading Different Data Types

#### <a name="chapter7part6.3"></a>Chapter 7 - Part 6.3: Handling Input Mismatch Exceptions

#### <a name="chapter7part6.4"></a>Chapter 7 - Part 6.4: Practical Examples and Demonstrations

#### <a name="chapter7part6.5"></a>Chapter 7 - Part 6.5: Exercises

#### <a name="chapter7part7"></a>Chapter 7 - Part 7: Writing Output to the Console: Using `System.out.println()`

#### <a name="chapter7part7.1"></a>Chapter 7 - Part 7.1: Understanding System.out.println()

#### <a name="chapter7part7.2"></a>Chapter 7 - Part 7.2: Practical Examples and Demonstrations

#### <a name="chapter7part7.3"></a>Chapter 7 - Part 7.3: Exercises

#### <a name="chapter7part7.4"></a>Chapter 7 - Part 7.4: Summary

#### <a name="chapter7part7.5"></a>Chapter 7 - Part 7.5: Next Steps

#### <a name="chapter7part8"></a>Chapter 7 - Part 8: Introduction to File Input/Output: Reading and Writing Text Files

#### <a name="chapter7part8.1"></a>Chapter 7 - Part 8.1: Understanding File Input/Output (I/O)

#### <a name="chapter7part8.2"></a>Chapter 7 - Part 8.2: Reading Text Files

#### <a name="chapter7part8.3"></a>Chapter 7 - Part 8.3: Writing Text Files

#### <a name="chapter7part8.4"></a>Chapter 7 - Part 8.4: Practice Activities

#### <a name="chapter7part8.5"></a>Chapter 7 - Part 8.5: Summary

## <a name="chapter8"></a>Chapter 8: Java Date and Time

#### <a name="chapter8part1"></a>Chapter 8 - Part 1: Java Date and Time

**Java Dates**

Java does not have a built-in Date class, but we can import the ```java.time``` package to work with the date and time API. The package includes many date and time classes. For example:

| Class             | Description                                                             |
| :----------------:| :----------------------------------------------------------------------:|
| LocalDate         | Represents a date (year, month, day (yyyy-MM-dd))                       |
| LocalTime         | Represents a time (hour, minute, second and nanoseconds (HH-mm-ss-ns))  |
| LocalDateTime     | Represents both a date and a time (yyyy-MM-dd-HH-mm-ss-ns)              | 
| DateTimeFormatter | Formatter for displaying and parsing date-time objects                  | 

**Display Current Date**

To display the current date, import the ```java.time.LocalDate``` class, and use its ```now()``` method:

```java

import java.time.LocalDate; // import the LocalDate class

public class Main {
  public static void main(String[] args) {
    LocalDate myObj = LocalDate.now(); // Create a date object
    System.out.println(myObj); // Display the current date //2022-11-04 
  }
}

**Display Current Time**

To display the current time (hour, minute, second, and nanoseconds), import the ```java.time.LocalTime``` class, and use its ```now()``` method:

```java

import java.time.LocalTime; // import the LocalTime class

public class Main {
  public static void main(String[] args) {
    LocalTime myObj = LocalTime.now();
    System.out.println(myObj); //14:30:40.994046 
  }
}

```

**Display Current Date and Time**

To display the current date and time, import the ```java.time.LocalDateTime class```, and use its ```now()``` method:

```java

import java.time.LocalDateTime; // import the LocalDateTime class

public class Main {
  public static void main(String[] args) {
    LocalDateTime myObj = LocalDateTime.now();
    System.out.println(myObj); //2022-11-04T14:30:40.994110 
  }
}

```

**Formatting Date and Time**

The "T" in the example above is used to separate the date from the time. You can use the ```DateTimeFormatter``` class with the ```ofPattern()``` method in the same package to format or parse date-time objects. The following example will remove both the "T" and nanoseconds from the date-time:

```java

import java.time.LocalDateTime; // Import the LocalDateTime class
import java.time.format.DateTimeFormatter; // Import the DateTimeFormatter class

public class Main {
  public static void main(String[] args) {
    LocalDateTime myDateObj = LocalDateTime.now();
    System.out.println("Before formatting: " + myDateObj); //Before Formatting: 2022-11-04T14:30:40.995494 
    DateTimeFormatter myFormatObj = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss");

    String formattedDate = myDateObj.format(myFormatObj);
    System.out.println("After formatting: " + formattedDate); //After Formatting: 04-11-2022 14:30:40 
  }
}

```

The ```ofPattern()``` method accepts all sorts of values, if you want to display the date and time in a different format. For example:

| Value          | Example            |
| :-------------:| :-----------------:|
| yyyy-MM-dd     | "1988-09-29"       |
| dd/MM/yyyy     | "29/09/1988"       |
| dd-MMM-yyyy    | "29-Sep-1988"      | 
| E, MMM dd yyyy | "Thu, Sep 29 1988" |

## <a name="chapter9"></a>Chapter 9: Java Enums

#### <a name="chapter9part1"></a>Chapter 9 - Part 1: Java Enums

It is a special type that serves to literally specify a set of related constants

Keyword in Java: ```enum```

Advantage: better semantics, more readable code and supported by compiler

Example: life cycle of a request.

```java

package entities.enums;

public enum OrderStatus {

	PENDING_PAYMENT,
	PROCESSING,
	SHIPPED,
	DELIVERED;
}

```

```java

package entities;

import java.util.Date;

import entities.enums.OrderStatus;

public class Order {

	private Integer id;
	private Date moment;
	private OrderStatus status;
	
	public Order() {
	}

	public Order(Integer id, Date moment, OrderStatus status) {
		this.id = id;
		this.moment = moment;
		this.status = status;
	}

	public Integer getId() {
		return id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public Date getMoment() {
		return moment;
	}

	public void setMoment(Date moment) {
		this.moment = moment;
	}

	public OrderStatus getStatus() {
		return status;
	}

	public void setStatus(OrderStatus status) {
		this.status = status;
	}

	@Override
	public String toString() {
		return "Order [id=" + id + ", moment=" + moment + ", status=" + status + "]";
	}
}

```

```java

package application;

import java.util.Date;

import entities.Order;
import entities.enums.OrderStatus;

public class Program {

	public static void main(String[] args) {

		Order order = new Order(1080, new Date(), OrderStatus.PENDING_PAYMENT);
		
		System.out.println(order);
		
		OrderStatus os1 = OrderStatus.DELIVERED;
		
		OrderStatus os2 = OrderStatus.valueOf("DELIVERED");
		
		System.out.println(os1);
		System.out.println(os2);
	}
}

```

**Convertion String to enum**

```java

OrderStatus os1 = OrderStatus.DELIVERED;

OrderStatus os2 = OrderStatus.valueOf("DELIVERED");

```

UML Annotation

<br>

<div align="center"><img src="img/enum-w797-h251.png" width=428 height=179><br><sub>Fig 39 - Enum UML representation - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>


## <a name="chapter10"></a>Chapter 10: Reference Type vs. Value Types, Garbage Collector, Boxing, unboxing and wrapper classes

#### <a name="chapter8part1"></a>Chapter 10 - Part 1: Reference Type vs. Value Types

Java provides two types of data types **primitive** and **reference** data type. The **primitive data types (value type)** are predefined in Java that serves as a fundamental building block while the **reference** data type refers to where data is stored.

<br>

<div align="center"><img src="img/data-types-w8000-h4500.png" width=600 height=350><br><sub>Fig 13 -Java Data Types - (<a href='https://getkt.com/blog/reintroduction-to-java-data-types/'>Work by neotam</a>) </sub></div>

<br>

**Reference types**

In Java, **non-primitive** data types are known as **reference types**. In other words, a variable of class type is called **reference data type**. It contains the address (or reference) of dynamically created objects. For example, if **Demo** is a class and we have created its object **d**, then the variable d is known as a reference type.

It refers to objects. It is not pre-defined. It is created by the programmer if required. The reference types hold the references of objects. All **reference types** are a subclass of type **java.lang.Object**. It provides access to the objects stored in the memory.

Example: In the example above the p2 variable refence the memory address where p1 was created.

```java

Product p1, p2;
p1 = new Product("TV", 900.00, 0);
p2 = p1;

```

<br>

<div align="center"><img src="img/referency_memory-w681-h362.png" width=681 height=362><br><sub>Fig 34 -Referency Types - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by Nelio Alves</a>) </sub></div>

<br>

The default values when we use ```new``` in Class and Arrays is:

- Numbers: 0
- boolean: false
- char: 0 code
- object: null

Reference type alow "null" value. This means they not reference any body.

**Primitive types**

In Java, primitive types is value types.

Example: y receive a copy of x

```java

double x, y;
x = 10;
y = x;

```

The primitive types needs a value to initiate:

```java

int p;
System.out.println(p); // error: variable not initiated

p = 10;
System.out.println(p);

```

<br>

<div align="center"><img src="img/primitive_memory-w641-h378.png" width=641 height=378><br><sub>Fig 35 -Primitive Types - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by Nelio Alves</a>) </sub></div>

<br>

<br>

<div align="center"><img src="img/data-types2-w1920-h1080.jpg" width=600 height=300><br><sub>Fig 14 -Java Data Primitive Types - (<a href='https://getkt.com/blog/reintroduction-to-java-data-types/'>Work by neotam</a>) </sub></div>

<br>

| Reference Type                                                                 | Primitive Type                                                         |
| :-----------------------------------------------------------------------------:| :---------------------------------------------------------------------:|
| It is not pre-defined except the String.                                       | It is pre-defined in Java.                                             |
| All reference type begins with Uppercase letter.                               | All primitive type begins with a lowercase letter.                     | 
| Non-primitive types have all the same size.                                    | The size of a primitive type depends on the data type.                 |
| It is used to invoke or call methods.                                          | We cannot invoke the method with a primitive type.                     |
| It can be null.                                                                | It cannot be null. It always has value.                                |
| Examples of reference data types are class, Arrays, String, Interface, etc.    | Examples of primitive data types are int, float, double, Boolean, long.|
| JVM allocates 8 bytes for each reference variable, by default.                 | Its size depends on the data type.                                     |
| **Example**: Demo d1;                                                          | **Example**: int num=78;                                               |
| Advantage: enjoys all OO features                                              | Advantage: it is simpler and more performant                           |
| Objects must be instantiated using new, or point to an existing object.        | Does not instantiate. Once declared, they are ready for use.           |
| Accepts null value                                                             | Does not accept null value                                             |
| Y = X; "Y starts pointing to where X points Y = X;                             | Y = X; "Y receives a copy of X"                                        |
| Objects instantiated on the heap                                               | "Objects" instantiated on the stack                                    |
| Unused objects are deallocated in a close moment by garbage collector          | "Objects" are deallocated immediately when your execution scope is terminated   |

#### <a name="chapter8part2"></a>Chapter 10 - Part 2: Garbage Collector

In Java, the ```new``` keyword is used to create an **instance** of the class. In other words, it instantiates a class by allocating **memory** for a new object and returning a reference to that memory. Objects occupy memory in the **Java heap space**. We can also use the ```new``` keyword to create the array object.

```java

ClassName objectName = new ClassName();  

```

If there are no references to an object, the memory used by that object can be reclaimed during the garbage collection process.

**Garbage Collector

It is a process that automates the memory management of a program running

Garbage collector monitors dynamically allocated objects by the program (on the heap), deallocating those that are no longer being used.

In java, garbage means unreferenced objects.

Garbage Collection is process of reclaiming the runtime unused memory automatically. In other words, it is a way to destroy the unused objects.

To do so, we were using free() function in C language and delete() in C++. But, in java it is performed automatically. So, java provides better memory management.

**Advantage of Garbage Collection**

- It makes java memory efficient because garbage collector removes the unreferenced objects from heap memory.

- It is automatically done by the garbage collector(a part of JVM) so we don't need to make extra efforts.

**How can an object be unreferenced?**

- By nulling the reference

```java

    Employee e=new Employee();  
    e=null;  

```

- By assigning a reference to another

```java

    Employee e1=new Employee();  
    Employee e2=new Employee();  
    e1=e2;//now the first object referred by e1 is available for garbage collection  

```

- By anonymous object etc.

```java

    new Employee();  

```

**finalize() method**

The finalize() method is invoked each time before the object is garbage collected. This method can be used to perform cleanup processing. This method is defined in Object class as:

```java

    protected void finalize(){}  

```

OBS: The Garbage collector of JVM collects only those objects that are created by new keyword. So if you have created any object without new, you can use finalize method to perform cleanup processing (destroying remaining objects).

**gc() method**

The gc() method is used to invoke the garbage collector to perform cleanup processing. The gc() is found in System and Runtime classes. 

```java

    public static void gc(){}  

```

OBS: Garbage collection is performed by a daemon thread called Garbage Collector(GC). This thread calls the finalize() method before object is garbage collected.

```java

    public class TestGarbage1{  
     public void finalize(){System.out.println("object is garbage collected");}  
     public static void main(String args[]){  
      TestGarbage1 s1=new TestGarbage1();  
      TestGarbage1 s2=new TestGarbage1();  
      s1=null;  
      s2=null;  
      System.gc();  
     }  
    }  
    
    //object is garbage collected
    //object is garbage collected

```

#### <a name="chapter8part3"></a>Chapter 10 - Part 3:  Boxing, unboxing and wrapper classes

**Boxing**

It is the process of converting a value type object to an object compatible reference type

```java

int x = 20;

Object obj = x;

```

**Unboxing**

It is the process of converting a reference-type object to a object type compatible value

```java

int x = 20;

Object obj = x;

int y = (int) obj;

```

**Comparing Reference Type**

Reference types are comparable in Java. Equality operators and the equals method can be used to assist with comparisons.

- Using the Equality Operators ```(==)```

The ```!=``` and ```==``` equality operators are used to compare the memory locations of two objects. If the memory addresses of the objects being compared are the same, the objects are considered equal. These equality operators are not used to compare the contents of two objects.

```java

String guest1 = new String("name");
String guest2 = guest1;
if (guest1 == guest2)
  System.out.println("They are equal");

```

In the following example, the memory addresses are not equal, so the statement "They are not equal" is output:

```java

String guest1 = new String("name");
String guest2 = new String("name");
if (guest1 != guest2)
  System.out.println("They are not equal");


```

- Using the ```equals()``` Method

To compare the contents of two class objects, the ```equals()``` method from class ```Object``` can be used or overridden. When the ```equals()``` method is overridden, the ```hashCode()``` method should also be overridden. This is done for compatibility with hash-based collections such as ```HashMap()``` and ```HashSet()```.

By default, the ```equals()``` method uses only the ```==``` operator for comparisons. This method has to be overridden to really be useful.

For example, if you want to compare values contained in two instances of the same class, you should use a programmer-defined equals() method.

**Comparing Strings**

There are two ways to check whether strings are equal in Java, but the definition of “equal” for each of them is different:

- The ```equals()``` method compares two strings, character by character, to determine equality. This is not the default implementation of the ```equals()``` method provided by the Object class. This is the overridden implementation provided by String class.

- The ```==``` operator checks to see whether two object references refer to the same instance of an object.

Here is a program that shows how strings are evaluated using the ```equals()``` method and the ```==``` operator

```java

class MyComparisons {

  // Add string to pool
  String first = "chairs";
  // Use string from pool
  String second = "chairs";
  // Create a new string
  String third = new String ("chairs");

 void myMethod() {

  /*
   * Contrary to popular belief, this evaluates
   * to true. Try it!
   */
  if (first == second) {
    System.out.println("first == second");
  }

  // This evaluates to true
  if (first.equals(second)) {
    System.out.println("first equals second");
  }
  // This evaluates to false
  if (first == third) {
    System.out.println("first == third");
  }
  // This evaluates to true
  if (first.equals(third)) {
    System.out.println("first equals third");
  }
 } // End myMethod()
} //end class

```


**Wrapper Classes**

These are classes that are equivalent to primitive types.

Boxing and unboxing is done automaticaly

Common usage: Entity fields in information systems (IMPORTANT!)
Because reference types (classes) accept null value and take advantage of Object Oriented resources

<br>

<div align="center"><img src="img/wrapper_classes-w541-h251.png" width=541 height=251><br><sub>Fig 37 - Wrapper Classes - (<a href='https://www.javatpoint.com/collections-in-java'>Work by  Java T Point</a>) </sub></div>

<br>

#### <a name="chapter8part4"></a>Chapter 10 - Part 4:  hashCode and equals

**hashCode and equals**

- They are operations of the Object class used to compare if an object is the same as another
- equals: slow, 100% response
- hashCode: fast, but positive response is not 100%
- Common types (String, Date, Integer, Double, etc.) already have implementation for these operations. custom classes need to overlay them.

**Equals**

- Method that compares if the object is equal to another, returning true or false.

```java

String a = "Maria";
String b = "Alex";

System.out.println(a.equals(b)); //false

```

```java

String a = "Maria";
String b = "Naria";

System.out.println(a.equals(b)); //true

```

**HashCode**

- Method that returns an integer representing a generated code from object information

```java

String a = "Maria";
String b = "Alex";

System.out.println(a.hashCode()); //74113750
System.out.println(b.hashCode()); //2043454

```

```java

String a = "Maria";
String b = "Maria";

System.out.println(a.hashCode()); //74113750
System.out.println(b.hashCode()); //74113750

```

If the hashCode of two objects is different, then the two objects are many different

If the code of two objects is the same, most likely the objects they are the same


## <a name="chapter14"></a>Chapter 11: Java Interfaces

#### <a name="chapter11part1"></a>Chapter 11 - Part 1: Java Interfaces

As of Java 8, interfaces can have "default methods" or "defend methods"

Interface is a type that defines a set of operations that a class must implement.

The interface establishes a contract that the class must comply with.

- For what interfaces?
  - To create loosely coupled and flexible systems.

```java

interface Shape {
	double area();
	double perimeter();
}

```

Another way to achieve **abstraction** in Java, is with interfaces.

An ```interface``` is a completely **"abstract class"** that is used to group related methods with empty bodies:

```java

// interface
interface Animal {
  public void animalSound(); // interface method (does not have a body)
  public void run(); // interface method (does not have a body)
}

```

To access the interface methods, the interface must be "implemented" (kinda like inherited) by another class with the ```implements``` keyword (instead of ```extends```). The body of the interface method is provided by the "implement" class:

```java

// Interface
interface Animal {
  public void animalSound(); // interface method (does not have a body)
  public void sleep(); // interface method (does not have a body)
}

// Pig "implements" the Animal interface
class Pig implements Animal {
  public void animalSound() {
    // The body of animalSound() is provided here
    System.out.println("The pig says: wee wee");
  }
  public void sleep() {
    // The body of sleep() is provided here
    System.out.println("Zzz");
  }
}

class Main {
  public static void main(String[] args) {
    Pig myPig = new Pig();  // Create a Pig object
    myPig.animalSound();
    myPig.sleep();
  }
}

```

Notes on Interfaces:

- Like abstract classes, interfaces cannot be used to create objects (in the example above, it is not possible to create an "Animal" object in the MyMainClass)
- Interface methods do not have a body - the body is provided by the "implement" class
- On implementation of an interface, you must override all of its methods
- Interface methods are by default ```abstract``` and ```public```
- Interface attributes are by default ```public```, ```static``` and ```final```
- An interface cannot contain a constructor (as it cannot be used to create objects)

Why And When To Use Interfaces?

1) To achieve security - hide certain details and only show the important details of an object (interface).

2) Java does not support "multiple inheritance" (a class can only inherit from one superclass). However, it can be achieved with interfaces, because the class can **implement** multiple interfaces. **Note**: To implement multiple interfaces, separate them with a comma (see example below).

**Multiple Interfaces**

To implement multiple interfaces, separate them with a comma:

```java

interface FirstInterface {
  public void myMethod(); // interface method
}

interface SecondInterface {
  public void myOtherMethod(); // interface method
}

class DemoClass implements FirstInterface, SecondInterface {
  public void myMethod() {
    System.out.println("Some text..");
  }
  public void myOtherMethod() {
    System.out.println("Some other text...");
  }
}

class Main {
  public static void main(String[] args) {
    DemoClass myObj = new DemoClass();
    myObj.myMethod();
    myObj.myOtherMethod();
  }
}

```

Exercise: A Brazilian car rental company charges an hourly rate for rentals of up to 12 hours. However, if the duration of the lease exceeds 12 hours, the lease will be charged based on a daily rate. In addition to the lease amount, it is added to the price the tax amount according to the country's rules which, in the case of Brazil, is 20% for values up to 100.00, or 15% for values above 100.00. Make one program that reads the lease data (car model, start and end time of lease), as well as the hourly rate and the daily rental rate. The program must then generate the payment note (containing lease amount, tax and total payment amount) and enter the data on the screen. see the examples.

<br>

<div align="center"><img src="img/interfaces1-w494-h669.png" width=494 height=669><br><sub>Fig 40 - Exercise Interface - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Class CarRental

```java

package model.entities;

import java.time.LocalDateTime;

public class CarRental {

	private LocalDateTime start;
	private LocalDateTime finish;
	
	private Vehicle vehicle;
	private Invoice invoice;
	
	public CarRental() {
	}

	public CarRental(LocalDateTime start, LocalDateTime finish, Vehicle vehicle) {
		this.start = start;
		this.finish = finish;
		this.vehicle = vehicle;
	}

	public LocalDateTime getStart() {
		return start;
	}

	public void setStart(LocalDateTime start) {
		this.start = start;
	}

	public LocalDateTime getFinish() {
		return finish;
	}

	public void setFinish(LocalDateTime finish) {
		this.finish = finish;
	}

	public Vehicle getVehicle() {
		return vehicle;
	}

	public void setVehicle(Vehicle vehicle) {
		this.vehicle = vehicle;
	}

	public Invoice getInvoice() {
		return invoice;
	}

	public void setInvoice(Invoice invoice) {
		this.invoice = invoice;
	}
}

```

Class Invoice

```java

package model.entities;

public class Invoice {

	private Double basicPayment;
	private Double tax;
	
	public Invoice() {
	}

	public Invoice(Double basicPayment, Double tax) {
		this.basicPayment = basicPayment;
		this.tax = tax;
	}

	public Double getBasicPayment() {
		return basicPayment;
	}

	public void setBasicPayment(Double basicPayment) {
		this.basicPayment = basicPayment;
	}

	public Double getTax() {
		return tax;
	}

	public void setTax(Double tax) {
		this.tax = tax;
	}
	
	public Double getTotalPayment() {
		return getBasicPayment() + getTax();
	}
}

```

Class Vehicle

```java

package model.entities;

public class Vehicle {

	private String model;
	
	public Vehicle() {
	}

	public Vehicle(String model) {
		this.model = model;
	}

	public String getModel() {
		return model;
	}

	public void setModel(String model) {
		this.model = model;
	}
}

```

Class RentalService

```java

package model.services;

import java.time.Duration;

import model.entities.CarRental;
import model.entities.Invoice;

public class RentalService {

	private Double pricePerDay;
	private Double pricePerHour;
	
	private TaxService taxService;

	public RentalService(Double pricePerDay, Double pricePerHour, TaxService taxService) {
		this.pricePerDay = pricePerDay;
		this.pricePerHour = pricePerHour;
		this.taxService = taxService;
	}
	
	public void processInvoice(CarRental carRental) {
		
		double minutes = Duration.between(carRental.getStart(), carRental.getFinish()).toMinutes();		
		double hours = minutes / 60.0;
		
		double basicPayment;
		if (hours <= 12.0) {
			basicPayment = pricePerHour * Math.ceil(hours);
		}
		else {
			basicPayment = pricePerDay * Math.ceil(hours / 24);
		}

		double tax = taxService.tax(basicPayment);

		carRental.setInvoice(new Invoice(basicPayment, tax));
	}
}

```

Class TaxService

```java

package model.services;

public interface TaxService {

	double tax(double amount);
}

```

Class BrazilTaxService

```java

package model.services;

public class BrazilTaxService implements TaxService {

	public double tax(double amount) {
		if (amount <= 100.0) {
			return amount * 0.2;
		}
		else {
			return amount * 0.15;
		}
	}
}

```

<br>

<div align="center"><img src="img/interfaces2-w636-h869.png" width=636 height=869><br><sub>Fig 40 - Exercise Interface - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Program

```java

package application;

import java.text.ParseException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.Locale;
import java.util.Scanner;

import model.entities.CarRental;
import model.entities.Vehicle;
import model.services.BrazilTaxService;
import model.services.RentalService;

public class Program {

	public static void main(String[] args) throws ParseException {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		DateTimeFormatter fmt =  DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
		
		System.out.println("Entre com os dados do aluguel");
		System.out.print("Modelo do carro: ");
		String carModel = sc.nextLine();
		System.out.print("Retirada (dd/MM/yyyy HH:mm): ");
		LocalDateTime start = LocalDateTime.parse(sc.nextLine(), fmt);
		System.out.print("Retorno (dd/MM/yyyy HH:mm): ");
		LocalDateTime finish = LocalDateTime.parse(sc.nextLine(), fmt);
		
		CarRental cr = new CarRental(start, finish, new Vehicle(carModel));

		System.out.print("Entre com o preço por hora: ");
		double pricePerHour = sc.nextDouble();
		System.out.print("Entre com o preço por dia: ");
		double pricePerDay = sc.nextDouble();
		
		RentalService rentalService = new RentalService(pricePerDay, pricePerHour, new BrazilTaxService());
		
		rentalService.processInvoice(cr);

		System.out.println("FATURA:");
		System.out.println("Pagamento basico: " + String.format("%.2f", cr.getInvoice().getBasicPayment()));
		System.out.println("Imposto: " + String.format("%.2f", cr.getInvoice().getTax()));
		System.out.println("Pagamento total: " + String.format("%.2f", cr.getInvoice().getTotalPayment()));
		
		sc.close();
	}
}

```

#### <a name="chapter11part2"></a>Chapter 11 - Part 2: Dependency Injection and Inversion of Control

When we have a direct association we have:
- Strong Coupling
- The RentalService class knows the concrete dependency
- If the concrete class changes, you need to change the RentalService class

<br>

<div align="center"><img src="img/interfaces3-w792-h366.png" width=792 height=366><br><sub>Fig 40 - Interfaces - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

When we implement a interface in our solution:
- weak coupling
- The RentalService class doesn't know the concrete dependency
- If the concrete class changes, the RentalService class doesn't change anything

<br>

<div align="center"><img src="img/interfaces4-w903-h410.png" width=903 height=410><br><sub>Fig 40 - Interfaces - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

**Dependency injection via constructor**

<br>

<div align="center"><img src="img/interfaces5-w1052-h449.png" width=1052 height=449><br><sub>Fig 40 - Interfaces - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

**Inversion of control**
- Development pattern that consists of removing from class a responsibility to instantiate your dependencies. The Class RentalService don't have to instanciate the type of TaxService, just the abstraction, Tax Service

**dependency injection**
- It is a way of performing inversion of control: an external component instantiates the dependency (In the exercise, the main Program, which is then injected into the "parent" object (The Parent was the RentalService). It might be implemented in several ways:
  - Constructor
  - Instantiation class (builder/factory)
  - Container / framework

#### <a name="chapter11part3"></a>Chapter 11 - Part 3: Inheritance vs Interfaces

**Common aspects between inheritance and interfaces**

- relationship is-one
- generalization/specialization
- Polymorphism

**Main Differences**

- inheritance = reuse (attributes and methods)
- interfaces = contract to be fulfilled

<br>

<div align="center"><img src="img/interfaces6-w952-h310.png" width=952 height=310><br><sub>Fig 40 - Interfaces - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

You can implement inheritance with interfaces, folow this case

Exercise: What if I need to implement Shape as an interface, but I also want to define a common reusable structure for all figures?

<br>

<div align="center"><img src="img/interfaces7-w993-h400.png" width=993 height=400><br><sub>Fig 40 - Interfaces - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Class Colour

```java

package model.enums;

public enum Color {
	BLACK,
	WHITE;
}

```

Class AbstractShape

```java

package model.entities;

import model.enums.Color;

public abstract class AbstractShape implements Shape {

	private Color color;

	public AbstractShape(Color color) {
		this.color = color;
	}

	public Color getColor() {
		return color;
	}

	public void setColor(Color color) {
		this.color = color;
	}
}

```

Class Shape

```java

package model.entities;

public interface Shape {

	double area();
}

```

Class Circle

```java

package model.entities;

import model.enums.Color;

public class Circle extends AbstractShape {

	private Double radius;

	public Circle(Color color, Double radius) {
		super(color);
		this.radius = radius;
	}

	public Double getRadius() {
		return radius;
	}

	public void setRadius(Double radius) {
		this.radius = radius;
	}

	@Override
	public double area() {
		return Math.PI * radius * radius;
	}
}

```

Class Rectangle

```java

package model.entities;

import model.enums.Color;

public class Rectangle extends AbstractShape {

	private Double width;
	private Double height;

	public Rectangle(Color color, Double width, Double height) {
		super(color);
		this.width = width;
		this.height = height;
	}

	public Double getWidth() {
		return width;
	}

	public void setWidth(Double width) {
		this.width = width;
	}

	public Double getHeight() {
		return height;
	}

	public void setHeight(Double height) {
		this.height = height;
	}

	@Override
	public double area() {
		return width * height;
	}
}

```

Program

```java

package application;

import model.entities.AbstractShape;
import model.entities.Circle;
import model.entities.Rectangle;
import model.enums.Color;

public class Program {

	public static void main(String[] args) {

		AbstractShape s1 = new Circle(Color.BLACK, 2.0);
		AbstractShape s2 = new Rectangle(Color.WHITE, 3.0, 4.0);
		
		System.out.println("Circle color: " + s1.getColor());
		System.out.println("Circle area: " + String.format("%.3f", s1.area()));
		System.out.println("Rectangle color: " + s2.getColor());
		System.out.println("Rectangle area: " + String.format("%.3f", s2.area()));
	}
}

```

#### <a name="chapter11part4"></a>Chapter 11 - Part 4: Multiple Inheritance and Interfaces

Multiple inheritance can generate the diamond problem: a ambiguity caused by existence of the same method in more than one superclass.

Multiple inheritance is not allowed in most languages!

<br>

<div align="center"><img src="img/interfaces8-w578-h443.png" width=578 height=443><br><sub>Fig 40 - Interfaces - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

**However, a class can implement more from an interface**

<br>

<div align="center"><img src="img/interfaces9-w633-h323.png" width=633 height=323><br><sub>Fig 40 - Interfaces - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

OBS: This is NOT multiple inheritance, because THERE IS NO REUSE in the relationship between ComboDevice and the Scanner and Printer interfaces. ComboDevide does not inherit, but yes implements the interfaces (fulfills the contract).

Class Device

```java

package devices;

public abstract class Device {

	public String serialNumber;

	public Device(String serialNumber) {
		this.serialNumber = serialNumber;
	}
	
	public String getSerialNumber() {
		return serialNumber;
	}

	public void setSerialNumber(String serialNumber) {
		this.serialNumber = serialNumber;
	}

	public abstract void processDoc(String doc);
}

```

Class ComboDevice

```java

package devices;

public class ComboDevice extends Device implements Scanner, Printer {

	public ComboDevice(String serialNumber) {
		super(serialNumber);
	}

	@Override
	public void print(String doc) {
		System.out.println("Combo printing: " + doc);
	}

	@Override
	public String scan() {
		return "Combo scan result";
	}

	@Override
	public void processDoc(String doc) {
		System.out.println("Combo processing: " + doc);
	}
}

```

Class Printer

```java

package devices;

public interface Printer {

	void print(String doc);
}

```

Class Scanner

```java

package devices;

public interface Scanner {

	String scan();
}

```

Class ConcretePrinter

```Java

package devices;

public class ConcretePrinter extends Device implements Printer {

	public ConcretePrinter(String serialNumber) {
		super(serialNumber);
	}

	@Override
	public void processDoc(String doc) {
		System.out.println("Printer processing: " + doc);
	}

	@Override
	public void print(String doc) {
		System.out.println("Printing: " + doc);
	}
}

```

Class ConcreteScanner

```java

package devices;

public class ConcreteScanner extends Device implements Scanner {

	public ConcreteScanner(String serialNumber) {
		super(serialNumber);
	}

	@Override
	public void processDoc(String doc) {
		System.out.println("Scanner processing: " + doc);
	}

	@Override
	public String scan() {
		return "Scanned content";
	}
}

```

Program

```java

package application;

import devices.ComboDevice;
import devices.ConcretePrinter;
import devices.ConcreteScanner;

public class Program {

	public static void main(String[] args) {

		ConcretePrinter p = new ConcretePrinter("1080");
		p.processDoc("My Letter");
		p.print("My Letter");

		System.out.println();
		ConcreteScanner s = new ConcreteScanner("2003");
		s.processDoc("My Email");
		System.out.println("Scan result: " + s.scan());
		
		System.out.println();
		ComboDevice c = new ComboDevice("2081");
		c.processDoc("My dissertation");
		c.print("My dissertation");
		System.out.println("Scan result: " + c.scan());
	}
}

```

#### <a name="chapter11part5"></a>Chapter 11 - Part 5: Comparable Interface

The Comparable interface is used to compare an object of the same class with an instance of that class, it provides ordering of data for objects of the user-defined class. The class has to implement the java.lang.Comparable interface to compare its instance, it provides the compareTo method that takes a parameter of the object of that class.

Example: Write a program to read a file containing names of people (one name per line), storing them in a list. Then sort the data in this list and show them neatly on the screen. Note: the file path can be informed "hardcode".

Maria Brown
Alex Green
Bob Grey
Anna White
Alex Black
Eduardo Rose
Willian Red
Marta Blue
Alex Brown

```java

package hello;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Program {
	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
		String path = "C:\\temp\\in.txt";
		try (BufferedReader br = new BufferedReader(new FileReader(path))) {
			String name = br.readLine();
			while (name != null) {
				list.add(name);
				name = br.readLine();
			}
			Collections.sort(list);
			for (String s : list) {
				System.out.println(s);
			}
		} catch (IOException e) {
			System.out.println("Error: " + e.getMessage());
		}
	}
}


/*

output

Alex Black
Alex Brown
Alex Green
Anna White
Bob Grey
Eduardo Rose
Maria Brown
Marta Blue
Willian Red

*/

```

Example:  Make a program to read a file containing employees (name and salary) in the .csv format, storing them in a list. Then sort the list by name and show the result on the screen. Note: the file path can be informed "hardcode".

Maria Brown,4300.00
Alex Green,3100.00
Bob Grey,3100.00
Anna White,3500.00
Alex Black,2450.00
Eduardo Rose,4390.00
Willian Red,2900.00
Marta Blue,6100.00
Alex Brown,5000.00



```java

package hello;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import entities.Employee;

public class Program {
	public static void main(String[] args) {
		List<Employee> list = new ArrayList<>();
		String path = "C:\\temp\\in.txt";
		try (BufferedReader br = new BufferedReader(new FileReader(path))) {
			String employeeCsv = br.readLine();
			while (employeeCsv != null) {
				String[] fields = employeeCsv.split(",");
				list.add(new Employee(fields[0], Double.parseDouble(fields[1])));
				employeeCsv = br.readLine();
			}
			Collections.sort(list);
			for (Employee emp : list) {
				System.out.println(emp.getName() + ", " + emp.getSalary());
			}
		} catch (IOException e) {
			System.out.println("Error: " + e.getMessage());
		}
	}
}

/*
 * 
 * output
 * 
Alex Black, 2450.0
Alex Brown, 5000.0
Alex Green, 3100.0
Anna White, 3500.0
Bob Grey, 3100.0
Eduardo Rose, 4390.0
Maria Brown, 4300.0
Marta Blue, 6100.0
Willian Red, 2900.0
 */

```

```java

package entities;

public class Employee implements Comparable<Employee> {
	private String name;
	private Double salary;

	public Employee(String name, Double salary) {
		this.name = name;
		this.salary = salary;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Double getSalary() {
		return salary;
	}

	public void setSalary(Double salary) {
		this.salary = salary;
	}

	@Override
	public int compareTo(Employee other) {
		return name.compareTo(other.getName()); //you are comparing with name with .getName(). If was salary, use .getSalary()
	}
}

```

**Using Comparable Interface**

- In this method, we are going to implement the Comparable interface from java.lang Package in the Pair class.
- The Comparable interface contains the method compareTo to decide the order of the elements.
- Override the compareTo method in the Pair class.
- Create an array of Pairs and populate the array.
- Use the Arrays.sort() function to sort the array.

**Example 1**

Given an array of Pairs consisting of two fields of type string and integer. you have to sort the array in ascending Lexicographical order and if two strings are the same sort it based on their integer value.

**Sample I/O:**

```

Input:  { {"abc", 3}, {"a", 4}, {"bc", 5}, {"a", 2} }
Output:  { {"a", 2}, {"a", 4}, {"abc", 3}, {"bc", 5} }

Input:  { {"efg", 1}, {"gfg", 1}, {"cba", 1}, {"zaa", 1} }
Output:  { {"cba", 1}, {"efg", 1}, {"gfg", 1}, {"zaa", 1} }

```

```java

import java.io.*;
import java.util.*;

class Pair implements Comparable<Pair> {
	String x;
	int y;

	public Pair(String x, int y)
	{
		this.x = x;
		this.y = y;
	}

	public String toString()
	{
		return "(" + x + "," + y + ")";
	}

	@Override public int compareTo(Pair a)
	{
		// if the string are not equal
		if (this.x.compareTo(a.x) != 0) {
			return this.x.compareTo(a.x);
		}
		else {
			// we compare int values
			// if the strings are equal
			return this.y - a.y;
		}
	}
}

public class GFG {
	public static void main(String[] args)
	{

		int n = 4;
		Pair arr[] = new Pair[n];

		arr[0] = new Pair("abc", 3);
		arr[1] = new Pair("a", 4);
		arr[2] = new Pair("bc", 5);
		arr[3] = new Pair("a", 2);

		// Sorting the array
		Arrays.sort(arr);

		// printing the
		// Pair array
		print(arr);
	}

	public static void print(Pair[] arr)
	{
		for (int i = 0; i < arr.length; i++) {
			System.out.println(arr[i]);
		}
	}
}

```

```
Before Sorting:
(abc, 3);
(a, 4);
(bc, 5);
(a, 2);

After Sorting:
(a,2)
(a,4)
(abc,3)
(bc,5)
```

Note: if two strings are the same then the comparison is done based on the value.

**Example 2**

Given an array of Pairs consisting of two strings with first and last names. you have to sort the array in ascending Lexicographical order of the first name and if two strings are the same sort it based on their last name.

**Sample I/O:**

```
Input:  { {"raj", "kashup"}, {"rahul", "singh"}, {"reshmi", "dubey"}, {"rahul", "jetli"} }
Output:  { {"rahul", "jetli"}, {"rahul", "singh"}, {"raj", "kashup"}, {"reshmi", "dubey"} }

Input:  { {"abc", "last"}, {"pklz", "yelp"}, {"rpng", "note"}, {"ppza", "xyz"} }
Output:  { {"abc", "last"}, {"pklz", "yelp"}, {"ppza", "xyz"}, {"rpng", "note"} }
```

```java


import java.io.*;
import java.util.*;
 
class Pair implements Comparable<Pair> {
    String firstName;
    String lastName;
 
    public Pair(String x, String y)
    {
        this.firstName = x;
        this.lastName = y;
    }
 
    public String toString()
    {
        return "( " + firstName + " , " + lastName + " )";
    }
 
    @Override public int compareTo(Pair a)
    {
        // if the string are not equal
        if (this.firstName.compareTo(a.firstName) != 0) {
            return this.firstName.compareTo(a.firstName);
        }
        else {
            // we compare lastName if firstNames are equal
            return this.lastName.compareTo(a.lastName);
        }
    }
}
 
public class GFG {
    public static void main(String[] args)
    {
 
        int n = 4;
        Pair arr[] = new Pair[n];
        arr[0] = new Pair("raj", "kashup");
        arr[1] = new Pair("rahul", "singh");
        arr[2] = new Pair("reshmi", "dubey");
        arr[3] = new Pair("rahul", "jetli");
 
        // Sorting the array
        Arrays.sort(arr);
 
        // printing the
        // Pair array
        print(arr);
    }
 
    public static void print(Pair[] arr)
    {
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}

```

**output**

```
Before Sorting:
( raj , kashup )
( rahul , singh )
( reshmi , dubey )
( rahul , jetli )


After Sorting:
( rahul , jetli )
( rahul , singh )
( raj , kashup )
( reshmi , dubey )
```

#### <a name="chapter11part6"></a>Chapter 11 - Part 6: Default methods

-  As of Java 8, interfaces can contain concrete methods.

- The basic intent is to provide default implementation for methods, so to avoid:
  - repetition of implementation in every class that implements the interface
  - the need to create abstract classes to provide implementation reuse

- Other advantages:
  - Maintain backward compatibility with existing systems
  - Allow "functional interfaces" (which must contain only one method) can provide other reusable standard operations

Example: Make a program to read an amount and the duration in months of a loan. Inform the amount to be paid after the deadline for the loan, in accordance with Brazilian interest rate rules. The calculation rule for Brazilian interest is standard compound interest of 2% per month.

<br>

<div align="center"><img src="img/interfaces10-w840-h323.png" width=840 height=323><br><sub>Fig 40 - Interfaces - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

class BrazilInterestService

```java

package services;

public class BrazilInterestService implements InterestService {

	private double interestRate;

	public BrazilInterestService(double interestRate) {
		this.interestRate = interestRate;
	}

	@Override
	public double getInterestRate() {
		return interestRate;
	}
}

```

class InterestService

```java

package services;

import java.security.InvalidParameterException;

public interface InterestService {

	double getInterestRate();

	default double payment(double amount, int months) {
		if (months < 1) {
			throw new InvalidParameterException("Months must be greater than zero");
		}
		return amount * Math.pow(1.0 + getInterestRate() / 100.0, months);
	}
}

```

class UsaInterestService

```java

package services;

public class UsaInterestService implements InterestService {

	private double interestRate;

	public UsaInterestService(double interestRate) {
		this.interestRate = interestRate;
	}

	@Override
	public double getInterestRate() {
		return interestRate;
	}
}

```

Program

```java

package application;

import java.util.Locale;
import java.util.Scanner;

import services.BrazilInterestService;
import services.InterestService;

public class Program {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		System.out.print("Amount: ");
		double amount = sc.nextDouble();
		System.out.print("Months: ");
		int months = sc.nextInt();
		
		InterestService is = new BrazilInterestService(2.0);
		double payment = is.payment(amount, months);
		
		System.out.println("Payment after " + months + " months:");
		System.out.println(String.format("%.2f", payment));
		
		sc.close();
	}
}

```


In Java 8+: 
- interfaces can now provide reuse
- now we have a form of multiple inheritance
  - But the compiler complains if there is more than one method with the same signature, forcing you to overwrite it
- Interfaces are still quite different from abstract classes. interfaces they do not have features such as constructors and attributes.

## <a name="chapter12"></a>Chapter 12: Collections

<br>

<div align="center"><img src="img/java_collection-w854-h715.png" width=854 height=715><br><sub>Fig 36 - Collections - (<a href='https://www.javatpoint.com/collections-in-java'>Work by  Java T Point</a>) </sub></div>

<br>

#### <a name="chapter12part1"></a>Chapter 12 - Part 1: ArrayList

ArrayList is a data Structure:
- Homogeneous (data of the same type)
- Ordered (elements accessed through positions)
- Starts empty, and its elements are allocated on demand
- Each element occupies a "node" (or node) of the list

Type (interface): List

Implementing classes: ArrayList, LinkedList, etc

Advantages:
- Variable Size
- Ease of insertion and deletion

Disadvantages:
- Fixed Size
- Sequential access to elements -> In the case of ArrayList, they are otimizaded

**Java ArrayList**

The ```ArrayList``` class is a resizable array, which can be found in the ```java.util``` package.

The difference between a built-in array and an ```ArrayList``` in Java, is that the size of an array cannot be modified (if you want to add or remove elements to/from an array, you have to create a new one). While elements can be added and removed from an ```ArrayList``` whenever you want. The syntax is also slightly different:

```java

import java.util.ArrayList; // import the ArrayList class

ArrayList<String> cars = new ArrayList<String>(); // Create an ArrayList object

```

- Add Items

The ```ArrayList``` class has many useful methods. For example, to add elements to the ```ArrayList```, use the ```add()``` method:

```java

import java.util.ArrayList;

public class Main {
  public static void main(String[] args) {
    ArrayList<String> cars = new ArrayList<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    cars.add("Mazda");
    System.out.println(cars);
  }
}

```

- Access an Item

To access an element in the ```ArrayList```, use the ```get()``` method and refer to the index number:

```java

cars.get(0);

```

- Change an Item

To modify an element, use the ```set()``` method and refer to the index number:

```java

cars.set(0, "Opel");

```

- Remove an Item

To remove an element, use the ```remove()``` method and refer to the index number:

```java

cars.remove(0);

```

To remove all the elements in the ```ArrayList```, use the ```clear()``` method:

```java

cars.clear();

```

- ArrayList Size

To find out how many elements an ArrayList have, use the ```size``` method:

```java

cars.size();

```

- Loop Through an ArrayList

Loop through the elements of an ```ArrayList``` with a ```for``` loop, and use the ```size()``` method to specify how many times the loop should run:

```java

public class Main {
  public static void main(String[] args) {
    ArrayList<String> cars = new ArrayList<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    cars.add("Mazda");
    for (int i = 0; i < cars.size(); i++) {
      System.out.println(cars.get(i));
    }
  }
}


```

You can also loop through an ArrayList with the for-each loop:

```java

public class Main {
  public static void main(String[] args) {
    ArrayList<String> cars = new ArrayList<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    cars.add("Mazda");
    for (String i : cars) {
      System.out.println(i);
    }
  }
}


```

- Other Types

Elements in an ArrayList are actually objects. In the examples above, we created elements (objects) of type "String". Remember that a String in Java is an object (not a primitive type). To use other types, such as int, you must specify an equivalent wrapper class: ```Integer```. For other primitive types, use: ```Boolean``` for boolean, ```Character``` for char, ```Double``` for double, etc:

```java

import java.util.ArrayList;

public class Main {
  public static void main(String[] args) {
    ArrayList<Integer> myNumbers = new ArrayList<Integer>();
    myNumbers.add(10);
    myNumbers.add(15);
    myNumbers.add(20);
    myNumbers.add(25);
    for (int i : myNumbers) {
      System.out.println(i);
    }
  }
}


```

- Sort an ArrayList

Another useful class in the ```java.util``` package is the ```Collections``` class, which include the ```sort()``` method for sorting lists alphabetically or numerically:

Example: Sort an ArrayList of Strings:

```java

import java.util.ArrayList;
import java.util.Collections;  // Import the Collections class

public class Main {
  public static void main(String[] args) {
    ArrayList<String> cars = new ArrayList<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    cars.add("Mazda");
    Collections.sort(cars);  // Sort cars
    for (String i : cars) {
      System.out.println(i);
    }
  }
}


```

Example: Sort an ArrayList of Integers:

```java

import java.util.ArrayList;
import java.util.Collections;  // Import the Collections class

public class Main {
  public static void main(String[] args) {
    ArrayList<Integer> myNumbers = new ArrayList<Integer>();
    myNumbers.add(33);
    myNumbers.add(15);
    myNumbers.add(20);
    myNumbers.add(34);
    myNumbers.add(8);
    myNumbers.add(12);

    Collections.sort(myNumbers);  // Sort myNumbers

    for (int i : myNumbers) {
      System.out.println(i);
    }
  }
}


```

```java

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class Program {

	public static void main(String[] args) {

		List<String> list = new ArrayList<>();

		list.add("Maria");
		list.add("Alex");
		list.add("Bob");
		list.add("Anna");
		list.add(2, "Marco");

		System.out.println(list.size()); // 5
		for (String x : list) {
			System.out.println(x); // Maria Alex Marco Bob Anna
		}
		System.out.println("---------------------");
		list.removeIf(x -> x.charAt(0) == 'M');
		for (String x : list) {
			System.out.println(x); // Alex Bob Anna
		}
		System.out.println("---------------------");
		System.out.println("Index of Bob: " + list.indexOf("Bob")); // -1
		System.out.println("Index of Marco: " + list.indexOf("Marco")); // -1
		System.out.println("---------------------");
		List<String> result = list.stream().filter(x -> x.charAt(0) == 'A').collect(Collectors.toList());
		for (String x : result) {
			System.out.println(x); //Alex Anna
		}
		System.out.println("---------------------");
		String name = list.stream().filter(x -> x.charAt(0) == 'J').findFirst().orElse(null);
		System.out.println(name); //null
	}
}

```

Exercise: Make a program to read an integer N and then the data (id, name and salary) of N employees. There should be no repetition of id

Then, increase the salary of a given employee by X percent. For this, the program must read an id and the value X. If the informed id does not exist, display a message and abort the operation. At the end, show the updated list of employees, according to examples.

Remember to apply the encapsulation technique to not allow the salary to be changed freely. A salary can only be increased on the basis of a increase by given percentage

<br>

<div align="center"><img src="img/arraylist_exercise-w677-h786.png" width=677 height=786><br><sub>Fig 37 - ArrayList Exercise - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Neilo Alves</a>) </sub></div>

<br>

<div align="center"><img src="img/arraylist1_exercise-w428-h179.png" width=428 height=179><br><sub>Fig 38 - ArrayList Exercise - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Class Employe

```java

public class Employee {

	private Integer id;
	private String name;
	private Double salary;
	
	public Employee() {
	}
	
	public Employee(Integer id, String name, Double salary) {
		this.id = id;
		this.name = name;
		this.salary = salary;
	}

	public Integer getId() {
		return id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Double getSalary() {
		return salary;
	}

	public void setSalary(Double salary) {
		this.salary = salary;
	}
	
	public void increaseSalary(double percentage) {
		salary += salary * percentage / 100.0;
	}
	
	public String toString() {
		return id + ", " + name + ", " + String.format("%.2f", salary);
	}
}

```

Program

```java

package application;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Scanner;

import entities.Employee;

public class Program {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		List<Employee> list = new ArrayList<>();
		
		// PART 1 - READING DATA:
		
		System.out.print("How many employees will be registered? ");
		int n = sc.nextInt();
		
		for (int i=1; i<=n; i++) {
			System.out.println();
			System.out.println("Employee #" + i + ": ");

			System.out.print("Id: ");
			int id = sc.nextInt();
			while (hasId(list, id)) {
				System.out.print("Id already taken. Try again: ");
				id = sc.nextInt();
			}
			
			System.out.print("Name: ");
			sc.nextLine();
			String name = sc.nextLine();
			System.out.print("Salary: ");
			double salary = sc.nextDouble();
			list.add(new Employee(id, name, salary));
		}

		// PART 2 - UPDATING SALARY OF GIVEN EMPLOYEE:
		
		System.out.println();
		System.out.print("Enter the employee id that will have salary increase: ");
		int id = sc.nextInt();
		Employee emp = list.stream().filter(x -> x.getId() == id).findFirst().orElse(null);
		if (emp == null) {
			System.out.println("This id does not exist!");
		}
		else {
			System.out.print("Enter the percentage: ");
			double percentage = sc.nextDouble();
			emp.increaseSalary(percentage);
		}
		
		// PART 3 - LISTING EMPLOYEES:
		
		System.out.println();
		System.out.println("List of employees:");
		for (Employee obj : list) {
			System.out.println(obj);
		}
				
		sc.close(); 
	}
	
	public static boolean hasId(List<Employee> list, int id) {
		Employee emp = list.stream().filter(x -> x.getId() == id).findFirst().orElse(null);
		return emp != null;
	}
}

```

#### <a name="chapter12part2"></a>Chapter 12 - Part 2: HashMap

- It is a collection of key/value pairs
  - Does not support key object repetitions
  - Elements are indexed by the key object (have no position)
  - Accessing, inserting and removing elements is fast

- Common usage: cookies, local storage, any key-value model

- Main implementations:
  - HashMap: faster (O(1) operations on hash table) and unordered
  - TreeMap: slower (O(log(n)) operations in red-black tree) and sorted by object compareTo (or Comparator)
  - LinkedHashMap: intermediate speed and elements in the order they are added

**Some important methods**

- put(key, value), remove(key), containsKey(key), get(key)
  - Based on equals and hashCode
  - If equals and hashCode do not exist, pointer comparison is used

- clear()

- size()

- keySet(): return a Set<K>

- values(): return a Collection<V>

	
In the ```ArrayList``` chapter, you learned that Arrays store items as an ordered collection, and you have to access them with an index number (```int``` type). A ```HashMap``` however, store items in "**key/value**" pairs, and you can access them by an index of another type (e.g. a ```String```).
	
One object is used as a key (index) to another object (value). It can store different types: ```String``` keys and ```Integer``` values, or the same type, like: ```String``` keys and ```String``` values:
	
Example: Create a ```HashMap``` object called **capitalCities** that will store ```String``` keys and ```String``` values:
	
```java
	
import java.util.HashMap; // import the HashMap class

HashMap<String, String> capitalCities = new HashMap<String, String>();
	
```
	
**Add Items**
	
The HashMap class has many useful methods. For example, to add items to it, use the ```put()``` method:
	
```java

// Import the HashMap class
import java.util.HashMap;

public class Main {
  public static void main(String[] args) {
    // Create a HashMap object called capitalCities
    HashMap<String, String> capitalCities = new HashMap<String, String>();

    // Add keys and values (Country, City)
    capitalCities.put("England", "London");
    capitalCities.put("Germany", "Berlin");
    capitalCities.put("Norway", "Oslo");
    capitalCities.put("USA", "Washington DC");
    System.out.println(capitalCities);
  }
}
	
```
	
**Access an Item**
	
To access a value in the HashMap, use the ```get()``` method and refer to its key:
	
```Java
	
capitalCities.get("England");
	
```
	
**Remove an Item**
	
To remove an item, use the ```remove()``` method and refer to the key:
	
```java
	
capitalCities.remove("England");
	
```
	
To remove all items, use the ```clear()``` method:
	
```java
	
capitalCities.clear();
	
```
	
**HashMap Size**
	
To find out how many items there are, use the ```size()``` method:
	
```java
	
capitalCities.size();
	
```
	
**Loop Through a HashMap**
	
Loop through the items of a HashMap with a for-each loop.

Note: Use the keySet() method if you only want the keys, and use the values() method if you only want the values:
	
```java
	
// Print keys
for (String i : capitalCities.keySet()) {
  System.out.println(i);
}
	
```
	
```java
	
// Print values
for (String i : capitalCities.values()) {
  System.out.println(i);
}
	
```
	
```java
	
// Print keys and values
for (String i : capitalCities.keySet()) {
  System.out.println("key: " + i + " value: " + capitalCities.get(i));
}
	
```
	
**Other Types**
	
Keys and values in a HashMap are actually objects. In the examples above, we used objects of type "String". Remember that a String in Java is an object (not a primitive type). To use other types, such as int, you must specify an equivalent wrapper class: Integer. For other primitive types, use: Boolean for boolean, Character for char, Double for double, etc:
	
```java
	
// Import the HashMap class
import java.util.HashMap;

public class Main {
  public static void main(String[] args) {

    // Create a HashMap object called people
    HashMap<String, Integer> people = new HashMap<String, Integer>();


    // Add keys and values (Name, Age)
    people.put("John", 32);
    people.put("Steve", 30);
    people.put("Angie", 33);

    for (String i : people.keySet()) {
      System.out.println("key: " + i + " value: " + people.get(i));
    }
  }
}
	
```

#### <a name="chapter12part3"></a>Chapter 12 - Part 3: HashSet

- Represents a set of elements (similar to Algebra)
  - Does not allow repetitions
  - Elements have no position
  - Accessing, inserting and removing elements is fast
  - Offers efficient set operations: intersection, union, difference.
  
- Main implementations:
  - HashSet: faster (O(1) operations on hash table) and unordered
  - TreeSet: slower (O(log(n)) operations in red-black tree) and sorted by object compareTo (or Comparator)
  - LinkedHashSet: intermediate speed and elements in the order they are added

**Some important methods**

- add(obj), remove(obj), contains(obj)
  - Based on equals and hashCode
  - If equals and hashCode do not exist, pointer comparison is used

- clear()

- size()

- RemoveIf(predicate)

- addAll(other): union: adds the elements of the other set to the set, without repetition

- retainAll(other): intersection: removes elements not contained in other from the set

- removeAll(other): difference: removes elements contained in other from the set
	
A HashSet is a collection of items where every item is unique, and it is found in the ```java.util``` package:
	
Example: Create a HashSet object called cars that will store strings:
	
```java
	
import java.util.HashSet; // Import the HashSet class

HashSet<String> cars = new HashSet<String>();
	
```
	
**Add Items**
	
The HashSet class has many useful methods. For example, to add items to it, use the ```add()``` method:
	
```java
	
// Import the HashSet class
import java.util.HashSet;

public class Main {
  public static void main(String[] args) {
    HashSet<String> cars = new HashSet<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    cars.add("BMW");
    cars.add("Mazda");
    System.out.println(cars);
  }
}
	
```
	
Note: In the example above, even though BMW is added twice it only appears once in the set because every item in a set has to be unique.
	
**Check If an Item Exists**
	
To check whether an item exists in a HashSet, use the ```contains()``` method:
	
```java
	
cars.contains("Mazda");
	
```
	
**Remove an Item**
	
To remove an item, use the ```remove()``` method:
	
```java
	
cars.remove("Volvo");
	
```
	
To remove all items, use the ```clear()``` method:
	
```java
	
cars.clear();
	
```
	
**HashSet Size**

To find out how many items there are, use the ```size``` method:
	
```java
	
cars.size();
	
```
	
**Loop Through a HashSet**
	
Loop through the items of an HashSet with a for-each loop:
	
```java
	
for (String i : cars) {
  System.out.println(i);
}
	
```
	
**Union**
	
```java
	
package application;
	
import java.util.Arrays;
import java.util.Set;
import java.util.TreeSet;
	
public class Program {
	
	public static void main(String[] args) {
	
		Set<Integer> a = new TreeSet<>(Arrays.asList(0,2,4,5,6,8,10));
		Set<Integer> b = new TreeSet<>(Arrays.asList(5,6,7,8,9,10));
	
		//union
		Set<Integer> c = new TreeSet<>(a);
		c.addAll(b);
		System.out.println(c); // [0, 2, 4, 5, 6, 7, 8, 9, 10]
	}
}
	
```
	
**intersection**
	
```java
	
import java.util.Arrays;
import java.util.Set;
import java.util.TreeSet;
	
public class Program {
	
	public static void main(String[] args) {
	
		Set<Integer> a = new TreeSet<>(Arrays.asList(0,2,4,5,6,8,10));
		Set<Integer> b = new TreeSet<>(Arrays.asList(5,6,7,8,9,10));
	
		//intersection
		Set<Integer> d = new TreeSet<>(a);
		d.retainAll(b);
		System.out.println(d); // [5, 6, 8, 10]
	}
}
	
```
	
**difference**
	
```java
	
import java.util.Arrays;
import java.util.Set;
import java.util.TreeSet;
	
public class Program {
	
	public static void main(String[] args) {
	
		Set<Integer> a = new TreeSet<>(Arrays.asList(0,2,4,5,6,8,10));
		Set<Integer> b = new TreeSet<>(Arrays.asList(5,6,7,8,9,10));
	
		//difference
		Set<Integer> e = new TreeSet<>(a);
		e.removeAll(b);
		System.out.println(e); //[0, 2, 4]
	}
}
	
```
	
**Other Types**
	
Items in an HashSet are actually objects. In the examples above, we created items (objects) of type "String". Remember that a String in Java is an object (not a primitive type). To use other types, such as int, you must specify an equivalent wrapper class: Integer. For other primitive types, use: Boolean for boolean, Character for char, Double for double, etc:
	
```java
	
import java.util.HashSet;

public class Main {
  public static void main(String[] args) {

    // Create a HashSet object called numbers
    HashSet<Integer> numbers = new HashSet<Integer>();

    // Add values to the set
    numbers.add(4);
    numbers.add(7);
    numbers.add(8);

    // Show which numbers between 1 and 10 are in the set
    for(int i = 1; i <= 10; i++) {
      if(numbers.contains(i)) {
        System.out.println(i + " was found in the set.");
      } else {
        System.out.println(i + " was not found in the set.");
      }
    }
  }
}
			  
```


## <a name="chapter13"></a>Chapter 13: Java Lambda Expression

#### <a name="chapter13part1"></a>Chapter 13 - Part 1: Java Lambda Expression

Lambda Expressions were added in Java 8.

A lambda expression is a short block of code which takes in parameters and returns a value. Lambda expressions are similar to methods, but they do not need a name and they can be implemented right in the body of a method.
	
**Syntax**
	
The simplest lambda expression contains a single parameter and an expression:
	
```java
	
parameter -> expression
	
```
	
To use more than one parameter, wrap them in parentheses:
	
```java
	
(parameter1, parameter2) -> expression
	
```
	
Expressions are limited. They have to immediately return a value, and they cannot contain variables, assignments or statements such as if or for. In order to do more complex operations, a code block can be used with curly braces. If the lambda expression needs to return a value, then the code block should have a return statement.
	
```java
	
(parameter1, parameter2) -> { code block }
	
```
	
**Using Lambda Expressions**
	
Lambda expressions are usually passed as parameters to a function:
	
Use a lambda expression in the ArrayList's forEach() method to print every item in the list:

```java

import java.util.ArrayList;

public class Main {
  public static void main(String[] args) {
    ArrayList<Integer> numbers = new ArrayList<Integer>();
    numbers.add(5);
    numbers.add(9);
    numbers.add(8);
    numbers.add(1);
    numbers.forEach( (n) -> { System.out.println(n); } );
  }
}

```
	
Lambda expressions can be stored in variables if the variable's type is an interface which has only one method. The lambda expression should have the same number of parameters and the same return type as that method. Java has many of these kinds of interfaces built in, such as the ```Consumer``` interface (found in the ```java.util``` package) used by lists.
	
Use Java's Consumer interface to store a lambda expression in a variable:
	
```java
	
import java.util.ArrayList;
import java.util.function.Consumer;

public class Main {
  public static void main(String[] args) {
    ArrayList<Integer> numbers = new ArrayList<Integer>();
    numbers.add(5);
    numbers.add(9);
    numbers.add(8);
    numbers.add(1);
    Consumer<Integer> method = (n) -> { System.out.println(n); };
    numbers.forEach( method );
  }
}
	
```
	
To use a lambda expression in a method, the method should have a parameter with a single-method interface as its type. Calling the interface's method will run the lambda expression:
	
```java
	
interface StringFunction {
  String run(String str);
}

public class Main {
  public static void main(String[] args) {
    StringFunction exclaim = (s) -> s + "!";
    StringFunction ask = (s) -> s + "?";
    printFormatted("Hello", exclaim);
    printFormatted("Hello", ask);
  }
  public static void printFormatted(String str, StringFunction format) {
    String result = format.run(str);
    System.out.println(result);
  }
}
	
```
	
<!-- URL's -->
