<h1 align="center"> Java </h1>

# Content

1. [Chapter 1: Introduction to Java and Setting Up Your Environment](#chapter1)
    - [Chapter 1 - Part 1: What is Java and Why Learn It?](#chapter1part1)
      - [Chapter 1 - Part 1.1: What is Java?](#chapter1part1.1)
      - [Chapter 1 - Part 1.2: Why Learn Java?](#chapter1part1.2)
    - [Chapter 1 - Part 2: Understanding the Java Ecosystem: JVM, JRE, JDK](#chapter1part2)
      - [Chapter 1 - Part 2.1: Compilation and Interpretation, Source Code and Object Code, Virtual Machine](#chapter1part2.1)
      - [Chapter 1 - Part 2.2: The Java Virtual Machine (JVM)](#chapter1part2.2)
      - [Chapter 1 - Part 2.3: The Java Runtime Environment (JRE)](#chapter1part2.3)
      - [Chapter 1 - Part 2.4: The Java Development Kit (JDK)](#chapter1part2.4)
      - [Chapter 1 - Part 2.5: Relationship Between JVM, JRE, and JDK](#chapter1part2.5)
      - [Chapter 1 - Part 2.6: Choosing the Right Version](#chapter1part2.6)
    - [Chapter 1 - Part 3: Installing the Java Development Kit (JDK)](#chapter1part3)
      - [Chapter 1 - Part 3.1: Understanding the JDK and its Components](#chapter1part3.1)
      - [Chapter 1 - Part 3.2: Downloading the JDK](#chapter1part3.2)
      - [Chapter 1 - Part 3.3: Installing the JDK](#chapter1part3.3)
      - [Chapter 1 - Part 3.4: Setting Environment Variables](#chapter1part3.4)
      - [Chapter 1 - Part 3.5: Verifying the Installation](#chapter1part3.5)
      - [Chapter 1 - Part 3.6: Troubleshooting Common Installation Issues](#chapter1part3.6)
    - [Chapter 1 - Part 4: Setting Up a Java Development Environment (IDE): IntelliJ IDEA or Eclipse](#chapter1part4)
      - [Chapter 1 - Part 4.1: Understanding Integrated Development Environments (IDEs)](#chapter1part4.1)
      - [Chapter 1 - Part 4.2: IntelliJ IDEA](#chapter1part4.2)
      - [Chapter 1 - Part 4.3: Eclipse](#chapter1part4.3)
    - [Chapter 1 - Part 5: Writing and Running Your First Java Program: "Hello, World!"](#chapter1part5)
      - [Chapter 1 - Part 5.1: Creating Your First Java Program: "Hello, World!"](#chapter1part5.1)
      - [Chapter 1 - Part 5.2: Understanding the Compilation Process](#chapter1part5.2)
      - [Chapter 1 - Part 5.3: Common Errors and Troubleshooting](#chapter1part5.3)
    - [Chapter 1 - Part 6: Understanding Basic Java Program Structure](#chapter1part6)
      - [Chapter 1 - Part 6.1: Anatomy of a Java Program](#chapter1part6.1)
      - [Chapter 1 - Part 6.2: Putting It All Together: A Complete Java Program](#chapter1part6.2)
      - [Chapter 1 - Part 6.3: Common Errors and How to Avoid Them](#chapter1part6.3)
2. [Chapter 2: Java Fundamentals: Data Types, Variables, and Operators](#chapter2)
    - [Chapter 2 - Part 1: Understanding Primitive Data Types: int, double, boolean, char](#chapter2part1)
      - [Chapter 2 - Part 1.1: Data Types in Java](#chapter2part1.1)
      - [Chapter 2 - Part 1.2: Integer Data Type: int](#chapter2part1.2)
      - [Chapter 2 - Part 1.3: Floating-Point Data Type: double](#chapter2part1.3)
      - [Chapter 2 - Part 1.4: Boolean Data Type: boolean](#chapter2part1.4)
      - [Chapter 2 - Part 1.5: Character Data Type: char](#chapter2part1.5)
    - [Chapter 2 - Part 2: Declaring and Initializing Variables](#chapter2part2)
      - [Chapter 2 - Part 2.1: Understanding Variable Declaration](#chapter2part2.1)
      - [Chapter 2 - Part 2.2: Understanding Variable Initialization](#chapter2part2.2)
      - [Chapter 2 - Part 2.3: Best Practices for Declaring and Initializing Variables](#chapter2part2.3)
      - [Chapter 2 - Part 2.4: Casting](#chapter2part2.4)
      - [Chapter 2 - Part 2.5: Variable Scope (Java Scope)](#chapter2part2.5)
      - [Chapter 2 - Part 2.6: Examples and Demonstrations](#chapter2part2.6)
    - [Chapter 2 - Part 3: Working with Strings](#chapter2part3)
      - [Chapter 2 - Part 3.1: Creating Strings](#chapter2part3.1)
      - [Chapter 2 - Part 3.2: String Immutability](#chapter2part3.2)
      - [Chapter 2 - Part 3.3: String Manipulation](#chapter2part3.3)
      - [Chapter 2 - Part 3.4: String Comparison](#chapter2part3.4)
      - [Chapter 2 - Part 3.5: String Methods](#chapter2part3.5)
    - [Chapter 2 - Part 4: Arithmetic Operators: +, -, *, /, %](#chapter2part4)
      - [Chapter 2 - Part 4.1: Basic Arithmetic Operators](#chapter2part4.1)
      - [Chapter 2 - Part 4.2: Operator Precedence](#chapter2part4.2)
      - [Chapter 2 - Part 4.3: Practical Examples and Demonstrations](#chapter2part4.3)
    - [Chapter 2 - Part 5: Assignment Operators: =, +=, -=, *=, /=](#chapter2part5)
      - [Chapter 2 - Part 5.1: Understanding the Basic Assignment Operator (=)](#chapter2part5.1)
      - [Chapter 2 - Part 5.2: Compound Assignment Operators (+=, -=, *=, /=)](#chapter2part5.2)
      - [Chapter 2 - Part 5.3: Practical Examples and Demonstrations](#chapter2part5.3)
    - [Chapter 2 - Part 6: Comparison Operators: ==, !=, >, <, >=, <=](#chapter2part6)
      - [Chapter 2 - Part 6.1: Understanding Comparison Operators](#chapter2part6.1)
      - [Chapter 2 - Part 6.2: Practical Examples and Demonstrations](#chapter2part6.2)
    - [Chapter 2 - Part 7: Logical Operators: &&, ||, !](#chapter2part7)
      - [Chapter 2 - Part 7.1: Understanding Logical Operators](#chapter2part7.1)
      - [Chapter 2 - Part 7.2: Combining Logical Operators](#chapter2part7.2)
      - [Chapter 2 - Part 7.3: Practical Examples](#chapter2part7.3)
    - [Chapter 2 - Part 8: Bitwise Operators](#chapter2part8)
    - [Chapter 2 - Part 9: Operator Precedence](#chapter2part9)
      - [Chapter 2 - Part 9.1: Understanding Operator Precedence in Java](#chapter2part9.1)
      - [Chapter 2 - Part 9.2: Using Parentheses to Control Precedence](#chapter2part9.2)
      - [Chapter 2 - Part 9.3: Practical Examples and Demonstrations](#chapter2part9.3)
3. [Chapter 3: Control Flow: Making Decisions and Repeating Actions](#chapter3)
    - [Chapter 3 - Part 1: Introduction to Control Flow Statements](#chapter3part1)
      - [Chapter 3 - Part 1.1: Understanding Control Flow](#chapter3part1.1)
      - [Chapter 3 - Part 1.2: Decision-Making Statements: An Overview](#chapter3part1.2)
      - [Chapter 3 - Part 1.3: Looping Statements: An Introduction](#chapter3part1.3)
      - [Chapter 3 - Part 1.4: Using break and continue Statements](#chapter3part1.4)
    - [Chapter 3 - Part 2: The `if` Statement: Conditional Execution](#chapter3part2)
      - [Chapter 3 - Part 2.1: Understanding the if Statement](#chapter3part2.1)
      - [Chapter 3 - Part 2.2: Practical Examples of the if Statement](#chapter3part2.2)
    - [Chapter 3 - Part 3: The `if-else` Statement: Choosing Between Two Options](#chapter3part3)
      - [Chapter 3 - Part 3.1: Understanding the if-else Statement](#chapter3part3.1)
      - [Chapter 3 - Part 3.2: Omitting Curly Braces](#chapter3part3.2)
      - [Chapter 3 - Part 3.3: Nested if-else Statements](#chapter3part3.3)
      - [Chapter 3 - Part 3.4: Short-Hand if-else](#chapter3part3.4)
      - [Chapter 3 - Part 3.5: Common Errors and Pitfalls](#chapter3part3.5)
    - [Chapter 3 - Part 4: The `if-else if-else` Statement: Handling Multiple Conditions](#chapter3part4)
      - [Chapter 3 - Part 4.1: Understanding the if-else if-else Statement](#chapter3part4.1)
    - [Chapter 3 - Part 5: The `switch` Statement: Selecting from Multiple Cases](#chapter3part5)
      - [Chapter 3 - Part 5.1: Understanding the switch Statement](#chapter3part5.1)
      - [Chapter 3 - Part 5.2: Practical Examples and Demonstrations](#chapter3part5.2)
    - [Chapter 3 - Part 6: The `while` Loop: Repeating Code While a Condition is True](#chapter3part6)
      - [Chapter 3 - Part 6.1: Understanding the while Loop](#chapter3part6.1)
      - [Chapter 3 - Part 6.2: Using while Loops with User Input](#chapter3part6.2)
      - [Chapter 3 - Part 6.3: Using while Loops with Boolean Flags](#chapter3part6.3)
      - [Chapter 3 - Part 6.4: Nested while Loops](#chapter3part6.4)
    - [Chapter 3 - Part 7: The `do-while` Loop: Ensuring Code Executes at Least Once](#chapter3part7)
      - [Chapter 3 - Part 7.1: Understanding the do-while Loop](#chapter3part7.1)
      - [Chapter 3 - Part 7.2: Practical Examples of do-while Loops](#chapter3part7.2)
    - [Chapter 3 - Part 8: The `for` Loop: Repeating Code a Specific Number of Times](#chapter3part8)
      - [Chapter 3 - Part 8.1: Understanding the for Loop Syntax](#chapter3part8.1)
      - [Chapter 3 - Part 8.2: How the for Loop Works](#chapter3part8.2)
      - [Chapter 3 - Part 8.3: Practical Examples of for Loops](#chapter3part8.3)
      - [Chapter 3 - Part 8.4: Variations of the for Loop](#chapter3part8.4)
      - [Chapter 3 - Part 8.5: Common Mistakes and How to Avoid Them](#chapter3part8.5)
    - [Chapter 3 - Part 9: Using `break` and `continue` Statements](#chapter3part9)
      - [Chapter 3 - Part 9.1: Understanding the break Statement](#chapter3part9.1)
      - [Chapter 3 - Part 9.2: Understanding the continue Statement](#chapter3part9.2)
      - [Chapter 3 - Part 9.3: Practical Examples and Demonstrations](#chapter3part9.3)
4. [Chapter 4: Working with Arrays and Strings](#chapter4)
    - [Chapter 4 - Part 1: Introduction to Arrays: Storing Collections of Data](#chapter4part1)
      - [Chapter 4 - Part 1.1: Declaring and Initializing Arrays](#chapter4part1.1)
      - [Chapter 4 - Part 1.2: Accessing Array Elements](#chapter4part1.2)
      - [Chapter 4 - Part 1.3: Looping Through Arrays](#chapter4part1.3)
    - [Chapter 4 - Part 2: Declaring and Initializing Arrays](#chapter4part2)
      - [Chapter 4 - Part 2.1: Declaring Arrays](#chapter4part2.1)
      - [Chapter 4 - Part 2.2: Initializing Arrays](#chapter4part2.2)
      - [Chapter 4 - Part 2.3: Accessing Array Elements](#chapter4part2.3)
      - [Chapter 4 - Part 2.4: Looping Through Arrays](#chapter4part2.4)
    - [Chapter 4 - Part 3: Accessing Array Elements](#chapter4part3)
      - [Chapter 4 - Part 3.1: Accessing Array Elements Using Indices](#chapter4part3.1)
      - [Chapter 4 - Part 3.2: ArrayIndexOutOfBoundsException](#chapter4part3.2)
      - [Chapter 4 - Part 3.3: Practical Examples and Demonstrations](#chapter4part3.3)
    - [Chapter 4 - Part 4: Looping Through Arrays](#chapter4part4)
      - [Chapter 4 - Part 4.1: Understanding the Need for Loops](#chapter4part4.1)
      - [Chapter 4 - Part 4.2: Types of Loops in Java](#chapter4part4.2)
      - [Chapter 4 - Part 4.3: The for Loop](#chapter4part4.3)
      - [Chapter 4 - Part 4.4: The Enhanced for Loop (For-Each Loop)](#chapter4part4.4)
      - [Chapter 4 - Part 4.5: The while Loop](#chapter4part4.5)
      - [Chapter 4 - Part 4.6: The do-while Loop](#chapter4part4.6)
      - [Chapter 4 - Part 4.7: Using Streams and Lambda Expressions to Loop Through Arrays](#chapter4part4.7)
    - [Chapter 4 - Part 5: Multidimensional Arrays](#chapter4part5)
      - [Chapter 4 - Part 5.1: Understanding Multidimensional Arrays](#chapter4part5.1)
      - [Chapter 4 - Part 5.2: Practical Examples and Demonstrations](#chapter4part5.2)
    - [Chapter 4 - Part 6: Introduction to Strings: Working with Text](#chapter4part6)
      - [Chapter 4 - Part 6.1: Creating Strings](#chapter4part6.1)
      - [Chapter 4 - Part 6.2: String Manipulation](#chapter4part6.2)
      - [Chapter 4 - Part 6.3: String Comparison: equals() vs. ==](#chapter4part6.3)
      - [Chapter 4 - Part 6.4: String Methods: toUpperCase(), toLowerCase(), trim()](#chapter4part6.4)
    - [Chapter 4 - Part 7: String Manipulation: Concatenation, Substrings, Length](#chapter4part7)
      - [Chapter 4 - Part 7.1: String Concatenation](#chapter4part7.1)
      - [Chapter 4 - Part 7.2: Extracting Substrings](#chapter4part7.2)
      - [Chapter 4 - Part 7.3: Determining String Length](#chapter4part7.3)
    - [Chapter 4 - Part 8: String Comparison: equals() vs. ==](#chapter4part8)
      - [Chapter 4 - Part 8.1: Understanding String Immutability and the String Pool](#chapter4part8.1)
      - [Chapter 4 - Part 8.2: The equals() Method: Comparing String Content](#chapter4part8.2)
      - [Chapter 4 - Part 8.3: The == Operator: Comparing Object References](#chapter4part8.3)
      - [Chapter 4 - Part 8.4: When to Use equals() vs. ==](#chapter4part8.4)
    - [Chapter 4 - Part 9: String Methods: toUpperCase(), toLowerCase(), trim()](#chapter4part9)
      - [Chapter 4 - Part 9.1: Understanding toUpperCase() and toLowerCase()](#chapter4part9.1)
      - [Chapter 4 - Part 9.2: Understanding trim()](#chapter4part9.2)
      - [Chapter 4 - Part 9.3: Combining String Methods](#chapter4part9.3)
5. [Chapter 5: Object-Oriented Programming (OOP) Fundamentals](#chapter5)
    - [Chapter 5 - Part 1: Introduction to Object-Oriented Programming (OOP)](#chapter5part1)
      - [Chapter 5 - Part 1.1: Understanding Classes and Objects](#chapter5part1.1)
      - [Chapter 5 - Part 1.2: Defining Classes: Attributes (Fields) and Behaviors (Methods)](#chapter5part1.2)
      - [Chapter 5 - Part 1.3: Creating Objects: Instantiating Classes](#chapter5part1.3)
      - [Chapter 5 - Part 1.4: Accessing Object Attributes and Calling Methods](#chapter5part1.4)
      - [Chapter 5 - Part 1.5: Constructors: Initializing Objects](#chapter5part1.5)
      - [Chapter 5 - Part 1.6: The this Keyword: Referring to the Current Object](#chapter5part1.6)
      - [Chapter 5 - Part 1.7: Introduction to Encapsulation: Hiding Data](#chapter5part1.7)
    - [Chapter 5 - Part 2: Understanding Classes and Objects](#chapter5part2)
      - [Chapter 5 - Part 2.1: Understanding Classes](#chapter5part2.1)
      - [Chapter 5 - Part 2.2: Creating Objects: Instantiating Classes](#chapter5part2.2)
      - [Chapter 5 - Part 2.3: Accessing Object Attributes and Calling Methods](#chapter5part2.3)
      - [Chapter 5 - Part 2.4: Constructors: Initializing Objects](#chapter5part2.4)
      - [Chapter 5 - Part 2.5: The this Keyword: Referring to the Current Object](#chapter5part2.5)
      - [Chapter 5 - Part 2.6: Introduction to Encapsulation: Hiding Data](#chapter5part2.6)
    - [Chapter 5 - Part 3: Defining Classes: Attributes (Fields) and Behaviors (Methods)](#chapter5part3)
      - [Chapter 5 - Part 3.1: Understanding Classes and Objects](#chapter5part3.1)
      - [Chapter 5 - Part 3.2: Defining Classes: Attributes (Fields)](#chapter5part3.2)
      - [Chapter 5 - Part 3.3: Defining Classes: Behaviors (Methods)](#chapter5part3.3)
      - [Chapter 5 - Part 3.4: Practical Examples and Demonstrations](#chapter5part3.4)
    - [Chapter 5 - Part 4: Creating Objects: Instantiating Classes](#chapter5part4)
      - [Chapter 5 - Part 4.1: Understanding Object Instantiation](#chapter5part4.1)
      - [Chapter 5 - Part 4.2: Practical Examples and Demonstrations](#chapter5part4.2)
    - [Chapter 5 - Part 5: Accessing Object Attributes and Calling Methods](#chapter5part5)
      - [Chapter 5 - Part 5.1: Accessing Object Attributes](#chapter5part5.1)
      - [Chapter 5 - Part 5.2: Calling Methods](#chapter5part5.2)
    - [Chapter 5 - Part 6: Constructors: Initializing Objects](#chapter5part6)
      - [Chapter 5 - Part 6.1: Understanding Constructors](#chapter5part6.1)
      - [Chapter 5 - Part 6.2: Default Constructor (No-Argument Constructor)](#chapter5part6.2)
      - [Chapter 5 - Part 6.3: Parameterized Constructor](#chapter5part6.3)
      - [Chapter 5 - Part 6.4: The this Keyword](#chapter5part6.4)
      - [Chapter 5 - Part 6.5: Practical Examples and Demonstrations](#chapter5part6.5)
      - [Chapter 5 - Part 6.8: Next Steps and Future Learning Directions](#chapter5part6.8)
    - [Chapter 5 - Part 7: The `this` Keyword: Referring to the Current Object](#chapter5part7)
      - [Chapter 5 - Part 7.1: Understanding the this Keyword](#chapter5part7.1)
      - [Chapter 5 - Part 7.2: Practical Examples and Demonstrations](#chapter5part7.2)
    - [Chapter 5 - Part 8: Introduction to Encapsulation: Hiding Data](#chapter5part8)
      - [Chapter 5 - Part 8.1: Understanding Encapsulation](#chapter5part8.1)
      - [Chapter 5 - Part 8.2: Implementing Encapsulation in Java](#chapter5part8.2)
      - [Chapter 5 - Part 8.3: Advanced Encapsulation Techniques](#chapter5part8.3)
6. [Chapter 6: Methods and Classes in Depth](#chapter6)
    - [Chapter 6 - Part 1: Method Overloading: Creating Methods with the Same Name](#chapter6part1)
      - [Chapter 6 - Part 1.1: Understanding Method Overloading](#chapter6part1.1)
      - [Chapter 6 - Part 1.2: Practical Examples and Demonstrations](#chapter6part1.2)
    - [Chapter 6 - Part 2: Method Parameters and Return Types](#chapter6part2)
      - [Chapter 6 - Part 2.1: Understanding Method Parameters](#chapter6part2.1)
      - [Chapter 6 - Part 2.2: Understanding Return Types](#chapter6part2.2)
      - [Chapter 6 - Part 2.3: Practical Examples and Demonstrations](#chapter6part2.3)
    - [Chapter 6 - Part 3: Static Variables and Methods: Class-Level Members](#chapter6part3)
      - [Chapter 6 - Part 3.1: Understanding Static Variables](#chapter6part3.1)
      - [Chapter 6 - Part 3.2: Understanding Static Methods](#chapter6part3.2)
      - [Chapter 6 - Part 3.3: Static Blocks](#chapter6part3.3)
      - [Chapter 6 - Part 3.4: Real-World Applications](#chapter6part3.4)
    - [Chapter 6 - Part 4: Understanding Access Modifiers: public, private, protected, default](#chapter6part4)
      - [Chapter 6 - Part 4.1: Understanding Access Modifiers](#chapter6part4.1)
      - [Chapter 6 - Part 4.2: Access Levels: A Summary](#chapter6part4.2)
      - [Chapter 6 - Part 4.3: Practical Examples and Demonstrations](#chapter6part4.3)
    - [Chapter 6 - Part 5: Introduction to Inheritance: Creating Hierarchies of Classes](#chapter6part5)
      - [Chapter 6 - Part 5.1: Understanding Inheritance](#chapter6part5.1)
      - [Chapter 6 - Part 5.2: The extends Keyword](#chapter6part5.2)
      - [Chapter 6 - Part 5.3: Method Overriding](#chapter6part5.3)
      - [Chapter 6 - Part 5.4: The super Keyword](#chapter6part5.4)
    - [Chapter 6 - Part 6: The `extends` Keyword: Inheriting from a Parent Class](#chapter6part6)
      - [Chapter 6 - Part 6.1: Understanding the extends Keyword](#chapter6part6.1)
      - [Chapter 6 - Part 6.2: Practical Examples and Demonstrations](#chapter6part6.2)
    - [Chapter 6 - Part 7: Method Overriding: Changing Inherited Behavior](#chapter6part7)
      - [Chapter 6 - Part 7.1: Understanding Method Overriding](#chapter6part7.1)
      - [Chapter 6 - Part 7.2: The super Keyword and Method Overriding](#chapter6part7.2)
      - [Chapter 6 - Part 7.3: Method Overriding vs. Method Overloading](#chapter6part7.3)
      - [Chapter 6 - Part 7.4: Practical Examples and Demonstrations](#chapter6part7.4)
    - [Chapter 6 - Part 8: The `super` Keyword: Accessing Parent Class Members](#chapter6part8)
      - [Chapter 6 - Part 8.1: Understanding the super Keyword](#chapter6part8.1)
7. [Chapter 7: Exception Handling and Basic Input/Output](#chapter7)
    - [Chapter 7 - Part 1: Introduction to Exception Handling: Dealing with Errors](#chapter7part1)
      - [Chapter 7 - Part 1.1: Understanding Exceptions](#chapter7part1.1)
      - [Chapter 7 - Part 1.2: The try-catch Block: Handling Exceptions](#chapter7part1.2)
      - [Chapter 7 - Part 1.3: Common Exception Types](#chapter7part1.3)
      - [Chapter 7 - Part 1.4: Best Practices for Exception Handling](#chapter7part1.4)
    - [Chapter 7 - Part 2: The `try-catch` Block: Handling Exceptions](#chapter7part2)
      - [Chapter 7 - Part 2.1: Understanding Exceptions](#chapter7part2.1)
      - [Chapter 7 - Part 2.2: The try-catch Block: A Detailed Explanation](#chapter7part2.2)
      - [Chapter 7 - Part 2.3: Best Practices for Using try-catch Blocks](#chapter7part2.3)
    - [Chapter 7 - Part 3: The `finally` Block: Ensuring Code Executes](#chapter7part3)
      - [Chapter 7 - Part 3.1: Understanding the finally Block](#chapter7part3.1)
      - [Chapter 7 - Part 3.2: Practical Examples of Using finally](#chapter7part3.2)
      - [Chapter 7 - Part 3.3: Best Practices and Considerations](#chapter7part3.3)
    - [Chapter 7 - Part 4: Common Exception Types: NullPointerException, ArrayIndexOutOfBoundsException](#chapter7part4)
      - [Chapter 7 - Part 4.1: Understanding Exceptions](#chapter7part4.1)
      - [Chapter 7 - Part 4.2: The NullPointerException](#chapter7part4.2)
      - [Chapter 7 - Part 4.3: The ArrayIndexOutOfBoundsException](#chapter7part4.3)
    - [Chapter 7 - Part 5: Custom Exceptions](#chapter7part5)
      - [Chapter 7 - Part 5.1: What is Custom Exception](#chapter7part5.1)
      - [Chapter 7 - Part 5.2: Creating Custom Exceptions](#chapter7part5.2)
    - [Chapter 7 - Part 6: Reading Input from the Console: Using the `Scanner` Class](#chapter7part6)
      - [Chapter 7 - Part 6.1: Introduction to the Scanner Class](#chapter7part6.1)
      - [Chapter 7 - Part 6.2: Reading Different Data Types](#chapter7part6.2)
      - [Chapter 7 - Part 6.3: Handling Input Mismatch Exceptions](#chapter7part6.3)
      - [Chapter 7 - Part 6.4: Practical Examples and Demonstrations](#chapter7part6.4)
    - [Chapter 7 - Part 7: Writing Output to the Console: Using `System.out.println()`](#chapter7part7)
      - [Chapter 7 - Part 7.1: Understanding System.out.println()](#chapter7part7.1)
      - [Chapter 7 - Part 7.2: Practical Examples and Demonstrations](#chapter7part7.2)
    - [Chapter 7 - Part 8: Introduction to File Input/Output: Reading and Writing Text Files](#chapter7part8)
      - [Chapter 7 - Part 8.1: Understanding File Input/Output (I/O)](#chapter7part8.1)
      - [Chapter 7 - Part 8.2: Reading Text Files](#chapter7part8.2)
      - [Chapter 7 - Part 8.3: Writing Text Files](#chapter7part8.3)
8. [Chapter 8: Java Date and Time](#chapter8)
    - [Chapter 8 - Part 1: Java Date and Time](#chapter8part1)
9. [Chapter 9: Java Enums](#chapter9)
    - [Chapter 9 - Part 1: Java Enums](#chapter9part1)
10. [Chapter 10: Reference Type vs. Value Types, Garbage Collector, Boxing, unboxing and wrapper classes](#chapter10)
    - [Chapter 10 - Part 1: Reference Type vs. Value Types](#chapter8part1)
    - [Chapter 10 - Part 2: Garbage Collector](#chapter8part2)
    - [Chapter 10 - Part 3:  Boxing, unboxing and wrapper classes](#chapter8part3)
    - [Chapter 10 - Part 4:  hashCode and equals](#chapter8part4)
11. [Chapter 11: Java Interfaces](#chapter14)
    - [Chapter 11 - Part 1: Java Interfaces](#chapter11part1)
    - [Chapter 11 - Part 2: Dependency Injection and Inversion of Control](#chapter11part2)
    - [Chapter 11 - Part 3: Inheritance vs Interfaces](#chapter11part3)
    - [Chapter 11 - Part 4: Multiple Inheritance and Interfaces](#chapter11part4)
    - [Chapter 11 - Part 5: Comparable Interface](#chapter11part5)
    - [Chapter 11 - Part 6: Default methods](#chapter11part6)
12. [Chapter 12: Collections](#chapter12)
    - [Chapter 12 - Part 1: ArrayList](#chapter12part1)
    - [Chapter 12 - Part 2: HashMap](#chapter12part2)
    - [Chapter 12 - Part 3: HashSet](#chapter12part3)
13. [Chapter 13: Java Lambda Expression](#chapter13)
    - [Chapter 13 - Part 1: Java Lambda Expression](#chapter13part1)
   
|               |                 |                 |                 |                 |                 |                 |                 |                 | 
| :-----------: | :-------------: | :-------------: | :-------------: | :-------------: | :-------------: | :-------------: | :-------------: | :-------------: |
|               |                 |                 |                 |                 |                 |                 |                 |                 |
|               |                 |                 |                 |                 |                 |                 |                 |                 |
|               |                 |                 |                 |                 |                 |                 |                 |                 |
|               |                 |                 |                 |                 |                 |                 |                 |                 |

## <a name="chapter1"></a>Chapter 1: Introduction to Java and Setting Up Your Environment

#### <a name="chapter1part1"></a>Chapter 1 - Part 1: What is Java and Why Learn It?

Java's enduring presence in the software development landscape makes it a crucial language to learn, especially for aspiring programmers. Its versatility, platform independence, and vast ecosystem contribute to its widespread use in enterprise applications, mobile development (Android), web applications, and more. Understanding the core principles of Java and its advantages will provide a solid foundation for building robust and scalable software solutions. This lesson will explore what Java is, its key features, and the reasons why it remains a relevant and valuable skill in today's technology-driven world.

#### <a name="chapter1part1.1"></a>Chapter 1 - Part 1.1: What is Java?

Java is a high-level, class-based, object-oriented programming language that is designed to have as few implementation dependencies as possible. It is a general-purpose programming language intended to let application developers write once, run anywhere (WORA), meaning that compiled Java code can run on all platforms that support Java without the need for recompilation. Java applications are typically compiled to bytecode that can run on any Java Virtual Machine (JVM) regardless of the underlying computer architecture.

**Key Features of Java**

- **Object-Oriented**: Java is built around the concepts of objects, classes, inheritance, and polymorphism. This allows for modular, reusable, and maintainable code.
- **Platform Independent**: The "write once, run anywhere" principle is a cornerstone of Java. Java achieves this through the JVM, which acts as an intermediary between the Java code and the underlying operating system.
- **Robust**: Java has strong memory management and automatic garbage collection, preventing memory leaks and improving application stability. It also incorporates exception handling to manage runtime errors gracefully.
- **Secure**: Java provides built-in security features, such as bytecode verification and security managers, to protect against malicious code.
- **Multithreaded**: Java supports multithreading, allowing multiple threads of execution to run concurrently within a single program. This enables the development of responsive and scalable applications.
- **High Performance**: Java's performance has improved significantly over the years with advancements in JVM technology and just-in-time (JIT) compilers.
- **Dynamic**: Java is a dynamic language that supports dynamic class loading and reflection, allowing programs to load and inspect classes at runtime.

**Java Editions**

Java is available in different editions to cater to various development needs:

- **Java Standard Edition (Java SE)**: The foundation of the Java platform, providing the core libraries and APIs for developing general-purpose applications. This is what we will be focusing on in this course.
- **Java Enterprise Edition (Java EE)**: Built on top of Java SE, providing additional APIs and runtime environments for developing enterprise-level applications, such as web applications and distributed systems.
- **Java Micro Edition (Java ME)**: Designed for developing applications for embedded systems and mobile devices.

#### <a name="chapter1part1.2"></a>Chapter 1 - Part 1.2: Why Learn Java?

Java's widespread adoption and rich ecosystem make it a valuable skill for software developers. Here are some compelling reasons to learn Java:

**High Demand in the Job Market**

Java developers are in high demand across various industries. Many companies rely on Java for building and maintaining their enterprise applications, web applications, and Android mobile apps. Learning Java can open doors to numerous job opportunities with competitive salaries.

**Versatility and Portability**

Java's platform independence allows developers to write code once and run it on any platform that supports the JVM. This versatility makes Java suitable for developing a wide range of applications, from desktop applications to web applications to mobile apps.

**Large and Active Community**

Java has a large and active community of developers who contribute to its growth and provide support to fellow developers. This community offers a wealth of resources, including online forums, tutorials, and open-source libraries, making it easier to learn and use Java.

**Extensive Libraries and Frameworks**

Java boasts a rich collection of libraries and frameworks that simplify the development process and provide pre-built components for common tasks. Some popular Java frameworks include Spring, Hibernate, and Struts.

**Android App Development**

Java is the primary language for developing Android mobile apps. Learning Java is essential for anyone who wants to build apps for the Android platform, which has a massive user base worldwide.

**Enterprise Application Development**

Java is widely used in enterprise application development due to its scalability, reliability, and security features. Many large organizations rely on Java for building their mission-critical systems.

**Real-World Examples**

- **Enterprise Applications**: Large financial institutions and e-commerce companies use Java to build their backend systems, handle transactions, and manage customer data.
- **Android Mobile Apps**: Popular apps like Spotify, Twitter, and many games are built using Java (or Kotlin, which is fully interoperable with Java) for the Android platform.
- **Web Applications**: Many web applications, including those used for online banking, e-learning platforms, and social media, are built using Java frameworks like Spring.

#### <a name="chapter1part2"></a>Chapter 1 - Part 2: Understanding the Java Ecosystem: JVM, JRE, JDK

The Java ecosystem is a crucial foundation for understanding how Java code runs and interacts with your computer. It's comprised of three core components: the Java Virtual Machine (JVM), the Java Runtime Environment (JRE), and the Java Development Kit (JDK). Each plays a distinct role in the development and execution of Java applications. Understanding these components is essential for any Java developer, as it allows you to troubleshoot issues, optimize performance, and choose the right tools for your projects. This lesson will provide a comprehensive overview of each component, their relationships, and their significance in the Java development process.

#### <a name="chapter1part2.1"></a>Chapter 1 - Part 2.1: Compilation and Interpretation, Source Code and Object Code, Virtual Machine

The Basic operations of a computer is Input of Data, Processing of Data and the output of the result or data.

The processing is made by the CPU

<br>

<div align="center"><img src="img/basic-operations-computer-w562-h190.gif" width=562 height=190><br><sub>Fig 15 -Basic Operations of a Computer - (<a href='http://cs.sru.edu/~mullins/cpsc100book/module02_introduction/module02-04_introduction.html'>Work by Paul Mullins</a>) </sub></div>

<br>

**Source Code**: is the code written by the programmer in a programming language

Ex:

```java
package application;

import java.util.Scanner;
import java.util.Locale;

public class Program {

	public static void main(String[] args) {
		
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
        	double x, y, media;
        
		System.out.print("Enter the First Number: ");
        	x = sc.nextDouble(); //input: 2
        	System.out.print("Enter the Second Number: ");
        	y = sc.nextDouble(); //input: 4
        
        	media = (x + y)/2.0;
        
       		System.out.println("Media = " + media);
        	sc.close();
	}
}

/*
Console

----input---
Enter the First Number: 2.0
Enter the First Number: 4.0

----output---
Media = 3.0
*/
```
<br>

<div align="center"><img src="img/compilation-interpretation-w1353-h638.png" width=1000 height=500><br><sub>Fig 1 - Compilation and Interpretation Process</sub></div>

<br>

<div align="center"><img src="img/hybrid-w1079-h395.png" width=1300 height=500><br><sub>Fig 2 - Hybrid Process</sub></div>

<br>

- **Compilation**:
	- Program Speed
	- Compiler Assistance Before Execution
	- Disadvantage: Platform dependence of the generated binary code

- **Interpretation**:
	- Flexibility of Maintaining the Application in Production
	- Expressiveness of Language
	- Source Code does not need to be Recompiled to run on different platform
	- Disadvantage: Execution speed compared to compiled languages.

- **Hybrid**:
	- Compiler Assistance Before Execution
	- Source Code does not need to be Recompiled to run on different platform

#### <a name="chapter1part2.2"></a>Chapter 1 - Part 2.2: The Java Virtual Machine (JVM)

JVM is the Java Virtual Machine to execute Java Programs in your system.

Java take the advantages of compilation and interpretation and create the hybrid interpretation with JVM.

Below, there some of compilation process examples in Java:

<br>

<div align="center"><img src="img/java-compiler-process-w700-h676.png" width=700 height=676><br><sub>Fig 3 - Compilation Process in Java - (<a href='https://medium.com/@PrayagBhakar/lesson-2-behind-the-scenes-4df6a461f31f'>Work by Prayag Bhakar</a>) </sub></div>

<br>

<div align="center"><img src="img/java-compiler-process2-w487-h317.png" width=487 height=317><br><sub>Fig 4 - Compilation Process in Java - (<a href='https://www3.ntu.edu.sg/home/ehchua/programming/java/J1a_Introduction.html'>Work by Chua Hock-Chuan</a>) </sub></div>

<br>

<div align="center"><img src="img/java-compiler-process3-w612-h242.png" width=612 height=242><br><sub>Fig 5 - Compilation Process in Java - (<a href='https://www.w3schools.in/java-tutorial/compile-java-file-using-javac/'>Work by  w3schools</a>) </sub></div>

<br>

The process to execute the bytecode is called JIT (Just in Time) Compilation. Is more faster than interpretation because the compiler revise before the run time, if the bytecode is lexical and syntactical correct.

<br>

<div align="center"><img src="img/java-compiler-process4-w557-h617.png" width=557 height=617><br><sub>Fig 6 - Compilation Process in Java - (<a href='http://javaeesupportpatterns.blogspot.com/2013/07/java-just-in-time-compilation-more-than.html'>Work by javaeesupportpatterns</a>) </sub></div>

<br>

The Java Virtual Machine (JVM) is the heart of the Java platform. It's an abstract computing machine, meaning it's a specification that can be implemented in different ways by different vendors. The JVM's primary role is to execute Java bytecode.

**What is Bytecode?**

When you write Java code, it's saved in .java files. These files are then compiled by the Java compiler (javac) into .class files. These .class files contain bytecode, which is a platform-independent set of instructions that the JVM can understand and execute.

Example:

Let's say you have a simple Java program:

```java
public class Example {
    public static void main(String[] args) {
        int x = 10;
        int y = 5;
        int sum = x + y;
        System.out.println("Sum: " + sum);
    }
}
```

After compiling this code, the Example.class file will contain bytecode instructions that tell the JVM how to perform the addition and print the result. You can inspect the bytecode using the javap command-line tool (part of the JDK): javap -c Example. The output will be assembly-like instructions.

**Key Functions of the JVM**

- **Loading Bytecode**: The JVM loads .class files containing bytecode into memory.
- **Bytecode Verification**: Before executing bytecode, the JVM verifies that it's valid and doesn't violate any security constraints. This helps prevent malicious code from harming the system.
- **Execution**: The JVM executes the bytecode instructions. This can be done through interpretation or just-in-time (JIT) compilation.
- **Just-in-Time (JIT) Compilation**: The JIT compiler is a part of the JVM that translates bytecode into native machine code during runtime. This significantly improves performance because native code executes much faster than interpreted bytecode. The JIT compiler analyzes the bytecode and identifies frequently executed sections (hotspots) to optimize.
- **Memory Management**: The JVM automatically manages memory through garbage collection. It allocates memory for objects and reclaims memory that is no longer in use, preventing memory leaks.

**JVM Implementations**

Different vendors provide their own implementations of the JVM specification. Some popular JVM implementations include:

- **HotSpot**: Developed by Oracle, HotSpot is the most widely used JVM. It's known for its advanced JIT compilation and garbage collection capabilities.
- **OpenJ9**: Developed by Eclipse, OpenJ9 is another high-performance JVM that's designed for cloud environments.
- **GraalVM**: A polyglot VM that supports multiple languages, including Java. GraalVM can also compile Java code ahead-of-time (AOT) for faster startup times.

**Platform Independence**

The JVM is what makes Java platform-independent. Because the bytecode is executed by the JVM, the same Java code can run on any operating system that has a JVM implementation. This "write once, run anywhere" (WORA) capability is a key advantage of Java.

Example:

You can compile your Java code on a Windows machine and then run the resulting .class files on a Linux server, as long as both machines have a compatible JVM installed.

**Hypothetical Scenario**

Imagine a company developing a cross-platform application that needs to run on Windows, macOS, and Linux. By using Java, they can write the application once and deploy it to all three platforms without having to rewrite the code for each operating system. The JVM handles the platform-specific details, allowing the developers to focus on the application logic.

#### <a name="chapter1part2.3"></a>Chapter 1 - Part 2.3: The Java Runtime Environment (JRE)

The Java Runtime Environment (JRE) provides the necessary resources to run Java applications. It includes the JVM, along with libraries and other components needed to execute Java bytecode.

**Components of the JRE**

- **JVM**: As mentioned earlier, the JVM is the core component of the JRE.
- **Java Class Libraries**: The JRE includes a set of standard Java class libraries that provide pre-built functionality for common tasks, such as input/output, networking, and data structures. These libraries are essential for developing Java applications.
- **Other Supporting Files**: The JRE also includes other supporting files, such as configuration files and security policies.

**JRE vs. JVM**

It's important to understand the difference between the JRE and the JVM. The JVM is the abstract specification for executing bytecode, while the JRE is a concrete implementation of that specification, along with the necessary libraries and supporting files. You can think of the JRE as a package that contains the JVM and everything else needed to run Java applications.

Analogy:

Think of the JVM as an engine and the JRE as the entire car. The engine (JVM) is responsible for running the car, but the car (JRE) also includes the wheels, seats, and other components needed to make it functional.

**Using the JRE**

When you want to run a Java application, you need to have the JRE installed on your system. The JRE provides the java command, which you use to launch Java applications.

Example:

To run a Java application named MyApp.class, you would use the following command:

```
java MyApp
```

This command tells the JRE to load the MyApp.class file, start the JVM, and execute the bytecode in the file.

**Real-World Example**

Consider a web server that hosts Java-based web applications. The server needs to have the JRE installed to run these applications. When a user accesses a web page that requires Java code to be executed, the JRE on the server handles the execution of that code.

**Hypothetical Scenario**

A small business uses a Java-based accounting application. Each employee who needs to use the application must have the JRE installed on their computer. The JRE allows them to run the application and access the company's financial data.

#### <a name="chapter1part2.4"></a>Chapter 1 - Part 2.4: The Java Development Kit (JDK)

The Java Development Kit (JDK) is a superset of the JRE. It includes everything in the JRE, plus additional tools and utilities needed for developing Java applications.

**Components of the JDK**

- **JRE**: The JDK includes the complete JRE.
- **Java Compiler (javac)**: The javac compiler translates Java source code (.java files) into bytecode (.class files).
- **Java Debugger (jdb)**: The jdb debugger allows you to debug Java code by stepping through the code, inspecting variables, and setting breakpoints.
- **Java Archive (jar)**: The jar tool allows you to package Java class files and resources into a single archive file (.jar file).
- **Java Documentation Generator (javadoc)**: The javadoc tool generates HTML documentation from Java source code comments.
- **Other Development Tools**: The JDK also includes other development tools, such as jconsole (for monitoring JVM performance) and jprofiler (for profiling Java applications).

**JDK vs. JRE**

The key difference between the JDK and the JRE is that the JDK is for developers, while the JRE is for users who just want to run Java applications. If you want to write, compile, and debug Java code, you need the JDK. If you just want to run Java applications, you only need the JRE.

Analogy:

Think of the JDK as a mechanic's toolkit and the JRE as the car itself. The mechanic (developer) needs the toolkit (JDK) to build and repair cars, while the driver (user) only needs the car (JRE) to drive.

**Using the JDK**

When you install the JDK, you get access to the javac compiler, which you use to compile your Java code.

Example:

To compile the Example.java file, you would use the following command:

```
javac Example.java
```

This command creates the Example.class file containing the bytecode.

**Real-World Example**

A software development company uses the JDK to develop and maintain its Java-based applications. The developers use the javac compiler to compile the code, the jdb debugger to debug the code, and the jar tool to package the applications for deployment.

**Hypothetical Scenario**

A student learning Java needs to install the JDK on their computer to write and run Java programs. The JDK provides the necessary tools for compiling, debugging, and testing their code.

#### <a name="chapter1part2.5"></a>Chapter 1 - Part 2.5: Relationship Between JVM, JRE, and JDK

The JVM, JRE, and JDK are closely related. The JDK includes the JRE, and the JRE includes the JVM.

```
JDK (Java Development Kit)
  |
  +-- JRE (Java Runtime Environment)
      |
      +-- JVM (Java Virtual Machine)
```

- The JDK is the complete development environment for Java applications.
- The JRE is the runtime environment for executing Java applications.
- The JVM is the virtual machine that executes Java bytecode.

#### <a name="chapter1part2.6"></a>Chapter 1 - Part 2.6: Choosing the Right Version

When installing the JDK or JRE, you'll need to choose a version. Oracle releases new versions of Java regularly, and each version may include new features, performance improvements, and security updates. It's generally recommended to use the latest stable version of the JDK or JRE, unless you have a specific reason to use an older version.

**Long-Term Support (LTS) Versions**

Oracle designates certain Java versions as Long-Term Support (LTS) versions. LTS versions receive extended support and security updates, making them a good choice for production environments. As of this writing, Java 11 and Java 17 are LTS versions.

**Considerations**

- **Compatibility**: Make sure that the version of the JDK or JRE you choose is compatible with your applications and libraries.
- **New Features**: Consider whether you need the new features and improvements offered by the latest version.
- **Support**: Choose an LTS version for long-term stability and support.

#### <a name="chapter1part3"></a>Chapter 1 - Part 3: Installing the Java Development Kit (JDK)

Installing the Java Development Kit (JDK) is the first crucial step in your journey to becoming a Java programmer. The JDK provides the necessary tools to compile, run, and debug Java code. Without it, you won't be able to execute the programs you write. This lesson will guide you through the process of downloading and installing the JDK on your system, ensuring you have a solid foundation for the rest of the course.

#### <a name="chapter1part3.1"></a>Chapter 1 - Part 3.1: Understanding the JDK and its Components

The Java JDK come with some of most used packages to help the developer like awt, beans, io, lang, math, net, nio, sql, util and each package have a class or a interface.

<br>

<div align="center"><img src="img/packages-jdk-w646-h292.png" width=646 height=292><br><sub>Fig 8 -Java Packages - (<a href='http://www.wellnwill.com/tutorial/core-java/package/package'>Work by Well N Will</a>) </sub></div>

<br>

Oracle have a documentation about all his packages: https://docs.oracle.com/javase/8/docs/api/

<br>

<div align="center"><img src="img/packages-jdk2-w788-h483.png" width=788 height=483><br><sub>Fig 9 -Java Packages - (<a href='https://docs.oracle.com/javase/8/docs/technotes/guides/desc_jdk_structure.html'>Work by Oracle</a>) </sub></div>

<br>

One of the most famous used packages is java.util.collections and java.util.map

<br>

<div align="center"><img src="img/packages-jdk4-w1512-h1252.png" width=500 height=400><br><sub>Fig 10 -Java Packages - (<a href='https://ukode.es/colecciones-i-introduccion-y-conceptos-basicos/'>Work by Jose Antonio Simón</a>) </sub></div>

<br>

<div align="center"><img src="img/packages-jdk3-w1720-h693.png" width=700 height=300><br><sub>Fig 11 -Java Packages - (<a href='https://ukode.es/colecciones-i-introduccion-y-conceptos-basicos/'>Work by Jose Antonio Simón</a>) </sub></div>

<br>

<div align="center"><img src="img/packages-jdk5-w854-h715.png" width=854 height=715><br><sub>Fig 12 -Java Packages - (<a href='https://www.javatpoint.com/collections-in-java'>Work by JavaPoint</a>) </sub></div>

<br>

The Java Development Kit (JDK) is a software development environment used for developing Java applications. It includes the Java Runtime Environment (JRE), compilers, debuggers, and other tools necessary for developing, testing, and running Java programs.

**Key Components of the JDK**

- **Java Runtime Environment (JRE)**: The JRE provides the runtime environment in which Java programs can execute. It includes the Java Virtual Machine (JVM), core classes, and supporting files. You encountered the JRE in the previous lesson when learning about the Java ecosystem.
- **Java Compiler (javac)**: This tool compiles Java source code (.java files) into bytecode (.class files) that can be executed by the JVM.
- **Java Debugger (jdb)**: This tool helps you find and fix errors in your Java code.
- **Java Archive (jar)**: This tool packages Java class files and related resources into a single archive file.
- **Other Tools**: The JDK also includes other useful tools such as javadoc (for generating API documentation) and jps (for listing running Java processes).

**Why is the JDK Necessary?**

The JDK is essential because it provides the tools needed to translate human-readable Java code into machine-executable bytecode. Without the JDK, you can't compile your code, and therefore, you can't run it. The JRE alone is sufficient for running pre-compiled Java applications, but the JDK is required for developing them.

#### <a name="chapter1part3.2"></a>Chapter 1 - Part 3.2: Downloading the JDK

The JDK can be downloaded from several sources, but the most common and recommended source is Oracle. Alternatively, you can use OpenJDK builds from vendors like Adoptium (Eclipse Temurin).

**Downloading from Oracle**

- **Visit the Oracle Website**: Go to the Oracle Java SE Downloads page.
- **Choose the Appropriate Version**: Select the latest Long-Term Support (LTS) version of Java. LTS versions are supported for a longer period, making them a stable choice for development.
- **Select Your Operating System**: Choose the appropriate installer for your operating system (Windows, macOS, or Linux).
- **Download the Installer**: Download the installer file. You may need to create an Oracle account to proceed with the download.

**Downloading from Adoptium (Eclipse Temurin)**

- **Visit the Adoptium Website**: Go to the Adoptium website.
- **Choose the Appropriate Version**: Select the latest LTS version of Java.
- **Select Your Operating System**: Choose the appropriate installer for your operating system (Windows, macOS, or Linux).
- **Download the Installer**: Download the installer file.

#### <a name="chapter1part3.3"></a>Chapter 1 - Part 3.3: Installing the JDK

The installation process varies slightly depending on your operating system.

**Installing on Windows**

- **Run the Installer**: Double-click the downloaded installer file to start the installation process.

- **Follow the Prompts**: Follow the on-screen instructions. You'll typically be prompted to choose an installation directory. The default location is usually fine.

- **Set the JAVA_HOME Environment Variable**:
  - Open the System Properties window (search for "environment variables" in the Start menu).
  - Click "Environment Variables".
  - Under "System variables", click "New".
  - Enter JAVA_HOME as the variable name.
  - Enter the installation directory of the JDK as the variable value (e.g., C:\Program Files\Java\jdk-17).
  - Click "OK" to close all windows.
 
- **Update the Path Environment Variable**:
  - In the System Variables section, find the Path variable and select it, then click "Edit".
  - Click "New" and add %JAVA_HOME%\bin to the list.
  - Click "OK" to close all windows.
 
- **Verify the Installation**: Open a new command prompt window and type java -version. You should see the version information for the installed JDK.

**Installing on macOS**

- **Run the Installer**: Double-click the downloaded .dmg file to mount it.

- **Open the Package**: Double-click the .pkg file to start the installation process.

- **Follow the Prompts**: Follow the on-screen instructions. The JDK will typically be installed in /Library/Java/JavaVirtualMachines/.

- **Set the JAVA_HOME Environment Variable (Optional)**: While macOS doesn't strictly require setting JAVA_HOME, some tools might rely on it. You can set it in your .bash_profile or .zshrc file:
  - Open Terminal.
  - Type nano ~/.zshrc (or nano ~/.bash_profile if you're using Bash).
  - Add the following lines:

```
export JAVA_HOME=$(/usr/libexec/java_home)
export PATH=$JAVA_HOME/bin:$PATH
```

  - Press Ctrl+X, then Y, then Enter to save and exit.
  - Type source ~/.zshrc (or source ~/.bash_profile) to apply the changes.

- **Verify the Installation**: Open a new Terminal window and type java -version. You should see the version information for the installed JDK.

**Installing on Linux**

The installation process on Linux varies depending on the distribution. Here are instructions for Debian/Ubuntu and Fedora/CentOS.

**Debian/Ubuntu**

- **Download the .deb Package**: Download the .deb package for your architecture.

- **Install the Package**: Open a terminal and navigate to the directory where you downloaded the package. Then, run the following command:

```
sudo apt install ./<package_name>.deb
```

Replace <package_name>.deb with the actual name of the downloaded file.

- **Set the JAVA_HOME Environment Variable**:
  - Open the /etc/environment file with root privileges:
 
```
sudo nano /etc/environment
```

  - Add the following line, replacing /usr/lib/jvm/java-17-openjdk-amd64 with the actual path to your JDK installation:

```
JAVA_HOME="/usr/lib/jvm/java-17-openjdk-amd64"
```

  - Save the file and exit.
  - Apply the changes by running:

```
source /etc/environment
```

- **Update the Path Environment Variable**:

  - Edit the ~/.bashrc or ~/.zshrc file:
 
```
nano ~/.bashrc
```

  - Add the following lines:

```
export PATH="$JAVA_HOME/bin:$PATH"
```

- Save the file and exit.
- Apply the changes by running:

```
source ~/.bashrc
```

- **Verify the Installation**: Open a new terminal window and type java -version. You should see the version information for the installed JDK.

**Fedora/CentOS**

- **Download the .rpm Package**: Download the .rpm package for your architecture.

- **Install the Package**: Open a terminal and navigate to the directory where you downloaded the package. Then, run the following command:

```
sudo rpm -i <package_name>.rpm
```

Replace <package_name>.rpm with the actual name of the downloaded file.

- **Set the JAVA_HOME Environment Variable**:
  
  - Open the /etc/environment file with root privileges:
 
```
sudo nano /etc/environment
```

  - Add the following line, replacing /usr/lib/jvm/java-17-openjdk-amd64 with the actual path to your JDK installation:

```
JAVA_HOME="/usr/lib/jvm/java-17-openjdk-amd64"
```

- Save the file and exit.
- Apply the changes by running:

```
source /etc/environment
```

- **Update the Path Environment Variable**:
  - Edit the ~/.bashrc or ~/.zshrc file:
 
```
nano ~/.bashrc
```

  - Add the following lines:

```
export PATH="$JAVA_HOME/bin:$PATH"
```

- Save the file and exit.
- Apply the changes by running:

```
source ~/.bashrc
```

- **Verify the Installation**: Open a new terminal window and type java -version. You should see the version information for the installed JDK.

#### <a name="chapter1part3.4"></a>Chapter 1 - Part 3.4: Setting Environment Variables

Setting environment variables is a crucial step in the installation process. These variables tell your operating system where to find the Java executables.

**Why are Environment Variables Important?**

Environment variables allow you to run Java commands from any directory in your terminal or command prompt. Without them, you would have to navigate to the JDK's bin directory every time you want to compile or run a Java program.

```**JAVA_HOME**```

The JAVA_HOME variable points to the installation directory of the JDK. This variable is used by many Java-based tools and applications to locate the JDK.

```**Path**```

The Path variable is a list of directories that the operating system searches when you execute a command. By adding the JDK's bin directory to the Path, you can run Java commands like java and javac from any directory.

#### <a name="chapter1part3.5"></a>Chapter 1 - Part 3.5: Verifying the Installation

After installing the JDK and setting the environment variables, it's important to verify that the installation was successful.

**Using the Command Line**

Open a new command prompt or terminal window and type the following command:

```
java -version
```

If the JDK is installed correctly, you should see output similar to the following:

```
java 17.0.2 2022-01-18 LTS
Java(TM) SE Runtime Environment (build 17.0.2+8-LTS-86)
Java HotSpot(TM) 64-Bit Server VM (build 17.0.2+8-LTS-86, mixed mode, sharing)
```

This output confirms that the Java runtime environment is installed and accessible.

Next, type the following command:

```
javac -version
```

If the JDK is installed correctly, you should see output similar to the following:

```
javac 17.0.2
```

This output confirms that the Java compiler is installed and accessible.

If you don't see this output, double-check that you have set the JAVA_HOME and Path environment variables correctly and that you have opened a new command prompt or terminal window after setting them.

#### <a name="chapter1part3.6"></a>Chapter 1 - Part 3.6: Troubleshooting Common Installation Issues

Even with careful instructions, installation issues can arise. Here are some common problems and their solutions:

**```java``` or ```javac``` Command Not Found**

This usually indicates that the Path environment variable is not set correctly. Double-check that you have added the JDK's bin directory to the Path and that you have opened a new command prompt or terminal window.

**Incorrect Java Version**

If you have multiple versions of Java installed on your system, the java -version command might show the wrong version. Ensure that the JAVA_HOME variable points to the correct JDK installation directory.

**Installation Errors**

If you encounter errors during the installation process, consult the JDK documentation or search online for solutions specific to your operating system and the error message you received.

#### <a name="chapter1part4"></a>Chapter 1 - Part 4: Setting Up a Java Development Environment (IDE): IntelliJ IDEA or Eclipse

Setting up a Java Development Environment (IDE) is a crucial step for any aspiring Java programmer. An IDE provides a comprehensive suite of tools that streamline the coding process, making it easier to write, debug, and run Java applications. This lesson will guide you through the process of setting up two popular IDEs: IntelliJ IDEA and Eclipse. We'll explore their key features, installation procedures, and basic configurations to get you ready to write your first Java programs.

#### <a name="chapter1part4.1"></a>Chapter 1 - Part 4.1: Understanding Integrated Development Environments (IDEs)

An Integrated Development Environment (IDE) is a software application that provides comprehensive facilities to computer programmers for software development. An IDE normally consists of at least a source code editor, build automation tools, and a debugger.

**Key Features of an IDE**

- **Source Code Editor**: A text editor designed specifically for writing and editing code, with features like syntax highlighting, code completion, and code formatting.
- **Build Automation Tools**: Tools that automate the process of compiling, linking, and packaging code into executable programs.
- **Debugger**: A tool that allows developers to step through code, inspect variables, and identify and fix errors.
- **Compiler**: Translates human-readable code into machine-executable code.
- **Interpreter**: Executes code line by line.
- **Version Control Integration**: Integration with version control systems like Git, allowing developers to track changes to their code and collaborate with others.
- **Testing Tools**: Tools for writing and running unit tests and integration tests.
- **Refactoring Tools**: Tools for restructuring code without changing its behavior, making it easier to maintain and improve.

**Why Use an IDE?**

Using an IDE offers several advantages over using a simple text editor and command-line tools:

- **Increased Productivity**: IDEs automate many common tasks, such as compiling code, running tests, and debugging, which can save developers a significant amount of time.
- **Improved Code Quality**: IDEs provide features like syntax highlighting, code completion, and code formatting, which can help developers write cleaner, more readable code.
- **Easier Debugging**: IDEs provide powerful debugging tools that allow developers to step through code, inspect variables, and identify and fix errors more easily.
- **Better Collaboration**: IDEs integrate with version control systems, making it easier for developers to collaborate on projects.

#### <a name="chapter1part4.2"></a>Chapter 1 - Part 4.2: IntelliJ IDEA

IntelliJ IDEA is a popular Java IDE known for its intelligent code assistance, comprehensive feature set, and user-friendly interface. It is developed by JetBrains and is available in two editions: Community (free and open-source) and Ultimate (commercial). For beginners, the Community Edition is sufficient.

**Installing IntelliJ IDEA**

- **Download IntelliJ IDEA**: Go to the JetBrains website (https://www.jetbrains.com/idea/download/) and download the Community Edition for your operating system (Windows, macOS, or Linux).

- **Run the Installer**: Once the download is complete, run the installer and follow the on-screen instructions.

- **Installation Options**: During the installation process, you may be prompted to configure some options, such as:
  - **Installation Location**: Choose the directory where you want to install IntelliJ IDEA.
  - **Create Desktop Shortcut**: Create a shortcut on your desktop for easy access to IntelliJ IDEA.
  - **Update PATH variable (restart needed)**: Add IntelliJ IDEA's bin folder to your system's PATH variable, allowing you to run IntelliJ IDEA from the command line.
  - **Associate .java**: Associate .java files with IntelliJ IDEA, so that double-clicking a .java file will open it in IntelliJ IDEA.
 
- **Complete the Installation**: Once you have configured the options, click "Install" to begin the installation process.

- **Run IntelliJ IDEA**: After the installation is complete, you can run IntelliJ IDEA from the Start menu (Windows) or the Applications folder (macOS).

**Configuring IntelliJ IDEA**

- **Import Settings (Optional)**: If you have used IntelliJ IDEA before, you can import your settings from a previous installation. Otherwise, choose "Do not import settings."
- **UI Theme**: Choose a UI theme (e.g., Light or Dark).
- **Featured Plugins**: IntelliJ IDEA suggests installing some featured plugins. You can install them now or later.
- **Start Using IntelliJ IDEA**: Click "Start using IntelliJ IDEA" to open the IDE.

**Creating a New Java Project in IntelliJ IDEA**

- **Open IntelliJ IDEA**: Launch IntelliJ IDEA.
- **Create New Project**: On the Welcome screen, click "New Project."
- **Choose Project Type**: In the "New Project" dialog, select "Java" from the left-hand menu.
- **Project SDK**: Ensure that the Project SDK is set to the JDK you installed in the previous lesson. If it's not, click "Install JDK" or select the correct JDK from the dropdown menu.
- **Project Template**: You can choose a template or create an empty project. For a simple project, select "Create project from template" and choose "Command Line App".
- **Project Name and Location**: Enter a name for your project (e.g., "HelloWorld") and choose a location to save the project files.
- **Finish**: Click "Finish" to create the project.

**IntelliJ IDEA Interface Overview**

- **Project Tool Window**: Displays the project structure, including source files, libraries, and other resources.
- **Editor Window**: Where you write and edit your code.
- **Navigation Bar**: Located at the top of the editor window, it shows the current file path and allows you to navigate to other files.
- **Run/Debug Tool Window**: Displays the output of your program and allows you to debug your code.
- **Terminal Tool Window**: Provides a command-line interface for running commands and scripts.

#### <a name="chapter1part4.3"></a>Chapter 1 - Part 4.3: Eclipse

Eclipse is another popular open-source IDE widely used for Java development. It's known for its flexibility, extensive plugin ecosystem, and strong community support.

**Installing Eclipse**

- **Download Eclipse**: Go to the Eclipse website (https://www.eclipse.org/downloads/) and download the Eclipse IDE for Java Developers for your operating system.
- **Run the Installer**: Run the installer and follow the on-screen instructions.
- **Choose Installation Folder**: Select the directory where you want to install Eclipse.
- **Launch Eclipse**: Once the installation is complete, you can launch Eclipse from the Start menu (Windows) or the Applications folder (macOS).

**Configuring Eclipse**

- **Workspace**: When you first launch Eclipse, you will be prompted to choose a workspace. A workspace is a directory where Eclipse stores your project files and settings. Choose a location for your workspace and click "Launch."
- **Welcome Screen**: The Eclipse Welcome screen provides links to tutorials, documentation, and other resources. You can close the Welcome screen to start using Eclipse.

**Creating a New Java Project in Eclipse**

- **Open Eclipse**: Launch Eclipse.
- **Create New Project**: Go to File > New > Java Project.
- **Project Name**: Enter a name for your project (e.g., "HelloWorld").
- **Use default location**: You can either use the default location or specify a custom location for your project.
- **JRE**: Ensure that the JRE is set to the JDK you installed in the previous lesson. If it's not, click "Configure JREs" and add the correct JDK.
- **Layout**: Keep the default project layout.
- **Finish**: Click "Finish" to create the project.

**Eclipse Interface Overview**

- **Package Explorer**: Displays the project structure, including source files, libraries, and other resources.
- **Editor Area**: Where you write and edit your code.
- **Outline View**: Displays the structure of the current file, including classes, methods, and fields.
- **Console View**: Displays the output of your program.
- **Problems View**: Displays errors and warnings in your code.

#### <a name="chapter1part5"></a>Chapter 1 - Part 5: Writing and Running Your First Java Program: "Hello, World!"

Let's embark on the journey of writing and running your very first Java program. This is a pivotal step in becoming a Java programmer. We'll create the classic "Hello, World!" program, which serves as a fundamental introduction to the structure and execution of Java code. This exercise will solidify your understanding of the Java Development Kit (JDK) and the Integrated Development Environment (IDE) you set up in the previous lessons. By the end of this lesson, you'll have a tangible result – a working Java program – and a foundational understanding of how to build upon it.

#### <a name="chapter1part5.1"></a>Chapter 1 - Part 5.1: Creating Your First Java Program: "Hello, World!"

The "Hello, World!" program is a time-honored tradition in programming. It's a simple program that displays the text "Hello, World!" on the console. Creating this program in Java involves a few key steps: writing the code, saving the file, compiling the code, and running the compiled code.

**Step 1: Writing the Code**

Open your chosen IDE (IntelliJ IDEA or Eclipse). Create a new Java file. The name of the file should match the name of the class you'll define within it, and it should end with the .java extension. For this example, let's name the file HelloWorld.java.

Now, enter the following code into the HelloWorld.java file:

```java
public class HelloWorld { // Declares a class named HelloWorld
    public static void main(String[] args) { // Declares the main method
        System.out.println("Hello, World!"); // Prints "Hello, World!" to the console
    }
}
```

Let's break down this code:

- ```**public class HelloWorld { ... }**```: This line declares a class named HelloWorld. In Java, everything resides within a class. The public keyword means that this class can be accessed from anywhere in your program. Classes are the fundamental building blocks of Java programs, and we'll delve deeper into them in Module 5.

- ```**public static void main(String[] args) { ... }**```: This is the main method. It's the entry point of your program – the code that the Java Virtual Machine (JVM) executes first.
  - ```**public**```: Similar to the class, public means this method can be accessed from anywhere.
  - ```**static**```: This keyword means that the method belongs to the HelloWorld class itself, rather than to an instance of the HelloWorld class. We'll explore static methods in more detail in Module 6.
  - ```**void**```: This indicates that the method doesn't return any value. Methods can perform actions and optionally return a result.
  - ```**main(String[] args)**```: This is the name of the method (main) and its parameters. String[] args is an array of strings that can be used to pass arguments to the program from the command line. We won't use command-line arguments in this simple program, but they can be useful for more complex applications.
 
- ```**System.out.println("Hello, World!");**```: This line is the heart of the program. It prints the text "Hello, World!" to the console.
  - ```**System.out**```: This is a standard output stream in Java. It represents the console (your terminal or command prompt).
  - ```**println()**```: This is a method of the System.out object that prints a line of text to the console. The text to be printed is enclosed in double quotes " ".
 
**Step 2: Saving the File**

Save the file as HelloWorld.java in a directory of your choice. Make sure the file name matches the class name exactly (including capitalization).

**Step 3: Compiling the Code**

Before you can run the program, you need to compile it. Compilation is the process of translating the human-readable Java code into bytecode, which the JVM can understand and execute.

- **Using IntelliJ IDEA**: IntelliJ IDEA usually compiles your code automatically as you type. However, you can also manually compile the code by going to Build > Build Project.
- **Using Eclipse**: Eclipse also typically compiles your code automatically. If not, you can compile it by going to Project > Build Project.

If the compilation is successful, you won't see any error messages. If there are errors, the IDE will highlight them and provide descriptions to help you fix them. Common errors include typos, missing semicolons, and incorrect syntax.

**Step 4: Running the Code**

Once the code is compiled successfully, you can run it.

- **Using IntelliJ IDEA**: Right-click in the code editor and select Run 'HelloWorld.main()'. Alternatively, you can click the green "play" button in the gutter next to the main method declaration.
- **Using Eclipse**: Right-click in the code editor and select Run As > Java Application.

If everything is set up correctly, you should see the text "Hello, World!" printed on the console in your IDE.

#### <a name="chapter1part5.2"></a>Chapter 1 - Part 5.2: Understanding the Compilation Process

The compilation process is a crucial step in Java development. When you compile a Java program, the Java compiler (javac) takes your .java file as input and produces a .class file. This .class file contains the bytecode representation of your program. Bytecode is a platform-independent intermediate language that the JVM can execute.

The JVM then interprets or compiles this bytecode into machine code that is specific to the underlying operating system and hardware. This is what makes Java platform-independent – the same bytecode can run on any system that has a JVM.

#### <a name="chapter1part5.3"></a>Chapter 1 - Part 5.3: Common Errors and Troubleshooting

| Compile-time                                                                                                              | Runtime                                                                                                                              | 
| :------------------------------------------------------------------------------------------------------------------------ | :-----------------------------------------------------------------------------------------------------------------------------------:|
| The compile-time errors are the errors which are produced at the compile-time, and they are detected by the compiler.     | The runtime errors are the errors which are not generated by the compiler and produce an unpredictable result at the execution time. |
| In this case, the compiler prevents the code from execution if it detects an error in the program.]                       | In this case, the compiler does not detect the error, so it cannot prevent the code from the execution.                              |
| It contains the syntax and semantic errors such as missing semicolon at the end of the statement.                         | It contains the errors such as division by zero, determining the square root of a negative number.                                   |

Even with a simple program like "Hello, World!", you might encounter errors. Here are some common errors and how to fix them:

- ```**ClassNotFoundException**```: This error usually means that the JVM can't find the .class file for your program. Make sure that the file is in the correct directory and that the class name matches the file name. Also, ensure that the code has been compiled.
- ```**NoSuchMethodError**```: main: This error indicates that the JVM can't find the main method in your class. Double-check that the main method is declared exactly as public static void main(String[] args).
- ```**Syntax errors**```: These errors are usually caused by typos, missing semicolons, or incorrect syntax. The IDE will typically highlight these errors and provide descriptions to help you fix them. Pay close attention to the error messages and carefully review your code.

#### <a name="chapter1part6"></a>Chapter 1 - Part 6: Understanding Basic Java Program Structure

Understanding the basic structure of a Java program is crucial for writing any Java code. It's like learning the alphabet before writing sentences. This lesson will break down the essential components of a Java program, explaining each part in detail and providing examples to illustrate how they work together. By the end of this lesson, you'll be able to read, understand, and write simple Java programs with confidence, setting a solid foundation for more advanced topics.

Java is an object-oriented language and your base unit is the class.  Every Code in Java have to be in a class.

The classes is organize in packages and the packages is organize in modules. A Java application is a set of modules with packages.

Bellow, there is a example of a Java application:

<br>

<div align="center"><img src="img/application-structure-in-java-w1449-h810.png" width=1000 height=500><br><sub>Fig 7 - Application Structure in Java Application </sub></div>

<br>

#### <a name="chapter1part6.1"></a>Chapter 1 - Part 6.1: Anatomy of a Java Program

Every Java program has a specific structure that the Java compiler expects. Understanding this structure is essential for writing code that compiles and runs correctly. The basic structure consists of the following key elements:

- **Class Declaration**: This is the foundation of any Java program. Everything in Java resides inside a class.
- **main Method**: This is the entry point of your program. When you run a Java program, the Java Virtual Machine (JVM) starts executing code from the main method.
- **Statements**: These are the instructions that the program executes. They perform actions such as calculations, printing output, or making decisions.
- **Comments**: These are explanatory notes that you can add to your code to make it more readable. They are ignored by the compiler.

Let's examine each of these elements in detail.

**Class Declaration**

In Java, everything is an object, and every piece of code must reside inside a class. A class is a blueprint for creating objects. The basic syntax for declaring a class is:

```java
public class ClassName {
    // Class body (fields and methods)
}
```

- ```**public**```: This is an access modifier that determines the visibility of the class. public means that the class can be accessed from anywhere. We'll delve deeper into access modifiers in a later module.
- ```**class**```: This keyword is used to declare a class.
- ```**ClassName**```: This is the name of the class. Class names should start with an uppercase letter and follow the camel case naming convention (e.g., MyFirstClass, StudentDetails).
- ```**{}**```: The curly braces enclose the body of the class, which contains fields (variables) and methods (functions).

**Example**

```java
public class MyFirstProgram {
    // Class body will go here
}
```

In this example, we've declared a class named MyFirstProgram. Currently, the class body is empty, but we'll add more to it in the following sections.

**The main Method**

The main method is the entry point of any Java program. It's where the execution begins. Every standalone Java program must have a main method. The syntax for the main method is:

```java
public static void main(String[] args) {
    // Statements to be executed
}
```

Let's break down each part of this declaration:

- ```**public**```: As with the class declaration, public means that the main method can be accessed from anywhere.
- ```**static**```: This keyword means that the main method belongs to the class itself, rather than to an instance of the class. This allows the JVM to call the main method without creating an object of the class. We'll discuss static in more detail in Module 6.
- ```**void**```: This indicates that the main method does not return any value.
- ```**main**```: This is the name of the method. It's a special name that the JVM recognizes as the entry point of the program.
- ```**String[] args**```: This is the parameter list of the main method. It's an array of strings that can be used to pass command-line arguments to the program. We'll cover arrays in Module 4. For now, you can think of it as a way to provide input to your program when you run it from the command line.

**Example:**

```java
public class MyFirstProgram {
    public static void main(String[] args) {
        // Statements to be executed
    }
}
```

In this example, we've added the main method to our MyFirstProgram class. Now, we can add statements inside the main method to make our program do something.

**Statements**

Statements are the instructions that the program executes. They can be simple assignments, calculations, method calls, or control flow statements (which we'll cover in Module 3). Every statement in Java must end with a semicolon (;).

**Example:**

```java
public class MyFirstProgram {
    public static void main(String[] args) {
        System.out.println("Hello, World!"); // This is a statement
    }
}
```

In this example, we've added a statement that prints the text "Hello, World!" to the console.

- ```**System.out.println()**```: This is a method call that prints a line of text to the console. System.out is an object that represents the standard output stream (usually the console), and println() is a method of that object. We'll discuss methods in detail in Module 6.
- ```**"Hello, World!"**```: This is a string literal, which is a sequence of characters enclosed in double quotes.

**Comments**

Comments are explanatory notes that you can add to your code to make it more readable. They are ignored by the compiler. Java supports two types of comments:

- **Single-line comments**: These start with // and continue until the end of the line.
- **Multi-line comments**: These start with /* and end with */. They can span multiple lines.

**Example**:

```java
public class MyFirstProgram {
    public static void main(String[] args) {
        // This is a single-line comment
        /*
         * This is a multi-line comment.
         * It can span multiple lines.
         */
        System.out.println("Hello, World!"); // This statement prints "Hello, World!" to the console
    }
}
```

Comments are extremely useful for explaining what your code does, especially when it's complex. They can also be used to temporarily disable code by "commenting it out."

#### <a name="chapter1part6.2"></a>Chapter 1 - Part 6.2: Putting It All Together: A Complete Java Program

Let's combine all the elements we've discussed to create a complete Java program that calculates the sum of two numbers and prints the result to the console.

```java
public class SumCalculator { // Class declaration
    public static void main(String[] args) { // Main method
        int num1 = 10; // Declare and initialize the first number
        int num2 = 20; // Declare and initialize the second number
        int sum = num1 + num2; // Calculate the sum
        System.out.println("The sum of " + num1 + " and " + num2 + " is: " + sum); // Print the result
    }
}
```

In this program:

- We declare a class named SumCalculator.
- We define the main method, which is the entry point of the program.
- Inside the main method, we declare two integer variables, num1 and num2, and initialize them with the values 10 and 20, respectively. We'll learn more about variables and data types in Module 2.
- We calculate the sum of num1 and num2 and store the result in a variable named sum.
- We print the result to the console using System.out.println(). The + operator is used to concatenate strings and variables.

#### <a name="chapter1part6.3"></a>Chapter 1 - Part 6.3: Common Errors and How to Avoid Them

When you're starting out with Java, it's common to make mistakes. Here are some common errors related to program structure and how to avoid them:

- **Missing semicolon**: Every statement in Java must end with a semicolon. Forgetting the semicolon is a very common error.
  - **Example**: int x = 10 (missing semicolon)
  - **Solution**: int x = 10;
 
- **Incorrect class name**: The class name must match the name of the file (with the .java extension). For example, if your class is named MyClass, the file must be named MyClass.java.
  - **Example**: Class name is MyClass, but the file is named Myclass.java.
  - **Solution**: Ensure the class name and file name match exactly, including capitalization.
 
- **Missing main method**: If your program doesn't have a main method with the correct signature (public static void main(String[] args)), the JVM won't be able to find the entry point of your program.

  - **Example**: public void main(String[] args) (missing static)
  - **Solution**: Double-check the signature of the main method to make sure it's exactly public static void main(String[] args).
 
- **Mismatched curly braces**: Every opening curly brace ({) must have a corresponding closing curly brace (}). Mismatched curly braces can lead to syntax errors that are difficult to debug.

**Example:**

```java
public class MyClass {
    public static void main(String[] args) {
        System.out.println("Hello");
    // Missing closing curly brace for the main method
} // Closing curly brace for the class
```

- **Solution**: Use an IDE like IntelliJ IDEA or Eclipse, which can automatically match curly braces and highlight errors.

## <a name="chapter2"></a>Chapter 2: Java Fundamentals: Data Types, Variables, and Operators

#### <a name="chapter2part1"></a>Chapter 2 - Part 1: Understanding Primitive Data Types: int, double, boolean, char

Primitive data types are the fundamental building blocks for representing data in Java. Understanding them is crucial because they dictate the kind of values a variable can hold and the operations that can be performed on it. This lesson will provide a comprehensive overview of four essential primitive data types: int, double, boolean, and char. We'll explore their characteristics, how to declare and use them, and their significance in Java programming.

#### <a name="chapter2part1.1"></a>Chapter 2 - Part 1.1: Data Types in Java

In Java, we have the 8 primitive data types. Other types are Non-primitive like the diagram below:

<br>

<div align="center"><img src="img/data-types-w8000-h4500.png" width=600 height=350><br><sub>Fig 13 -Java Data Types - (<a href='https://getkt.com/blog/reintroduction-to-java-data-types/'>Work by neotam</a>) </sub></div>

<br>

<div align="center"><img src="img/data-types2-w1920-h1080.jpg" width=600 height=300><br><sub>Fig 14 -Java Data Primitive Types - (<a href='https://getkt.com/blog/reintroduction-to-java-data-types/'>Work by neotam</a>) </sub></div>

<br>

The size of a data (bits) is the number of the values this variable can store: The byte type can store 8 bits. Each bit store 1 or 0.

So: 2x2x2x2x2x2x2x2x2 = 2^8 = 256 possible values (-128 to 127)


To see the range of max and min of a type of variable do:

```java
int myMinIntValue = Integer.MIN_VALUE;
int myMaxIntValue = Integer.MAX_VALUE;
System.out.println("Integer Minimum Value = " + myMinIntValue);
System.out.println("Integer Maximum Value = " + myMaxIntValue);

int myMaxIntTest = 2_147_483_647; // another form to express

byte myMinByteValue = Byte.MIN_VALUE;
byte myMaxByteValue = Byte.MAX_VALUE;
System.out.println("Byte Minimum Value = " + myMinByteValue);
System.out.println("Byte Maximum Value = " + myMaxByteValue);

short myMinShortValue = Short.MIN_VALUE;
short myMaxShortValue = Short.MAX_VALUE;
System.out.println("Short Minimum Value = " + myMinShortValue);
System.out.println("Short Maximum Value = " + myMaxShortValue);
        
long myLongValue = 100; // Wrong -> Use L
long myMinLongValue = Long.MIN_VALUE;
long myMaxLongValue = Long.MAX_VALUE;
System.out.println("Long Minimum Value = " + myMinLongValue);
System.out.println("Long Maximum Value = " + myMaxLongValue);
long bigLongLiteralValue = 2_147_483_647_234L;
System.out.println(bigLongLiteralValue);

short bigShortLiteralValue = 32767;

/*

Output

Integer Minimum Value = -2147483648
Integer Maximum Value = 2147483647
Byte Minimum Value = -128
Byte Maximum Value = 127
Short Minimum Value = -32768
Short Maximum Value = 32767
Long Minimum Value = -9223372036854775808
Long Maximum Value = 9223372036854775807
2147483647234
*/
```

If you try to add a value in a Maximun or Minimun Value, will occur a overflow in a Maximun and underflow in Minimun. The Computer will convert the maximun to minimun and vice-versa

```java
int myMinIntValue = Integer.MIN_VALUE;
int myMaxIntValue = Integer.MAX_VALUE;
System.out.println("Integer Minimum Value = " + myMinIntValue);
System.out.println("Integer Maximum Value = " + myMaxIntValue);
System.out.println("Busted MAX value = " + (myMaxIntValue + 1)); // overflow
System.out.println("Busted MIN value = " + (myMinIntValue - 1)); // underflow

/*
Output

Integer Minimum Value = -2147483648
Integer Maximum Value = 2147483647
Busted MAX value = -2147483648
Busted MIN value = 2147483647
*/
```


Wrapper types(Reference Types) provided by java for corresponding Primitive Types

| Primitive Types  | Wrapper types(Reference Types) |
| :--------------: | :-----------------------------:|
| boolean          | Boolean                        | 
| byte             | Byte                           |
| character        | Character                      |
| short            | Short                          |
| int              | Int                            | 
| long             | Long                           |
| float            | Float                          |
| double           | double                         |

**Variables Name -> Camel Case** Ex: myVariable

**Class Name -> Pascal Case** Ex: MyClass


#### <a name="chapter2part1.2"></a>Chapter 2 - Part 1.2: Integer Data Type: int

The int data type is used to store whole numbers (integers) without any fractional part. It's one of the most commonly used data types in Java.

**Characteristics of int**

- **Size**: int occupies 4 bytes (32 bits) of memory.
- **Range**: The range of values that an int can hold is from -2,147,483,648 (-231) to 2,147,483,647 (231 - 1).
- **Usage**: Suitable for representing counts, indices, quantities, and other whole number values.

**Declaring and Initializing int Variables**

To declare an int variable, you use the int keyword followed by the variable name. To initialize it, you assign a value to it using the assignment operator =.

```java
int age; // Declaration
age = 30; // Initialization

int count = 100; // Declaration and initialization in one line
```

**Examples of int Usage**

```java
int numberOfStudents = 25;
int temperature = 72;
int score = 1000;
int negativeNumber = -5;
```

**int Operations**

You can perform various arithmetic operations on int variables, such as addition, subtraction, multiplication, and division.

```java
int x = 10;
int y = 5;

int sum = x + y; // sum is 15
int difference = x - y; // difference is 5
int product = x * y; // product is 50
int quotient = x / y; // quotient is 2
int remainder = x % y; // remainder is 0
```

**When to Use int**

Use int when you need to represent whole numbers within the specified range and when you don't need to store fractional parts. For example, representing the number of items in a shopping cart, the age of a person, or the score in a game.

#### <a name="chapter2part1.3"></a>Chapter 2 - Part 1.3: Floating-Point Data Type: double

The double data type is used to store floating-point numbers, which are numbers with a fractional part (decimal numbers).

**Characteristics of double**

**Size**: double occupies 8 bytes (64 bits) of memory.
**Range**: double can represent a wide range of values, both positive and negative, including very large and very small numbers. It uses the IEEE 754 standard for representing floating-point numbers.
**Precision**: double provides approximately 15-17 decimal digits of precision.
**Usage**: Suitable for representing measurements, scientific calculations, financial values, and other values that require fractional precision.

**Declaring and Initializing double Variables**

To declare a double variable, you use the double keyword followed by the variable name. To initialize it, you assign a floating-point value to it.

```java
double price; // Declaration
price = 19.99; // Initialization

double temperature = 98.6; // Declaration and initialization in one line
```

**Examples of double Usage**

```java
double pi = 3.14159;
double gravity = 9.81;
double bankBalance = 1234.56;
double percentage = 0.75;
```

**double Operations**

You can perform arithmetic operations on double variables, similar to int.

```java
double x = 10.5;
double y = 3.2;

double sum = x + y; // sum is 13.7
double difference = x - y; // difference is 7.3
double product = x * y; // product is 33.6
double quotient = x / y; // quotient is 3.28125
```

**When to Use double**

Use double when you need to represent numbers with fractional parts or when you require a wider range and higher precision than int can provide. For example, representing the price of an item, the temperature of a room, or the result of a scientific calculation.

#### <a name="chapter2part1.4"></a>Chapter 2 - Part 1.4: Boolean Data Type: boolean

The boolean data type represents a logical value that can be either true or false. It's used to represent conditions and make decisions in your code.

**Characteristics of boolean**

- **Size**: The size of a boolean is not precisely defined in the Java specification, but it's typically considered to be 1 bit, although it might occupy more memory depending on the JVM implementation.
- **Values**: boolean can only hold two values: true or false.
- **Usage**: Used to represent conditions, flags, and logical states.

**Declaring and Initializing boolean Variables**

To declare a boolean variable, you use the boolean keyword followed by the variable name. To initialize it, you assign either true or false to it.

```java
boolean isRaining; // Declaration
isRaining = true; // Initialization

boolean isLoggedIn = false; // Declaration and initialization in one line
```

**Examples of boolean Usage**

```java
boolean hasPermission = true;
boolean isFinished = false;
boolean isValidInput = true;
```

**boolean Operations**

boolean variables are primarily used with logical operators to create complex conditions. These operators will be covered in detail in a later lesson, but here's a brief overview:

- ```&&``` (AND): Returns true if both operands are true.
- ```||``` (OR): Returns true if at least one operand is true.
- ```!``` (NOT): Inverts the value of the operand.

```java
boolean x = true;
boolean y = false;

boolean andResult = x && y; // andResult is false
boolean orResult = x || y; // orResult is true
boolean notX = !x; // notX is false
```

**When to Use boolean**

Use boolean when you need to represent a binary state or a condition that can be either true or false. For example, representing whether a user is logged in, whether a file exists, or whether a certain condition is met.

#### <a name="chapter2part1.5"></a>Chapter 2 - Part 1.5: Character Data Type: char

The char data type is used to store a single character. It represents characters using the Unicode character set.

**Characteristics of char**

- **Size**: char occupies 2 bytes (16 bits) of memory.
- **Range**: char can represent characters from the Unicode character set, which includes letters, digits, symbols, and special characters from various languages.
- **Usage**: Used to represent individual characters, such as letters, digits, or symbols.

**Declaring and Initializing char Variables**

To declare a char variable, you use the char keyword followed by the variable name. To initialize it, you assign a character literal to it, enclosed in single quotes.

```java
char initial; // Declaration
initial = 'J'; // Initialization

char grade = 'A'; // Declaration and initialization in one line
```

**Examples of char Usage**

```java
char letter = 'a';
char digit = '5';
char symbol = '$';
char unicodeChar = '\u0041'; // Unicode for 'A'
```

**char Operations**

You can perform some arithmetic operations on char variables, as they are represented by numerical Unicode values. However, it's more common to use them for character manipulation and comparison.

```java
char letterA = 'A';
char letterB = 'B';

int difference = letterB - letterA; // difference is 1 (Unicode value of 'B' - Unicode value of 'A')
```

**Escape Sequences**

char also supports escape sequences, which are special character combinations that represent characters that are difficult or impossible to type directly.

- ```\n```: Newline
- ```\t```: Tab
- ```\'```: Single quote
- ```\"```: Double quote
- ```\\```: Backslash

```java
char newline = '\n';
char tab = '\t';
char singleQuote = '\'';
char doubleQuote = '\"';
char backslash = '\\';

System.out.println("This is a line" + newline + "This is a new line");
System.out.println("Column 1" + tab + "Column 2");
System.out.println("He said, " + singleQuote + "Hello" + singleQuote);
```

**When to Use char**

Use char when you need to represent a single character. For example, representing a letter in a name, a digit in a code, or a symbol in a password.

#### <a name="chapter2part2"></a>Chapter 2 - Part 2: Declaring and Initializing Variables

Declaring and initializing variables are fundamental concepts in Java programming. They are the building blocks for storing and manipulating data within your programs. Understanding how to properly declare and initialize variables is crucial for writing correct and efficient code. This lesson will cover the different ways to declare and initialize variables, best practices, and common pitfalls to avoid.

#### <a name="chapter2part2.1"></a>Chapter 2 - Part 2.1: Understanding Variable Declaration

In Java, before you can use a variable, you must declare it. Declaring a variable means specifying its data type and giving it a name. The syntax for declaring a variable is:

```java
dataType variableName;
```

- **dataType**: This specifies the type of data the variable will hold (e.g., int, double, boolean, char, String). We covered primitive data types in the previous lesson.
- **variableName**: This is the name you choose for the variable. Variable names must follow certain rules:
  - They must start with a letter, underscore (_), or dollar sign ($).
  - They can contain letters, digits, underscores, and dollar signs.
  - They cannot be a Java keyword (e.g., class, public, static, void, int).
  - They are case-sensitive (e.g., myVariable and myvariable are different variables).
  - By convention, variable names should start with a lowercase letter and use camelCase for multi-word names (e.g., numberOfStudents).
 
Here are some examples of variable declarations:

```java
int age;          // Declares an integer variable named 'age'
double salary;     // Declares a double variable named 'salary'
boolean isEmployed; // Declares a boolean variable named 'isEmployed'
char initial;       // Declares a character variable named 'initial'
String name;       // Declares a String variable named 'name'
```

**Multiple Declarations**

You can declare multiple variables of the same data type in a single line, separated by commas:

```java
int x, y, z; // Declares three integer variables: x, y, and z
```

However, it's generally recommended to declare each variable on a separate line for better readability, especially when initializing them.

#### <a name="chapter2part2.2"></a>Chapter 2 - Part 2.2: Understanding Variable Initialization

Initialization is the process of assigning an initial value to a variable. In Java, you can initialize a variable at the time of declaration or later in your code.

**Initialization at Declaration**

The most common and recommended way to initialize a variable is at the time of declaration:

```java
dataType variableName = value;
```

Here are some examples:

```java
int age = 25;             // Declares an integer variable 'age' and initializes it to 25
double salary = 50000.0;    // Declares a double variable 'salary' and initializes it to 50000.0
boolean isEmployed = true;  // Declares a boolean variable 'isEmployed' and initializes it to true
char initial = 'J';          // Declares a character variable 'initial' and initializes it to 'J'
String name = "John Doe";   // Declares a String variable 'name' and initializes it to "John Doe"
```

**Initialization After Declaration**

You can also declare a variable first and then initialize it later:

```java
int age;     // Declares an integer variable 'age'
age = 25;    // Initializes the variable 'age' to 25
```

However, it's generally better to initialize variables at the time of declaration whenever possible. This makes your code more readable and reduces the risk of using a variable before it has been assigned a value.

**Default Values**

If you declare a variable without initializing it, Java assigns a default value to it. These default values depend on the data type:

- ```int```: 0
- ```double```: 0.0
- ```boolean```: false
- ```char```: \u0000 (null character)
- ```String```: null

However, it's important to note that local variables (variables declared inside a method) must be initialized before they are used. The compiler will generate an error if you try to use an uninitialized local variable. Instance variables (variables declared within a class but outside any method) are automatically initialized with default values. We will cover classes and methods in later modules.

```java
public class Example {
    int instanceVariable; // Automatically initialized to 0

    public void myMethod() {
        int localVariable; // Not automatically initialized
        // System.out.println(localVariable); // Error: variable 'localVariable' might not have been initialized
    }
}
```

#### <a name="chapter2part2.3"></a>Chapter 2 - Part 2.3: Best Practices for Declaring and Initializing Variables

Initialize variables at the time of declaration: This makes your code more readable and prevents errors caused by using uninitialized variables.

- **Choose meaningful variable names**: Use names that clearly indicate the purpose of the variable.

- **Use appropriate data types**: Select the data type that best represents the type of data the variable will hold.

- **Follow naming conventions**: Use camelCase for variable names (e.g., numberOfStudents, firstName).

- **Avoid using uninitialized local variables**: Always initialize local variables before using them.

- **Consider using final for constants**: If a variable's value should not change after initialization, declare it as final. This makes your code more robust and easier to understand.

```java
final double PI = 3.14159;
// PI = 3.14; // Error: cannot assign a value to final variable PI
```

#### <a name="chapter2part2.4"></a>Chapter 2 - Part 2.4: Casting

It is the explicit conversion from one type to another.

It is necessary when the compiler is not able to “guess” that the result of an expression must be of another type.

```java
int x3, y3;
		
double resultado;
		
x3 = 5;
y3 = 2;
resultado = x3 / y3; // result a int -> 2.0 and not 2.5
		
System.out.println(resultado);
		
resultado = (double) x3 / y3; // casting
		
System.out.println(resultado);
		
double x4;
int y4;
		
x4 = 5.0;
y4 = (int) x4; // -> You can convert double to int - make a casting
		
System.out.println(y4);

int myIntValue = 100;
byte myByteValue = 100;
short myShortValue = 100;
		
int myIntTotal = (myIntValue)/2;
byte myByteTotal = (byte) ((myByteValue)/2);
short myShortTotal = (short) ((myShortValue)/2);



/*
Console

----output---
2.0
2.5
5

*/
```

#### <a name="chapter2part2.5"></a>Chapter 2 - Part 2.5: Variable Scope (Java Scope)

In Java, variables are only accessible inside the region they are created. This is called **scope**.

Scope of a variable: is the region of the program where the variable is valid, that is, where it can be referenced.

Variables declared directly inside a method are available anywhere in the method following the line of code in which they were declared:

**Method Scope**

Variables declared directly inside a method are available anywhere in the method following the line of code in which they were declared:

```java

public class Main {
  public static void main(String[] args) {

    // Code here CANNOT use x

    int x = 100;

    // Code here can use x
    System.out.println(x);
  }
}

```

**Block Scope**

A block of code refers to all of the code between curly braces ```{}```.

Variables declared inside blocks of code are only accessible by the code between the curly braces, which follows the line in which the variable was declared:

```java

public class Main {
  public static void main(String[] args) {

    // Code here CANNOT use x

    { // This is a block

      // Code here CANNOT use x

      int x = 100;

      // Code here CAN use x
      System.out.println(x);

   } // The block ends here

  // Code here CANNOT use x

  }
}

```

OBS: A block of code may exist on its own or it can belong to an ```if```, ```while``` or ```for``` statement. In the case of ```for``` statements, variables declared in the statement itself are also available inside the block's scope.

```java

double price = sc.nextDouble();

if (price > 100.0) {

double discount = price * 0.1;

// Code here CAN use variable discount

}

// Code here CANNOT use variable discount

```

#### <a name="chapter2part2.6"></a>Chapter 2 - Part 2.6: Examples and Demonstrations

Let's look at some more detailed examples of declaring and initializing variables in Java.

**Example 1: Calculating the Area of a Rectangle**

```java
public class RectangleArea {
    public static void main(String[] args) {
        // Declare and initialize the length and width of the rectangle
        double length = 10.5;
        double width = 5.0;

        // Calculate the area
        double area = length * width;

        // Print the area to the console
        System.out.println("The area of the rectangle is: " + area);
    }
}
```

In this example, we declare and initialize the length and width variables with double values. We then calculate the area and store it in the area variable, also a double. Finally, we print the result to the console.

**Example 2: Determining if a Number is Even**

```java
public class EvenNumber {
    public static void main(String[] args) {
        // Declare and initialize an integer variable
        int number = 20;

        // Check if the number is even
        boolean isEven = (number % 2 == 0);

        // Print whether the number is even or not
        System.out.println("Is the number even? " + isEven);
    }
}
```

Here, we declare an int variable number and initialize it. We then use the modulo operator (%) to check if the number is even. The result is stored in a boolean variable isEven, which is then printed to the console.

**Example 3: Storing a User's Name**

```java
import java.util.Scanner;

public class UserGreeting {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter their name
        System.out.print("Enter your name: ");

        // Declare and initialize a String variable to store the user's name
        String name = scanner.nextLine();

        // Print a greeting to the user
        System.out.println("Hello, " + name + "!");

        // Close the scanner
        scanner.close();
    }
}
```

In this example, we use the Scanner class (which we will cover in more detail in a later module) to read input from the console. We declare a String variable name and initialize it with the user's input. Then, we print a personalized greeting to the user.

#### <a name="chapter2part3"></a>Chapter 2 - Part 3: Working with Strings

Strings are fundamental to programming, representing text and enabling interaction with users and data. In Java, strings are objects, not primitive data types, which means they have associated methods that allow for powerful manipulation and analysis. Understanding how to work with strings is crucial for tasks ranging from simple text output to complex data processing. This lesson will cover the essentials of working with strings in Java, including their creation, manipulation, and comparison.

#### <a name="chapter2part3.1"></a>Chapter 2 - Part 3.1: Creating Strings

In Java, strings are objects of the String class. There are several ways to create string objects.

**String Literals**

The most common way to create a string is by using a string literal, which is a sequence of characters enclosed in double quotes.

```java
String message = "Hello, world!"; // Creating a string literal
System.out.println(message); // Output: Hello, world!
```

When you use a string literal, Java checks if a string with the same content already exists in the string pool. If it does, the new variable will refer to the existing string in the pool. If not, a new string object is created in the string pool. The string pool is a special memory area in the Java heap that stores string literals to optimize memory usage.

**Using the new Keyword**

You can also create a string using the new keyword, which explicitly creates a new String object in the heap, regardless of whether an identical string already exists in the string pool.

```java
String anotherMessage = new String("Hello, world!"); // Creating a string object using 'new'
System.out.println(anotherMessage); // Output: Hello, world!
```

While both methods achieve the same result, using string literals is generally preferred for efficiency because it leverages the string pool. Using new creates a new object even if an identical string exists, which can be less memory-efficient.

**Creating Strings from Character Arrays**

You can create a string from an array of characters using the String constructor.

```java
char[] charArray = {'J', 'a', 'v', 'a'};
String fromCharArray = new String(charArray);
System.out.println(fromCharArray); // Output: Java
```

This method is useful when you need to convert character data into a string format.

#### <a name="chapter2part3.2"></a>Chapter 2 - Part 3.2: String Immutability

A crucial concept to understand about strings in Java is that they are immutable. This means that once a String object is created, its value cannot be changed. Any operation that appears to modify a string actually creates a new String object.

```java
String text = "Hello";
text = text + " world!"; // A new String object is created
System.out.println(text); // Output: Hello world!
```

In the example above, the original "Hello" string is not modified. Instead, a new string "Hello world!" is created, and the text variable is updated to refer to this new string. The old "Hello" string might eventually be garbage collected if it's no longer referenced.

**Implications of Immutability**

Immutability has several important implications:

- **Thread Safety**: Immutable objects are inherently thread-safe, as their state cannot be modified after creation. This makes them safe to use in concurrent environments without the need for synchronization.
- **Caching**: Immutable strings can be safely cached and reused, as their value will never change. This is the basis for the string pool optimization.
- **Predictability**: Immutability makes code more predictable and easier to reason about, as you can be confident that a string's value will not change unexpectedly.

#### <a name="chapter2part3.3"></a>Chapter 2 - Part 3.3: String Manipulation

While strings are immutable, Java provides a rich set of methods for manipulating strings and creating new strings based on existing ones.

**Concatenation**

String concatenation is the process of combining two or more strings into a single string. In Java, you can use the + operator or the concat() method to concatenate strings.

**Using the + Operator**

The + operator is the most common and convenient way to concatenate strings.

```java
String firstName = "John";
String lastName = "Doe";
String fullName = firstName + " " + lastName;
System.out.println(fullName); // Output: John Doe
```

When you use the + operator with a string and another data type (e.g., an integer), Java automatically converts the other data type to a string and concatenates them.

```java
String age = "Age: ";
int personAge = 30;
String ageString = age + personAge;
System.out.println(ageString); // Output: Age: 30
```

**Using the concat() Method**

The concat() method is another way to concatenate strings. It takes a string as an argument and returns a new string that is the concatenation of the original string and the argument.

```java
String greeting = "Hello";
String name = " Alice";
String fullGreeting = greeting.concat(name);
System.out.println(fullGreeting); // Output: Hello Alice
```

While both methods achieve the same result, the + operator is generally preferred for its simplicity and readability.

**Substrings**

A substring is a contiguous sequence of characters within a string. Java provides the substring() method to extract substrings from a string.

```java
String message = "This is a test message";
String sub = message.substring(5, 12); // Extracts characters from index 5 (inclusive) to 12 (exclusive)
System.out.println(sub); // Output: is a te
```

The substring() method takes two arguments: the starting index (inclusive) and the ending index (exclusive). You can also use a single argument, which specifies the starting index, and the substring will extend to the end of the string.

```java
String message = "This is a test message";
String sub2 = message.substring(8); // Extracts characters from index 8 to the end of the string
System.out.println(sub2); // Output: a test message
```

**Length**

The length() method returns the number of characters in a string.

```java
String text = "Java";
int len = text.length();
System.out.println(len); // Output: 4
```

The length of a string includes all characters, including spaces and special characters.

**Adding Numbers and Strings**


WARNING!

Java uses the ```+``` operator for both addition and concatenation.

Numbers are added. Strings are concatenated.

If you add two numbers, the result will be a number:

```java

int x = 10;
int y = 20;
int z = x + y;  // z will be 30 (an integer/number)

```

If you add two strings, the result will be a string concatenation:

```java

String x = "10";
String y = "20";
String z = x + y;  // z will be 1020 (a String)

```

If you add a number and a string, the result will be a string concatenation:

```java

String x = "10";
int y = 20;
String z = x + y;  // z will be 1020 (a String)

```

**Strings - Special Characters**

Because strings must be written within quotes, Java will misunderstand this string, and generate an error:

```java

Because strings must be written within quotes, Java will misunderstand this string, and generate an error:

```

The solution to avoid this problem, is to use the **backslash escape character**.

The backslash (```\```) escape character turns special characters into string characters:

| Escape character | Result   |Description   |
| :---------------:| :-------:|:-----------: |
| \'               | '        | Single quote |
| \"               | "        | Double quote |
| \\               | \        | Backslash    |


The sequence ```\"```  inserts a double quote in a string:

```java

String txt = "We are the so-called \"Vikings\" from the north.";

```

The sequence ```\'```  inserts a single quote in a string:

```java

String txt = "It\'s alright.";

```

The sequence ```\\```  inserts a single backslash in a string:

```java

String txt = "The character \\ is called backslash.";

```

| Code | Result          |
| :---:| :--------------:|
| \n   | New Line        |
| \r   | Carriage Return | 
| \t   | Tab             |
| \b   | Backspace       |
| \f   | Form Feed       |

#### <a name="chapter2part3.4"></a>Chapter 2 - Part 3.4: String Comparison

Comparing strings is a common task in programming. Java provides several ways to compare strings, each with its own nuances.

**```equals()``` vs. ```==```**

It's crucial to understand the difference between the equals() method and the == operator when comparing strings.

- The equals() method compares the content of two strings. It returns true if the strings have the same sequence of characters, and false otherwise.

- The == operator compares the references of two strings. It returns true if the two variables refer to the same String object in memory, and false otherwise.

```java
String str1 = "Hello";
String str2 = "Hello";
String str3 = new String("Hello");

System.out.println(str1.equals(str2)); // Output: true (same content)
System.out.println(str1 == str2);    // Output: true (same object from string pool)
System.out.println(str1.equals(str3)); // Output: true (same content)
System.out.println(str1 == str3);    // Output: false (different objects)
```

In the example above, str1 and str2 refer to the same string in the string pool, so == returns true. However, str3 is a new String object created using new, so == returns false even though the content is the same.

**Always use the equals() method to compare the content of strings**. Using == can lead to unexpected results, especially when dealing with strings created using new or strings obtained from external sources.

**```equalsIgnoreCase()```**

The equalsIgnoreCase() method compares the content of two strings, ignoring case differences.

```java
String str1 = "Hello";
String str2 = "hello";

System.out.println(str1.equals(str2));          // Output: false (case-sensitive comparison)
System.out.println(str1.equalsIgnoreCase(str2)); // Output: true (case-insensitive comparison)
```

This method is useful when you want to compare strings without regard to case.

**```compareTo()```**

The compareTo() method compares two strings lexicographically (based on the Unicode values of their characters). It returns:

- A negative value if the first string is lexicographically less than the second string.
- A positive value if the first string is lexicographically greater than the second string.
- Zero if the strings are equal.

```java
String str1 = "apple";
String str2 = "banana";
String str3 = "apple";

System.out.println(str1.compareTo(str2)); // Output: Negative value (apple comes before banana)
System.out.println(str2.compareTo(str1)); // Output: Positive value (banana comes after apple)
System.out.println(str1.compareTo(str3)); // Output: 0 (strings are equal)
```

The compareTo() method is useful for sorting strings or determining their relative order.

#### <a name="chapter2part3.5"></a>Chapter 2 - Part 3.5: String Methods

Java's String class provides a wide range of methods for manipulating and analyzing strings. Here are some commonly used methods:

**```toUpperCase()``` and ```toLowerCase()```**

These methods convert a string to uppercase or lowercase, respectively.

```java
String text = "Java is Fun";
String upper = text.toUpperCase();
String lower = text.toLowerCase();

System.out.println(upper); // Output: JAVA IS FUN
System.out.println(lower); // Output: java is fun
```

These methods are useful for normalizing strings or performing case-insensitive comparisons.

**```trim()```**

The trim() method removes leading and trailing whitespace from a string.

```java
String text = "   Hello World   ";
String trimmed = text.trim();

System.out.println(text);    // Output:    Hello World
System.out.println(trimmed); // Output: Hello World
```

Whitespace includes spaces, tabs, and newline characters. The trim() method is useful for cleaning up user input or data from external sources.

**```replace()```**

The replace() method replaces all occurrences of a specified character or substring with another character or substring.

```java
String text = "This is a test";
String replaced = text.replace("test", "sample");
System.out.println(replaced); // Output: This is a sample

String replacedChar = text.replace('i', 'a');
System.out.println(replacedChar); // Output: Thas as a tast
```

**```indexOf()``` and ```lastIndexOf()```**

The indexOf() method returns the index of the first occurrence of a specified character or substring within a string. The lastIndexOf() method returns the index of the last occurrence. If the character or substring is not found, both methods return -1.

```java
String text = "This is a test";
int firstIndex = text.indexOf("is");
int lastIndex = text.lastIndexOf("is");

System.out.println(firstIndex); // Output: 2
System.out.println(lastIndex);  // Output: 5

int notFound = text.indexOf("xyz");
System.out.println(notFound);   // Output: -1
```

**```startsWith()``` and ```endsWith()```**

The startsWith() method checks if a string starts with a specified prefix. The endsWith() method checks if a string ends with a specified suffix. Both methods return a boolean value.

```java
String text = "Hello World";
boolean startsWithHello = text.startsWith("Hello");
boolean endsWithWorld = text.endsWith("World");

System.out.println(startsWithHello); // Output: true
System.out.println(endsWithWorld);   // Output: true
```

#### <a name="chapter2part4"></a>Chapter 2 - Part 4: Arithmetic Operators: +, -, *, /, %

Arithmetic operators are fundamental building blocks in Java, allowing you to perform mathematical calculations within your programs. Understanding how these operators work is crucial for manipulating numerical data and creating dynamic applications. This lesson will cover the five basic arithmetic operators in Java: addition, subtraction, multiplication, division, and modulus. We'll explore their syntax, usage, and potential pitfalls, equipping you with the knowledge to confidently perform arithmetic operations in your Java code.

#### <a name="chapter2part4.1"></a>Chapter 2 - Part 4.1: Basic Arithmetic Operators

Java provides five primary arithmetic operators:

- **Addition (+)**: Adds two operands.
- **Subtraction (-)**: Subtracts the second operand from the first.
- **Multiplication (*)**: Multiplies two operands.
- **Division (/)**: Divides the first operand by the second.
- **Modulus (%)**: Returns the remainder of a division operation.

**Addition (+)**

The addition operator (+) is used to sum two numerical values.

```java
int a = 10;
int b = 5;
int sum = a + b; // sum will be 15
System.out.println("Sum: " + sum);
```

In this example, the + operator adds the values of a and b, storing the result in the sum variable. The System.out.println() statement then prints the value of sum to the console.

String Concatenation: The + operator also performs string concatenation. If one of the operands is a string, Java treats the + operator as a string concatenation operator, converting the other operand to a string and joining them together.

```java
String firstName = "John";
String lastName = "Doe";
String fullName = firstName + " " + lastName; // fullName will be "John Doe"
System.out.println("Full Name: " + fullName);
```

Here, the + operator concatenates the firstName, a space (" "), and the lastName strings to create the fullName string.

**Subtraction (-)**

The subtraction operator (-) is used to find the difference between two numerical values.

```java
int a = 10;
int b = 5;
int difference = a - b; // difference will be 5
System.out.println("Difference: " + difference);
```

In this example, the - operator subtracts the value of b from a, storing the result in the difference variable.

Unary Minus: The - operator can also be used as a unary operator to negate a single operand.

```java
int a = 10;
int negativeA = -a; // negativeA will be -10
System.out.println("Negative A: " + negativeA);
```

**Multiplication (*)**

The multiplication operator (*) is used to find the product of two numerical values.

```java
int a = 10;
int b = 5;
int product = a * b; // product will be 50
System.out.println("Product: " + product);
```

In this example, the * operator multiplies the values of a and b, storing the result in the product variable.

**Division (/)**

The division operator (/) is used to divide the first operand by the second.

```java
int a = 10;
int b = 5;
int quotient = a / b; // quotient will be 2
System.out.println("Quotient: " + quotient);
```

In this example, the / operator divides the value of a by b, storing the result in the quotient variable.

Integer Division: When both operands are integers, the / operator performs integer division, which truncates the decimal part of the result.

```java
int a = 11;
int b = 5;
int quotient = a / b; // quotient will be 2 (not 2.2)
System.out.println("Quotient: " + quotient);
```

To obtain a floating-point result, at least one of the operands must be a floating-point number (e.g., double or float).

```java
double a = 11.0;
int b = 5;
double quotient = a / b; // quotient will be 2.2
System.out.println("Quotient: " + quotient);
```

Division by Zero: Dividing by zero results in an ArithmeticException at runtime. It's crucial to avoid division by zero in your code.

```java
int a = 10;
int b = 0;
// int quotient = a / b; // This will throw an ArithmeticException
```

**Modulus (%)**

The modulus operator (%) returns the remainder of a division operation.

```java
int a = 10;
int b = 3;
int remainder = a % b; // remainder will be 1
System.out.println("Remainder: " + remainder);
```

In this example, the % operator divides a by b and returns the remainder, which is 1.

Use Cases: The modulus operator is useful for various tasks, such as:

- Determining if a number is even or odd: number % 2 == 0 indicates an even number.
- Wrapping around a range: index = (index + 1) % arrayLength ensures that the index stays within the bounds of the array.
- Extracting digits from a number: lastDigit = number % 10 extracts the last digit of the number.

#### <a name="chapter2part4.2"></a>Chapter 2 - Part 4.2: Operator Precedence

Arithmetic operators have a specific order of precedence, which determines the order in which they are evaluated in an expression. The precedence of arithmetic operators in Java is as follows (from highest to lowest):

- **1**: Multiplication (*), Division (/), Modulus (%)
- **2**: Addition (+), Subtraction (-)

Operators with higher precedence are evaluated before operators with lower precedence. When operators have the same precedence, they are evaluated from left to right.

```java
int result = 10 + 5 * 2; // Multiplication is performed before addition
System.out.println("Result: " + result); // Output: 20
```

In this example, the multiplication 5 * 2 is performed first, resulting in 10. Then, the addition 10 + 10 is performed, resulting in 20.

Using Parentheses: You can use parentheses () to override the default operator precedence and explicitly specify the order of evaluation.

```java
int result = (10 + 5) * 2; // Addition is performed before multiplication due to parentheses
System.out.println("Result: " + result); // Output: 30
```

In this example, the addition 10 + 5 is performed first because it is enclosed in parentheses, resulting in 15. Then, the multiplication 15 * 2 is performed, resulting in 30.

#### <a name="chapter2part4.3"></a>Chapter 2 - Part 4.3: Practical Examples and Demonstrations

Let's explore some practical examples of using arithmetic operators in Java.

**Calculating the Area of a Rectangle**

```java
double length = 10.5;
double width = 5.0;
double area = length * width; // Calculate the area
System.out.println("Area of the rectangle: " + area);
```

This example calculates the area of a rectangle by multiplying its length and width.

**Calculating the Average of Three Numbers**

```java
double num1 = 85.0;
double num2 = 90.0;
double num3 = 78.0;
double average = (num1 + num2 + num3) / 3; // Calculate the average
System.out.println("Average: " + average);
```

This example calculates the average of three numbers by summing them and dividing by 3.

**Converting Celsius to Fahrenheit**

```java
double celsius = 25.0;
double fahrenheit = (celsius * 9 / 5) + 32; // Convert Celsius to Fahrenheit
System.out.println("Fahrenheit: " + fahrenheit);
```

This example converts a temperature from Celsius to Fahrenheit using the standard conversion formula.

**Calculating the Remaining Seats**

Imagine a scenario where you are managing seats for an event. You have a total number of seats and a certain number of seats have been booked. You can use subtraction to calculate the remaining seats.

```java
int totalSeats = 200;
int bookedSeats = 120;
int remainingSeats = totalSeats - bookedSeats;
System.out.println("Remaining seats: " + remainingSeats);
```

#### <a name="chapter2part5"></a>Chapter 2 - Part 5: Assignment Operators: =, +=, -=, *=, /=

Assignment operators are fundamental to programming in Java. They provide a concise way to assign values to variables and perform arithmetic operations simultaneously. Understanding these operators is crucial for writing efficient and readable code. This lesson will cover the basic assignment operator (=) and the compound assignment operators (+=, -=, *=, /=), explaining their functionality and demonstrating their usage with examples.

#### <a name="chapter2part5.1"></a>Chapter 2 - Part 5.1: Understanding the Basic Assignment Operator (=)

The most basic assignment operator in Java is the equals sign (=). It assigns the value on the right-hand side of the operator to the variable on the left-hand side.

**Syntax**

```java
variable = expression;
```

**Explanation**

- ```variable```: This is the name of the variable that will store the value.
- ```=```: The assignment operator.
- ```expression```: This is any valid Java expression that evaluates to a value. The value must be compatible with the data type of the variable.

**Examples**

```java
int age = 25; // Assigns the integer value 25 to the variable 'age'
double price = 19.99; // Assigns the double value 19.99 to the variable 'price'
String name = "Alice"; // Assigns the String value "Alice" to the variable 'name'
boolean isValid = true; // Assigns the boolean value true to the variable 'isValid'
```

**Important Notes**

- The assignment operator assigns the value of the expression to the variable. If the expression involves other variables, their current values are used.
- Assignment is right-associative, meaning that in an expression like a = b = c;, the value of c is first assigned to b, and then the value of b is assigned to a. It's generally better to avoid chaining assignments like this for readability.
- The variable on the left-hand side must be declared before it can be used in an assignment.

#### <a name="chapter2part5.2"></a>Chapter 2 - Part 5.2: Compound Assignment Operators (+=, -=, *=, /=)

Compound assignment operators combine an arithmetic operation with assignment. They provide a shorthand way to update the value of a variable.

**The += Operator (Addition Assignment)**

The += operator adds the value of the right-hand operand to the value of the left-hand operand and assigns the result to the left-hand operand.

**Syntax**

```java
variable += expression; // Equivalent to: variable = variable + expression;
```

**Example**

```java
int x = 10;
x += 5; // Equivalent to x = x + 5;
System.out.println(x); // Output: 15
```

**The -= Operator (Subtraction Assignment)**

The -= operator subtracts the value of the right-hand operand from the value of the left-hand operand and assigns the result to the left-hand operand.

**Syntax**

```java
variable -= expression; // Equivalent to: variable = variable - expression;
```

**Example**

```java
int y = 20;
y -= 7; // Equivalent to y = y - 7;
System.out.println(y); // Output: 13
```

**The ```*=``` Operator (Multiplication Assignment)**

The *= operator multiplies the value of the left-hand operand by the value of the right-hand operand and assigns the result to the left-hand operand.

**Syntax**

```java
variable *= expression; // Equivalent to: variable = variable * expression;
```

**Example**

```java
int z = 5;
z *= 4; // Equivalent to z = z * 4;
System.out.println(z); // Output: 20
```

**The /= Operator (Division Assignment)**

The /= operator divides the value of the left-hand operand by the value of the right-hand operand and assigns the result to the left-hand operand.

**Syntax**

```java
variable /= expression; // Equivalent to: variable = variable / expression;
```

**Example**

```java
double a = 100.0;
a /= 2.5; // Equivalent to a = a / 2.5;
System.out.println(a); // Output: 40.0
```

**Implicit Casting with Compound Assignment Operators**

Compound assignment operators perform an implicit cast if necessary. This means that if the result of the operation is of a different type than the variable, Java will automatically convert the result to the variable's type. This can be useful, but it's important to be aware of potential loss of precision.

**Example**

```java
int num = 5;
num += 2.5; // Equivalent to num = (int)(num + 2.5);
System.out.println(num); // Output: 7 (2.5 is truncated to 2)
```

In this example, num + 2.5 would normally result in a double. However, because we're using the += operator, the result is implicitly cast back to an int, truncating the decimal part. If we had used num = num + 2.5; directly, it would have resulted in a compile-time error because you can't directly assign a double to an int without explicit casting.

#### <a name="chapter2part5.3"></a>Chapter 2 - Part 5.3: Practical Examples and Demonstrations

Let's look at some more practical examples of how assignment operators can be used in Java programs.

**Example 1: Calculating the Sum of Numbers**

```java
public class SumCalculator {
    public static void main(String[] args) {
        int sum = 0; // Initialize the sum to 0
        sum += 10; // Add 10 to the sum
        sum += 25; // Add 25 to the sum
        sum += 5; // Add 5 to the sum

        System.out.println("The sum is: " + sum); // Output: The sum is: 40
    }
}
```

**Example 2: Updating a Product Price**

```java
public class PriceUpdater {
    public static void main(String[] args) {
        double price = 99.99; // Initial price
        double discount = 0.20; // 20% discount

        price -= price * discount; // Apply the discount
        System.out.println("The discounted price is: " + price); // Output: The discounted price is: 79.992
    }
}
```

**Example 3: Incrementing a Counter**

```java
public class Counter {
    public static void main(String[] args) {
        int count = 0; // Initialize the counter
        count++; // Increment the counter (covered in the next lesson, but shown here for context)
        count += 1; // Increment the counter using +=

        System.out.println("The count is: " + count); // Output: The count is: 2
    }
}
```

**Example 4: Accumulating Values in a Loop**

```java
public class LoopAccumulator {
    public static void main(String[] args) {
        int total = 0;
        for (int i = 1; i <= 5; i++) {
            total += i; // Add the current value of i to the total
        }
        System.out.println("The total is: " + total); // Output: The total is: 15
    }
}
```

#### <a name="chapter2part6"></a>Chapter 2 - Part 6: Comparison Operators: ==, !=, >, <, >=, <=

Comparison operators are fundamental building blocks in Java, allowing you to create logic that makes decisions based on the relationship between values. They are essential for controlling the flow of your program and performing different actions based on specific conditions. Understanding how to use comparison operators correctly is crucial for writing effective and bug-free Java code. This lesson will provide a comprehensive overview of each comparison operator, along with practical examples and exercises to solidify your understanding.

#### <a name="chapter2part6.1"></a>Chapter 2 - Part 6.1: Understanding Comparison Operators

Comparison operators are used to compare two values. The result of a comparison operation is always a boolean value: true or false. Java provides six comparison operators:

- ```==``` (equal to)
- ```!=``` (not equal to)
- ```>``` (greater than)
- ```<``` (less than)
- ```>=``` (greater than or equal to)
- ```<=``` (less than or equal to)

These operators can be used to compare primitive data types (like int, double, char, boolean) and, with some caveats, objects (specifically using == and !=).

**The == (Equal To) Operator**

The == operator checks if two values are equal. If they are, it returns true; otherwise, it returns false.

**Example with Integers**:

```java
int x = 5;
int y = 5;
int z = 10;

System.out.println(x == y); // Output: true
System.out.println(x == z); // Output: false
```

**Example with Doubles:**

```java
double a = 3.14;
double b = 3.14;
double c = 2.71;

System.out.println(a == b); // Output: true
System.out.println(a == c); // Output: false
```

**Example with Characters:**

```java
char p = 'A';
char q = 'A';
char r = 'B';

System.out.println(p == q); // Output: true
System.out.println(p == r); // Output: false
```

**Important Note Regarding Objects**:

When using == with objects (like Strings, or custom objects you'll learn to create later), it checks if the two variables refer to the same object in memory, not whether the objects have the same value. This is a crucial distinction.

```java
String str1 = new String("Hello");
String str2 = new String("Hello");
String str3 = str1;

System.out.println(str1 == str2); // Output: false (different objects)
System.out.println(str1 == str3); // Output: true (same object)
```

To compare the content of objects (like Strings), you should use the .equals() method, which will be covered in a later module.

**The != (Not Equal To) Operator**

The != operator checks if two values are not equal. It returns true if they are different, and false if they are the same.

**Example with Integers**:

```java
int x = 5;
int y = 5;
int z = 10;

System.out.println(x != y); // Output: false
System.out.println(x != z); // Output: true
```

**Example with Doubles**:

```java
double a = 3.14;
double b = 3.14;
double c = 2.71;

System.out.println(a != b); // Output: false
System.out.println(a != c); // Output: true
```

**Example with Characters**:

```java
char p = 'A';
char q = 'A';
char r = 'B';

System.out.println(p != q); // Output: false
System.out.println(p != r); // Output: true
```

**Important Note Regarding Objects**:

Similar to ==, when using != with objects, it checks if the two variables refer to different objects in memory.

```java
String str1 = new String("Hello");
String str2 = new String("Hello");

System.out.println(str1 != str2); // Output: true (different objects)
```

**The ```>``` (Greater Than) Operator**:

The > operator checks if the value on the left is greater than the value on the right. It returns true if it is, and false otherwise. This operator is typically used with numerical data types.

**Example with Integers**:

```java
int x = 10;
int y = 5;
int z = 10;

System.out.println(x > y); // Output: true
System.out.println(y > x); // Output: false
System.out.println(x > z); // Output: false
```

**Example with Doubles**:

```java
double a = 3.14;
double b = 2.71;
double c = 3.14;

System.out.println(a > b); // Output: true
System.out.println(b > a); // Output: false
System.out.println(a > c); // Output: false
```

**Example with Characters**:

Characters can also be compared using >, as they have underlying numerical (Unicode) values.

```java
char p = 'C'; // Unicode value 67
char q = 'A'; // Unicode value 65

System.out.println(p > q); // Output: true (67 > 65)
```

**The ```<``` (Less Than) Operator**:

The < operator checks if the value on the left is less than the value on the right. It returns true if it is, and false otherwise. This operator is also typically used with numerical data types.

**Example with Integers**:

```java
int x = 5;
int y = 10;
int z = 5;

System.out.println(x < y); // Output: true
System.out.println(y < x); // Output: false
System.out.println(x < z); // Output: false
```

**Example with Doubles**:

```java
double a = 2.71;
double b = 3.14;
double c = 2.71;

System.out.println(a < b); // Output: true
System.out.println(b < a); // Output: false
System.out.println(a < c); // Output: false
```

**Example with Characters**:

```java
char p = 'A'; // Unicode value 65
char q = 'C'; // Unicode value 67

System.out.println(p < q); // Output: true (65 < 67)
```

**The ```>=``` (Greater Than or Equal To) Operator**:

The >= operator checks if the value on the left is greater than or equal to the value on the right. It returns true if it is, and false otherwise.

**Example with Integers**:

```java
int x = 10;
int y = 5;
int z = 10;

System.out.println(x >= y); // Output: true
System.out.println(x >= z); // Output: true
System.out.println(y >= x); // Output: false
```

**Example with Doubles**:

```java
double a = 3.14;
double b = 2.71;
double c = 3.14;

System.out.println(a >= b); // Output: true
System.out.println(a >= c); // Output: true
System.out.println(b >= a); // Output: false
```

**Example with Characters**:

```java
char p = 'C'; // Unicode value 67
char q = 'A'; // Unicode value 65
char r = 'C'; // Unicode value 67

System.out.println(p >= q); // Output: true (67 >= 65)
System.out.println(p >= r); // Output: true (67 >= 67)
```

**The ```<=``` (Less Than or Equal To) Operator**:

The <= operator checks if the value on the left is less than or equal to the value on the right. It returns true if it is, and false otherwise.

**Example with Integers**:

```java
int x = 5;
int y = 10;
int z = 5;

System.out.println(x <= y); // Output: true
System.out.println(x <= z); // Output: true
System.out.println(y <= x); // Output: false
```

**Example with Doubles**:

```java
double a = 2.71;
double b = 3.14;
double c = 2.71;

System.out.println(a <= b); // Output: true
System.out.println(a <= c); // Output: true
System.out.println(b <= a); // Output: false
```

**Example with Characters**:

```java
char p = 'A'; // Unicode value 65
char q = 'C'; // Unicode value 67
char r = 'A'; // Unicode value 65

System.out.println(p <= q); // Output: true (65 <= 67)
System.out.println(p <= r); // Output: true (65 <= 65)
```

#### <a name="chapter2part6.2"></a>Chapter 2 - Part 6.2: Practical Examples and Demonstrations

Let's look at some more practical examples of how comparison operators can be used in Java programs.

**Example 1: Checking if a number is within a range**

```java
int age = 25;
int votingAge = 18;

boolean isEligibleToVote = age >= votingAge;

System.out.println("Is eligible to vote: " + isEligibleToVote); // Output: true
```

**Example 2: Comparing two double values with a tolerance**

Due to the way floating-point numbers are represented in computers, direct comparison using == can sometimes be unreliable. It's often better to check if the difference between two doubles is within a small tolerance.

```java
double value1 = 0.1 + 0.2;
double value2 = 0.3;
double tolerance = 0.00001;

boolean areEqual = Math.abs(value1 - value2) < tolerance;

System.out.println("Are equal: " + areEqual); // Output: true
```

**Example 3: Comparing characters to determine alphabetical order**

```java
char char1 = 'M';
char char2 = 'P';

if (char1 < char2) {
    System.out.println(char1 + " comes before " + char2 + " in the alphabet.");
} else {
    System.out.println(char2 + " comes before " + char1 + " in the alphabet.");
}
// Output: M comes before P in the alphabet.
```

#### <a name="chapter2part7"></a>Chapter 2 - Part 7: Logical Operators: &&, ||, !

Logical operators are fundamental building blocks in Java, allowing you to create more complex and nuanced conditions in your code. They enable you to combine multiple boolean expressions, creating powerful decision-making capabilities within your programs. Understanding and effectively using logical operators is crucial for controlling the flow of execution and implementing sophisticated logic.

#### <a name="chapter2part7.1"></a>Chapter 2 - Part 7.1: Understanding Logical Operators

Logical operators are used to combine two or more boolean expressions into a single boolean result. Java provides three main logical operators:

- **```&&```  (Logical AND)**: Returns true if both operands are true. Otherwise, it returns false.

- **```||``` (Logical OR)**: Returns true if at least one of the operands is true. It returns false only if both operands are false.

- **```!``` (Logical NOT)**: This is a unary operator that inverts the boolean value of its operand. If the operand is true, ! returns false, and vice versa.

**Logical AND ```(&&)```**:

The logical AND operator (&&) evaluates to true only when both operands are true. Think of it as requiring both conditions to be met.

|Operand 1	|Operand 2	|Result|
| :-----------: | :-------------: | :-------------: |
|true	|true	|true|
|true	|false	|false|
|false	|true	|false|
|false	|false	|false|

**Example**

```java
int age = 25;
boolean isStudent = true;

// Check if the person is both older than 18 AND a student
boolean isEligibleForDiscount = age > 18 && isStudent;
System.out.println("Eligible for discount: " + isEligibleForDiscount); // Output: true

age = 16;
isEligibleForDiscount = age > 18 && isStudent;
System.out.println("Eligible for discount: " + isEligibleForDiscount); // Output: false
```

In the first case, both conditions (age > 18 and isStudent) are true, so the result is true. In the second case, age > 18 is false, so the entire expression becomes false.

**Short-circuiting**: The && operator exhibits short-circuiting behavior. This means that if the left-hand operand evaluates to false, the right-hand operand is not evaluated. This is because the result of the entire expression will be false regardless of the value of the right-hand operand. This can improve performance and prevent potential errors.

```java
int x = 5;
int y = 0;

// The second condition (y != 0 && x / y > 2) will not be evaluated because x > 10 is false.
if (x > 10 && x / y > 2) {
    System.out.println("This will not be printed.");
} else {
    System.out.println("Short-circuiting occurred."); // Output: Short-circuiting occurred.
}
```

In this example, if the right-hand operand was evaluated, it would result in a division by zero error. However, because of short-circuiting, this error is avoided.

**Logical OR ```(||)```**:

The logical OR operator (||) evaluates to true if at least one of the operands is true. It only evaluates to false if both operands are false.

|Operand 1|	Operand 2|	Result|
| :-----------: | :-------------: | :-------------: |
|true	|true	|true|
|true	|false	|true|
|false|	true	|true|
|false	|false	|false|

**Example**:

```java
int temperature = 28;
boolean isRaining = false;

// Check if it's either hot OR raining
boolean shouldWearJacket = temperature < 15 || isRaining;
System.out.println("Should wear a jacket: " + shouldWearJacket); // Output: false

temperature = 10;
shouldWearJacket = temperature < 15 || isRaining;
System.out.println("Should wear a jacket: " + shouldWearJacket); // Output: true
```

In the first case, both conditions (temperature < 15 and isRaining) are false, so the result is false. In the second case, temperature < 15 is true, so the entire expression becomes true.

**Short-circuiting**: Similar to &&, the || operator also exhibits short-circuiting. If the left-hand operand evaluates to true, the right-hand operand is not evaluated. This is because the result of the entire expression will be true regardless of the value of the right-hand operand.

```java
String name = null;

// The second condition (name.length() > 5) will not be evaluated because name == null is true.
if (name == null || name.length() > 5) {
    System.out.println("Name is null or longer than 5 characters."); // Output: Name is null or longer than 5 characters.
}
```

In this example, if the right-hand operand was evaluated, it would result in a NullPointerException. However, because of short-circuiting, this exception is avoided.

**Logical NOT ```(!)```**:

The logical NOT operator (!) is a unary operator that inverts the boolean value of its operand. If the operand is true, ! returns false, and if the operand is false, ! returns true.

|Operand	|Result|
| :-----------: | :-------------: |
|true	|false|
|false	|true|

**Example**:

```java
boolean isLoggedIn = false;

// Check if the user is NOT logged in
boolean isLoggedOut = !isLoggedIn;
System.out.println("Is logged out: " + isLoggedOut); // Output: true

isLoggedIn = true;
isLoggedOut = !isLoggedIn;
System.out.println("Is logged out: " + isLoggedOut); // Output: false
```

In the first case, isLoggedIn is false, so !isLoggedIn is true. In the second case, isLoggedIn is true, so !isLoggedIn is false.

**Using NOT to simplify conditions**: The NOT operator can sometimes be used to make conditions more readable or to express them in a different way.

```java
int score = 75;
boolean isPassing = score >= 60;
boolean isFailing = !isPassing; // Equivalent to score < 60

System.out.println("Is passing: " + isPassing); // Output: true
System.out.println("Is failing: " + isFailing); // Output: false
```

#### <a name="chapter2part7.2"></a>Chapter 2 - Part 7.2: Combining Logical Operators

You can combine multiple logical operators to create more complex conditions. When combining operators, it's important to understand operator precedence (which will be covered in the next lesson) and to use parentheses to ensure that the expression is evaluated in the order you intend.

**Example**:

```java
int age = 20;
boolean hasLicense = true;
boolean isInsured = false;

// Check if the person is of legal age AND has a license AND is insured
boolean canDrive = age >= 18 && hasLicense && isInsured;
System.out.println("Can drive: " + canDrive); // Output: false

// Check if the person is of legal age AND (has a license OR is insured)
canDrive = age >= 18 && (hasLicense || isInsured);
System.out.println("Can drive: " + canDrive); // Output: true
```

In the first case, all three conditions must be true for canDrive to be true. In the second case, the person must be of legal age, and they must have either a license or insurance (or both). The parentheses ensure that the || operation is performed before the && operation.

#### <a name="chapter2part7.3"></a>Chapter 2 - Part 7.3: Practical Examples

Let's consider a scenario where you're building a simple e-commerce application. You might use logical operators to determine whether a user is eligible for a discount based on their membership status and purchase amount.

```java
boolean isMember = true;
double purchaseAmount = 120.0;

// Check if the user is a member OR if their purchase amount is greater than $100
boolean isEligibleForDiscount = isMember || purchaseAmount > 100.0;

if (isEligibleForDiscount) {
    System.out.println("User is eligible for a discount."); // Output: User is eligible for a discount.
} else {
    System.out.println("User is not eligible for a discount.");
}

// Check if the user is a member AND their purchase amount is greater than $50
boolean isEligibleForFreeShipping = isMember && purchaseAmount > 50.0;

if (isEligibleForFreeShipping) {
    System.out.println("User is eligible for free shipping."); // Output: User is eligible for free shipping.
} else {
    System.out.println("User is not eligible for free shipping.");
}
```

In this example, the || operator is used to check if the user is either a member or has a purchase amount greater than $100. The && operator is used to check if the user is both a member and has a purchase amount greater than $50.

#### <a name="chapter7part8"></a>Chapter 7 - Part 8: Bitwise Operators

The Bitwise operators are used to perform a bit manipulation on numbers. This Operator can be used with any integral type(char, int, short, etc) but it cannot be applied to double and float.

<br>

<div align="center"><img src="img/bitwise-w582-h400.png" width=582 height=400><br><sub>Fig 24 - Bitwise Operators used in Java - (<a href='https://www.javastudypoint.com/2019/12/bitwise-operators-in-java.html'>Work by javastudypoint</a>) </sub></div>

<br>

**Types of Bitwise Operators in Java**

1. **Bitwise AND (&) Operator:** This operator returns 1 if both the operands are also 1 else it returns 0.

2. **Bitwise OR (|) Operator:** This operator returns 1 if either of the bits in the operand is 1, else it returns 0.

3. **Bitwise Complement (~) Operator:** This operator inverts all of the bits of its operands.

4. **Bitwise Exclusive OR (^) Operator:** This operator returns 1 if the corresponding bits are different, else it returns 0.

5. **Bitwise Shift Left (<<) Operator:** This operator shifts the bits of the number to the left and fills 0 in the void spaces that are left as a result.

6. **Bitwise Shift Right (>>) Operator:** This operator shifts the bits of the number to the right and fills 0 in the void spaces that are left as a result.

7. **Shift Right Zero Fill (>>>), Operator:** This operator shifts the bits of the number to the right and fills 0 in the void spaces that are left as a result. The leftmost bit is set to be 0.

<br>

<div align="center"><img src="img/bitwise_truth_table-w1291-h472.png" width=1291 height=472><br><sub>Fig 25 - Bitwise Operators Truth Table - (<a href='https://www.javastudypoint.com/2019/12/bitwise-operators-in-java.html'>Work by  freeCodeCamp</a>) </sub></div>

<br>

```java

public class BitwiseOperator {
    public static void main(String[] args)
    {
        //Initial values
        int a = 6;
        int b = 7;

        // bitwise and
        // 0110 & 0111=0110 = 6
        System.out.println("a&b = " + (a & b));

        // bitwise or
        // 0110 | 0111=0111 = 7
        System.out.println("a|b = " + (a | b));

        // bitwise xor
        // 0110 ^ 0111=0001 = 1
        System.out.println("a^b = " + (a ^ b));

        // bitwise and
        // ~0110=1001
        // will give 2's complement of 1001 = -7
        System.out.println("~a = " + ~a);

		// bitwise left shift
		System.out.println("a << 2 = " +(a << 2));

		// bitwise right shift
		System.out.println("a >> 2 = " +(a >> 2));

		// bitwise shift right zero fill
		System.out.println("b >>> 2 = " +(b >>> 2));
	}

}

```

```java


    int a = 60;	      /* 60 = 0011 1100 represents 60 in binary*/
    int b = 13;	      /* 13 = 0000 1101 */
    int c = 0;
    
    c = a & b;        /* 12 = 0000 1100 */
    c = a | b;        /* 61 = 0011 1101 */
    c = a ^ b;        /* 49 = 0011 0001 */
    c = ~a;           /*-61 = 1100 0011  :Invert all bits */
    
    // shift operators : zeros are shifted in to replace the discarded bits
    c = a << 2;       /* 240 = 1111 0000 : Shift left 2 bits*/
    c = a >> 2;       /* 15 = 1111 */
    c = a >>> 2;      /* 15 = 0000 1111 : Zero fill right shift*/

```

```java

import java.util.Scanner;

public class Program {
	
	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		
		int mask = 0b100000; //binary number declared in Java, in this case, 32
		System.out.println(mask);
		int n = sc.nextInt();
		
		if ((n & mask) != 0) {
			System.out.println("6th bit is true!");
		} else {
			System.out.println("6th bit is false");
		}
		sc.close();
	}
}

```


#### <a name="chapter2part9"></a>Chapter 2 - Part 9: Operator Precedence

Operator precedence dictates the order in which operators are evaluated in a Java expression. Understanding operator precedence is crucial for writing correct and predictable code. Without this knowledge, the results of calculations might be unexpected, leading to bugs that are difficult to find. This lesson will cover the rules of operator precedence in Java, providing examples and exercises to solidify your understanding.

#### <a name="chapter2part9.1"></a>Chapter 2 - Part 9.1: Understanding Operator Precedence in Java

Operator precedence determines which operations are performed first in an expression. Operators with higher precedence are evaluated before operators with lower precedence. When operators have the same precedence, their associativity determines the order of evaluation (left-to-right or right-to-left).

Here's a table summarizing the precedence of common Java operators, from highest to lowest:

|Precedence	|Operator(s)	|Associativity|
| :-----------: | :-------------: | :-------------: |
|1	|```[]```, ```.```, ```()``` (method call)|	Left-to-right|
|2	|```++```, ```--``` (postfix)|	Left-to-right|
|3	|```++```, ```--``` (prefix), ```+```, ```-```, ```!```, ```~```|	Right-to-left|
|4	|```*```, ```/```, ```%```|	Left-to-right|
|5	|```+```, ```-```|	Left-to-right|
|6	|```<<```, ```>>```, ```>>>```|	Left-to-right|
|7	|```<```, ```<=```, ```>```, ```>=```, instanceof|	Left-to-right|
|8	|```==```, ```!=```|	Left-to-right|
|9	|```&```|	Left-to-right|
|10	|```^```|	Left-to-right|
|11	|&&|	Left-to-right|
|12	|```? :```|	Right-to-left|
|13	|```=```, ```+=```, ```-=```, ```*=```, ```/=```, ```%=```, ```&=```, ```^=```|	```=```, ```<<=```, ```>>=```, ```>>>=```|

**Arithmetic Operators**

Arithmetic operators (```*```, ```/```, ```%```, ```+```, ```-```) follow the standard mathematical order of operations. Multiplication, division, and modulus have higher precedence than addition and subtraction.

**Example 1**:

```java
int result = 5 + 3 * 2; // Multiplication is performed before addition
System.out.println(result); // Output: 11
```

In this example, 3 * 2 is evaluated first, resulting in 6. Then, 5 + 6 is evaluated, resulting in 11.

**Example 2**:

```java
int result = (5 + 3) * 2; // Parentheses change the order of operations
System.out.println(result); // Output: 16
```

Here, the parentheses force 5 + 3 to be evaluated first, resulting in 8. Then, 8 * 2 is evaluated, resulting in 16.

**Increment and Decrement Operators**

Increment (```++```) and decrement (```--```) operators can be used in prefix or postfix form. The precedence differs depending on the form.

Postfix: The value is used before it is incremented/decremented. Prefix: The value is incremented/decremented before it is used.

Example 1 (Postfix):

```java
int x = 5;
int y = x++; // y = 5, then x = 6
System.out.println("x = " + x + ", y = " + y); // Output: x = 6, y = 5
```

**Example 2 (Prefix)**:

```java
int x = 5;
int y = ++x; // x = 6, then y = 6
System.out.println("x = " + x + ", y = " + y); // Output: x = 6, y = 6
```

**Example 3 (Precedence with other operators)**:

```java
int x = 5;
int y = 10;
int result = ++x + y--; // x becomes 6, then 6 + 10 is evaluated, then y becomes 9
System.out.println("x = " + x + ", y = " + y + ", result = " + result); // Output: x = 6, y = 9, result = 16
```

In this example, the prefix increment ++x has higher precedence than the addition + and the postfix decrement y--. Therefore, x is incremented to 6 first. Then, 6 + y is evaluated (using the original value of y, which is 10), resulting in 16. Finally, y is decremented to 9.

**Comparison Operators**

Comparison operators (```==```, ```!=```, ```>```, ```<```, ```>=```, ```<=```) are used to compare values. They have lower precedence than arithmetic operators.

Example:

```java
int x = 5;
int y = 10;
boolean result = x + 5 > y - 2; // Arithmetic operations are performed before comparison
System.out.println(result); // Output: false (10 > 8 is false)
```

Here, x + 5 is evaluated to 10, and y - 2 is evaluated to 8. Then, 10 > 8 is evaluated, resulting in false.

**Logical Operators**

Logical operators (&&, ||, !) are used to combine boolean expressions. ! (logical NOT) has the highest precedence among logical operators, followed by && (logical AND), and then || (logical OR).

**Example 1**:

```java
boolean a = true;
boolean b = false;
boolean result = a || b && false; // AND is performed before OR
System.out.println(result); // Output: true (true || (false && false) -> true || false -> true)
```

In this example, b && false is evaluated first, resulting in false. Then, a || false is evaluated, resulting in true.

**Example 2**:

```java
boolean a = true;
boolean b = false;
boolean result = (a || b) && false; // Parentheses change the order of operations
System.out.println(result); // Output: false ((true || false) && false -> true && false -> false)
```

Here, the parentheses force a || b to be evaluated first, resulting in true. Then, true && false is evaluated, resulting in false.

**Example 3**:

```java
boolean a = true;
boolean b = false;
boolean result = !b && a; // NOT is performed before AND
System.out.println(result); // Output: true ((!false) && true -> true && true -> true)
```

In this example, !b is evaluated first, resulting in true. Then, true && a is evaluated, resulting in true.

**Assignment Operators**

Assignment operators (=, +=, -=, *=, /=, %=) have the lowest precedence. They are evaluated after all other operations in the expression.

**Example**:

```java
int x = 5;
int y = 10;
x += y * 2; // Multiplication is performed before addition and assignment
System.out.println(x); // Output: 25 (x = x + (y * 2) -> x = 5 + (10 * 2) -> x = 5 + 20 -> x = 25)
```

Here, y * 2 is evaluated to 20. Then, x + 20 is evaluated to 25. Finally, x is assigned the value 25.

#### <a name="chapter2part9.2"></a>Chapter 2 - Part 9.2: Using Parentheses to Control Precedence

Parentheses () can be used to override the default operator precedence. Expressions within parentheses are always evaluated first. This can improve code readability and prevent unexpected results.

**Example 1**:

```java
int result = 10 - 2 * 3; // Multiplication is performed before subtraction
System.out.println(result); // Output: 4
```

**Example 2**:

```java
int result = (10 - 2) * 3; // Parentheses change the order of operations
System.out.println(result); // Output: 24
```

In the first example, 2 * 3 is evaluated first, resulting in 6. Then, 10 - 6 is evaluated, resulting in 4. In the second example, 10 - 2 is evaluated first due to the parentheses, resulting in 8. Then, 8 * 3 is evaluated, resulting in 24.

#### <a name="chapter2part9.3"></a>Chapter 2 - Part 9.3: Practical Examples and Demonstrations

Let's consider a more complex example that combines multiple operators:

```java
int a = 5;
int b = 3;
int c = 10;
int result = a++ + b * 2 - c / 3;
System.out.println("Initial values: a = 5, b = 3, c = 10");
// a++ (postfix increment): a is used as 5, then incremented to 6
// b * 2: 3 * 2 = 6
// c / 3: 10 / 3 = 3 (integer division)
// 5 + 6 - 3 = 8
System.out.println("a = " + a + ", b = " + b + ", c = " + c + ", result = " + result); // Output: a = 6, b = 3, c = 10, result = 8
```

Here's a breakdown of the evaluation:

- a++ is evaluated. The current value of a (which is 5) is used in the expression, and then a is incremented to 6.
- b * 2 is evaluated, resulting in 6.
- c / 3 is evaluated, resulting in 3 (integer division).
- 5 + 6 - 3 is evaluated from left to right, resulting in 8.
- The value 8 is assigned to result.

## <a name="chapter3"></a>Chapter 3: Control Flow: Making Decisions and Repeating Actions

Control flow statements are the fundamental building blocks that allow programs to make decisions and repeat actions. Without control flow, a program would execute sequentially, line by line, offering no flexibility or adaptability. This lesson introduces the core concepts of control flow and sets the stage for understanding how to write more complex and dynamic Java programs. We'll explore the different types of control flow statements available in Java and how they alter the execution path of your code.

#### <a name="chapter3part1"></a>Chapter 3 - Part 1: Introduction to Control Flow Statements

Control flow refers to the order in which individual statements, instructions or function calls of an imperative program are executed or evaluated. In simple terms, it's the path your code takes as it runs. By default, Java executes code sequentially, from top to bottom, within a method. Control flow statements allow you to deviate from this linear execution, enabling your program to respond to different conditions and perform repetitive tasks.

#### <a name="chapter3part1.1"></a>Chapter 3 - Part 1.1: Understanding Control Flow

Control flow refers to the order in which individual statements, instructions or function calls of an imperative program are executed or evaluated. In simple terms, it's the path your code takes as it runs. By default, Java executes code sequentially, from top to bottom, within a method. Control flow statements allow you to deviate from this linear execution, enabling your program to respond to different conditions and perform repetitive tasks.

**Types of Control Flow Statements**

- **Decision-Making Statements**: These statements allow your program to choose between different paths of execution based on certain conditions. The primary decision-making statements in Java are:
  - ```if``` statement
  - ```if-else``` statement
  - ```if-else if-else``` statement
  - ```switch``` statement
 
- **Looping Statements**: These statements allow you to repeat a block of code multiple times. The looping statements in Java are:
  - ```while``` loop
  - ```do-while``` loop
  - ```for``` loop
  - ```for-each``` loop
 
**Importance of Control Flow**

Control flow statements are essential for creating programs that can:

- **React to User Input**: A program can take different actions based on what the user enters.
- **Process Data Conditionally**: A program can perform different calculations or operations depending on the data it receives.
- **Automate Repetitive Tasks**: A program can repeat a set of instructions multiple times, saving time and effort.
- **Implement Complex Algorithms**: Many algorithms rely on conditional execution and repetition to solve problems.

#### <a name="chapter3part1.2"></a>Chapter 3 - Part 1.2: Decision-Making Statements: An Overview

Decision-making statements allow a program to execute specific blocks of code only when certain conditions are met. These conditions are evaluated as boolean expressions (i.e., they result in either true or false).

**The ```if``` Statement**

The if statement is the simplest form of decision-making. It executes a block of code only if a specified condition is true.

```java
if (condition) {
    // Code to be executed if the condition is true
}
```

**Example**:

```java
int age = 20;

if (age >= 18) {
    System.out.println("You are eligible to vote.");
}
```

In this example, the message "You are eligible to vote." will be printed to the console only if the value of the age variable is greater than or equal to 18.

**The ```if-else``` Statement**

The if-else statement provides an alternative block of code to execute when the condition in the if statement is false.

**Syntax**:

```java
if (condition) {
    // Code to be executed if the condition is true
} else {
    // Code to be executed if the condition is false
}
```

**Example**:

```java
int age = 16;

if (age >= 18) {
    System.out.println("You are eligible to vote.");
} else {
    System.out.println("You are not eligible to vote yet.");
}
```

In this example, since age is 16 (less than 18), the message "You are not eligible to vote yet." will be printed.

**The ```if-else if-else``` Statement**

The if-else if-else statement allows you to check multiple conditions in sequence. It provides a way to handle more complex decision-making scenarios where you have several possible outcomes.

**Syntax**:

```java
if (condition1) {
    // Code to be executed if condition1 is true
} else if (condition2) {
    // Code to be executed if condition1 is false AND condition2 is true
} else if (condition3) {
    // Code to be executed if condition1 and condition2 are false AND condition3 is true
} else {
    // Code to be executed if all conditions are false
}
```

**Example**:

```java
int score = 75;

if (score >= 90) {
    System.out.println("Grade: A");
} else if (score >= 80) {
    System.out.println("Grade: B");
} else if (score >= 70) {
    System.out.println("Grade: C");
} else if (score >= 60) {
    System.out.println("Grade: D");
} else {
    System.out.println("Grade: F");
}
```

In this example, the program checks the value of the score variable against a series of conditions. Since score is 75, the message "Grade: C" will be printed.

**The ```switch``` Statement**

The switch statement provides a more efficient way to select one block of code to execute from a set of possible cases, based on the value of a single variable or expression. It's particularly useful when you have multiple possible values to check against.

**Syntax**:

```java
switch (expression) {
    case value1:
        // Code to be executed if expression equals value1
        break;
    case value2:
        // Code to be executed if expression equals value2
        break;
    case value3:
        // Code to be executed if expression equals value3
        break;
    default:
        // Code to be executed if expression doesn't match any of the cases
}
```

**Explanation**:

- The switch statement evaluates the expression.
- The case labels specify the different possible values of the expression.
- If the value of the expression matches a case label, the code within that case block is executed.
- The break statement is crucial. It terminates the switch statement and prevents the execution of subsequent case blocks. If you omit the break statement, the program will "fall through" to the next case block, even if the value of the expression doesn't match that case.
- The default case is optional. It provides a block of code to execute if the value of the expression doesn't match any of the case labels.

**Example**:

```java
int dayOfWeek = 3;

switch (dayOfWeek) {
    case 1:
        System.out.println("Monday");
        break;
    case 2:
        System.out.println("Tuesday");
        break;
    case 3:
        System.out.println("Wednesday");
        break;
    case 4:
        System.out.println("Thursday");
        break;
    case 5:
        System.out.println("Friday");
        break;
    case 6:
        System.out.println("Saturday");
        break;
    case 7:
        System.out.println("Sunday");
        break;
    default:
        System.out.println("Invalid day");
}
```

In this example, since dayOfWeek is 3, the message "Wednesday" will be printed.

#### <a name="chapter3part1.3"></a>Chapter 3 - Part 1.3: Looping Statements: An Introduction

Looping statements allow you to execute a block of code repeatedly, as long as a certain condition remains true. This is incredibly useful for automating tasks that need to be performed multiple times.

**The ```while``` Loop**

The while loop executes a block of code repeatedly as long as a specified condition is true. The condition is checked before each iteration of the loop.

**Syntax**:

```java
while (condition) {
    // Code to be executed repeatedly as long as the condition is true
}
```

**Example**:

```java
int count = 1;

while (count <= 5) {
    System.out.println("Count: " + count);
    count++; // Increment the counter
}
```

In this example, the loop will execute as long as the value of count is less than or equal to 5. The message "Count: " followed by the current value of count will be printed in each iteration. The count++ statement increments the value of count by 1 after each iteration. Without this increment, the loop would run indefinitely (an infinite loop).

**The ```do-while``` Loop**

The do-while loop is similar to the while loop, but with one key difference: the condition is checked after each iteration of the loop. This means that the code block inside the do-while loop will always be executed at least once, even if the condition is initially false.

**Syntax**:

```java
do {
    // Code to be executed repeatedly as long as the condition is true
} while (condition);
```

**Example**:

```java
int count = 6;

do {
    System.out.println("Count: " + count);
    count++;
} while (count <= 5);
```

In this example, even though count is initially 6 (which is greater than 5), the code inside the do block will be executed once. The message "Count: 6" will be printed. Then, the condition count <= 5 will be checked. Since it's false, the loop will terminate.

**The ```for``` Loop**

The for loop provides a more concise way to write loops that iterate a specific number of times. It combines the initialization, condition checking, and increment/decrement steps into a single statement.

**Syntax**:

```java
for (initialization; condition; increment/decrement) {
    // Code to be executed repeatedly as long as the condition is true
}
```

**Explanation**:

- **Initialization**: This part is executed only once, at the beginning of the loop. It's typically used to declare and initialize a loop counter variable.
- **Condition**: This condition is checked before each iteration of the loop. If it's true, the loop body is executed. If it's false, the loop terminates.
- **Increment/Decrement**: This part is executed after each iteration of the loop. It's typically used to update the loop counter variable.

**Example**:

```java
for (int i = 1; i <= 5; i++) {
    System.out.println("Iteration: " + i);
}
```

In this example, the loop will execute 5 times. The variable i is initialized to 1. The loop continues as long as i is less than or equal to 5. After each iteration, i is incremented by 1.

**The ```for-each``` Loop**

The for-each loop automatically handles the iteration process, so you don't need to worry about index variables or incrementing counters. It iterates through each element in the array or collection, one at a time, and makes the element available to you within the loop's body.

```java
for (dataType element : arrayOrCollection) {
    // Code to be executed for each element
    // You can use the 'element' variable to access the current element
}
```

**Explanation**:

- **dataType**: The data type of the elements in the array or collection.
- **element**: A variable that will hold the current element during each iteration.
- **arrayOrCollection**: The array or collection you want to iterate through.

**Example with Arrays**:

```java
public class ForEachArrayExample {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};

        // Using a for-each loop to print each element in the array
        for (int number : numbers) {
            System.out.println(number);
        }
    }
}
```

```
1
2
3
4
5
```

#### <a name="chapter3part1.4"></a>Chapter 3 - Part 1.4: Using break and continue Statements

The break and continue statements provide additional control over the execution of loops.

**The ```break``` Statement**

The break statement is used to terminate a loop prematurely. When a break statement is encountered inside a loop, the loop is immediately exited, and the program continues with the next statement after the loop.

**Example**:

```java
for (int i = 1; i <= 10; i++) {
    if (i == 5) {
        break; // Exit the loop when i is 5
    }
    System.out.println("Iteration: " + i);
}
```

In this example, the loop is intended to iterate from 1 to 10. However, when i becomes 5, the break statement is executed, and the loop terminates. The output will be:

```
Iteration: 1
Iteration: 2
Iteration: 3
Iteration: 4
```

**The ```continue``` Statement**

The continue statement is used to skip the current iteration of a loop and proceed to the next iteration. When a continue statement is encountered inside a loop, the remaining code in the current iteration is skipped, and the loop proceeds to the next iteration.

**Example**:

```java
for (int i = 1; i <= 10; i++) {
    if (i % 2 == 0) {
        continue; // Skip even numbers
    }
    System.out.println("Iteration: " + i);
}
```

In this example, the loop iterates from 1 to 10. However, when i is an even number (i.e., i % 2 == 0 is true), the continue statement is executed, and the remaining code in the current iteration (the System.out.println() statement) is skipped. The output will be:

```
Iteration: 1
Iteration: 3
Iteration: 5
Iteration: 7
Iteration: 9
```

#### <a name="chapter3part2"></a>Chapter 3 - Part 2: The `if` Statement: Conditional Execution

The if statement is a fundamental building block of control flow in Java, allowing programs to make decisions and execute different code paths based on whether a condition is true or false. It enables programs to respond dynamically to different inputs and situations, making them more versatile and intelligent. Understanding the if statement is crucial for writing programs that can solve real-world problems.

#### <a name="chapter3part2.1"></a>Chapter 3 - Part 2.1: Understanding the if Statement

The if statement in Java allows you to execute a block of code only if a specified condition is true. The basic syntax is as follows:

```java
if (condition) {
    // Code to be executed if the condition is true
}
```

The condition is a boolean expression that evaluates to either true or false. If the condition is true, the code within the curly braces {} is executed. If the condition is false, the code block is skipped, and the program continues with the next statement after the if block.

**Anatomy of an if Statement**

Let's break down the components of an if statement:

- **```if``` Keyword**: This keyword signals the start of the conditional statement.
- **Condition**: This is a boolean expression enclosed in parentheses (). It can be a simple comparison (e.g., x > 5) or a more complex logical expression (e.g., (x > 5) && (y < 10)).
- **Code Block**: This is a block of code enclosed in curly braces {}. This code is executed only if the condition evaluates to true. If the code block contains only one statement, the curly braces can be omitted, but it's generally recommended to always use them for clarity and to avoid potential errors when adding more statements later.

**Boolean Expressions**

The condition within the if statement must be a boolean expression. This means it must evaluate to either true or false. Boolean expressions are typically constructed using:

- **Comparison Operators**: == (equal to), != (not equal to), > (greater than), < (less than), >= (greater than or equal to), <= (less than or equal to).
- **Logical Operators**: && (logical AND), || (logical OR), ! (logical NOT).

For example:

```java
int age = 20;
boolean isAdult = age >= 18; // isAdult will be true

if (isAdult) {
    System.out.println("You are an adult.");
}
```

#### <a name="chapter3part2.2"></a>Chapter 3 - Part 2.2: Practical Examples of the if Statement

Let's explore some practical examples to illustrate how the if statement can be used in Java programs.

**Example 1: Checking if a Number is Positive**

This example demonstrates how to use an if statement to check if a number is positive.

```java
int number = 10;

if (number > 0) {
    System.out.println("The number is positive.");
}
```

In this case, the condition number > 0 evaluates to true because number is 10, which is greater than 0. Therefore, the message "The number is positive." is printed to the console.

**Example 2: Determining if a User is Eligible to Vote**

This example builds upon the previous one and incorporates user input.

```java
import java.util.Scanner;

public class VotingEligibility {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print("Enter your age: ");
        int age = input.nextInt();

        if (age >= 18) {
            System.out.println("You are eligible to vote.");
        }
    }
}
```

This program prompts the user to enter their age. It then uses an if statement to check if the age is greater than or equal to 18. If it is, the program prints "You are eligible to vote."

**Example 3: Checking for Even or Odd Numbers**

This example demonstrates the use of the modulo operator (%) to determine if a number is even or odd.

```java
int number = 7;

if (number % 2 == 0) {
    System.out.println("The number is even.");
}
```

In this case, the condition number % 2 == 0 evaluates to false because 7 divided by 2 has a remainder of 1, which is not equal to 0. Therefore, nothing is printed to the console. To handle the case where the number is odd, you would typically use an if-else statement, which will be covered in the next lesson.

**Example 4: Validating User Input**

This example shows how to use an if statement to validate user input and ensure it falls within a specific range.

```java
import java.util.Scanner;

public class InputValidation {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print("Enter a number between 1 and 100: ");
        int number = input.nextInt();

        if (number >= 1 && number <= 100) {
            System.out.println("You entered a valid number: " + number);
        }
    }
}
```

This program prompts the user to enter a number between 1 and 100. It then uses an if statement with a compound condition (number >= 1 && number <= 100) to check if the number is within the valid range. If it is, the program prints a confirmation message.

**Example 5: Simulating a Simple Login**

This example demonstrates how to use an if statement to simulate a simple login process by comparing a user-entered password with a stored password.

```java
import java.util.Scanner;

public class SimpleLogin {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        String storedPassword = "password123"; // In real applications, passwords should be stored securely
        System.out.print("Enter your password: ");
        String enteredPassword = input.nextLine();

        if (enteredPassword.equals(storedPassword)) {
            System.out.println("Login successful!");
        }
    }
}
```

This program prompts the user to enter their password. It then uses the equals() method to compare the entered password with the stored password. If they match, the program prints "Login successful!". Note that in real-world applications, passwords should be stored securely using hashing and salting techniques.

#### <a name="chapter3part3"></a>Chapter 3 - Part 3: The `if-else` Statement: Choosing Between Two Options

The if-else statement is a fundamental control flow structure in Java (and many other programming languages). It allows your program to execute different blocks of code based on whether a specified condition is true or false. This ability to make decisions is crucial for creating programs that can handle different inputs and situations, making them more versatile and useful. Without conditional statements like if-else, programs would simply execute the same sequence of instructions every time, regardless of the data they are processing.

#### <a name="chapter3part3.1"></a>Chapter 3 - Part 3.1: Understanding the if-else Statement

The if-else statement provides a way to execute one block of code if a condition is true and another block of code if the condition is false. The basic syntax is as follows:

```java
if (condition) {
    // Code to execute if the condition is true
} else {
    // Code to execute if the condition is false
}
```

- **```if``` keyword**: This signals the start of the conditional statement.
- **```condition```**: This is a boolean expression (an expression that evaluates to either true or false). The condition is enclosed in parentheses ().
- **```{}``` (curly braces)**: These define the blocks of code that will be executed based on the condition. The code within the first set of curly braces is executed if the condition is true. The code within the second set of curly braces (following the else keyword) is executed if the condition is false.
- **```else``` keyword**: This keyword introduces the block of code that will be executed when the if condition is false.

**How it Works**

- The program evaluates the condition inside the parentheses of the if statement.
- If the condition evaluates to true, the code block immediately following the if statement (the code within the first set of curly braces) is executed. The code block following the else statement is skipped.
- If the condition evaluates to false, the code block immediately following the if statement is skipped. The code block following the else statement (the code within the second set of curly braces) is executed.
- After either the if block or the else block is executed, the program continues with the next statement after the if-else statement.

**Example 1: Checking if a Number is Positive or Negative**

```java
public class IfElseExample {
    public static void main(String[] args) {
        int number = -10;

        if (number > 0) {
            System.out.println("The number is positive.");
        } else {
            System.out.println("The number is not positive.");
        }
    }
}
```

In this example:

- We declare an integer variable number and initialize it to -10.
- The if statement checks if number > 0. Since -10 is not greater than 0, the condition is false.
- Therefore, the code inside the else block is executed, and the output is "The number is not positive."

**Example 2: Determining Even or Odd**

```java
public class EvenOdd {
    public static void main(String[] args) {
        int number = 7;

        if (number % 2 == 0) {
            System.out.println("The number is even.");
        } else {
            System.out.println("The number is odd.");
        }
    }
}
```

In this example:

- We declare an integer variable number and initialize it to 7.
- The if statement checks if number % 2 == 0. The % operator gives the remainder of a division. If the remainder when number is divided by 2 is 0, then the number is even.
- Since 7 % 2 equals 1 (not 0), the condition is false.
- Therefore, the code inside the else block is executed, and the output is "The number is odd."

**Example 3: Comparing Two Numbers**

```java
public class CompareNumbers {
    public static void main(String[] args) {
        int num1 = 25;
        int num2 = 15;

        if (num1 > num2) {
            System.out.println("num1 is greater than num2");
        } else {
            System.out.println("num1 is not greater than num2");
        }
    }
}
```

In this example:

- We declare two integer variables, num1 and num2.
- The if statement checks if num1 > num2. Since 25 is greater than 15, the condition is true.
- Therefore, the code inside the if block is executed, and the output is "num1 is greater than num2".

#### <a name="chapter3part3.2"></a>Chapter 3 - Part 3.2: Omitting Curly Braces

If the code block within the if or else statement consists of only a single statement, you can omit the curly braces. However, it is generally considered good practice to always include the curly braces, even for single-line blocks, as it improves code readability and reduces the risk of errors when modifying the code later.

**Example (Not Recommended)**:

```java
public class NoBraces {
    public static void main(String[] args) {
        int age = 15;

        if (age >= 18)
            System.out.println("You are an adult.");
        else
            System.out.println("You are a minor.");
    }
}
```

While this code is syntactically correct, it's better to write it as:

```java
public class WithBraces {
    public static void main(String[] args) {
        int age = 15;

        if (age >= 18) {
            System.out.println("You are an adult.");
        } else {
            System.out.println("You are a minor.");
        }
    }
}
```

#### <a name="chapter3part3.3"></a>Chapter 3 - Part 3.3: Nested ```if-else``` Statements

You can nest if-else statements inside other if-else statements to create more complex decision-making logic. This means placing an if-else statement within the code block of another if or else statement.

```java
public class NestedIfElse {
    public static void main(String[] args) {
        int num = 10;

        if (num > 0) {
            System.out.println("The number is positive.");
            if (num % 2 == 0) {
                System.out.println("The number is also even.");
            } else {
                System.out.println("The number is odd.");
            }
        } else {
            System.out.println("The number is not positive.");
        }
    }
}
```

In this example:

- The outer if statement checks if num > 0. Since 10 is greater than 0, the condition is true.
- The code inside the outer if block is executed.
- Inside the outer if block, there is another if-else statement (nested if-else). This inner if statement checks if num % 2 == 0. Since 10 % 2 equals 0, the condition is true.
- Therefore, the code inside the inner if block is executed, and the output is "The number is also even."
- If num was not greater than 0, the else block of the outer if-else statement would have been executed.

#### <a name="chapter3part3.4"></a>Chapter 3 - Part 3.4: Short-Hand if-else

Optional structure to ```if-else``` when you want to decide a **VALUE** based on a condition.

**The Short Hand If...Else Statement**

```java

variable = (condition) ? expressionTrue :  expressionFalse;

```

Instead of writing:

```java

int time = 20;
if (time < 18) {
  System.out.println("Good day.");
} else {
  System.out.println("Good evening.");
}

```

You can simply write:

```java

int time = 20;
String result = (time < 18) ? "Good day." : "Good evening.";
System.out.println(result);

```

#### <a name="chapter3part3.5"></a>Chapter 3 - Part 3.5: Common Errors and Pitfalls

- **Using = instead of ==**: A common mistake is to use the assignment operator = instead of the equality operator == in the condition. This will lead to unexpected behavior and potentially a compilation error.

```java
int x = 5;
if (x = 10) { // Incorrect: assignment operator
    System.out.println("x is 10");
}
```

The correct way to write this is:

```java
int x = 5;
if (x == 10) { // Correct: equality operator
    System.out.println("x is 10");
}
```

- **Missing curly braces**: Forgetting to include curly braces for multi-line code blocks can lead to logical errors. Only the first statement after the if or else will be conditionally executed.

- **Incorrectly nested if-else statements**: Ensure that nested if-else statements are properly aligned and that each if has a corresponding else (if needed) to avoid confusion and logical errors.

#### <a name="chapter3part4"></a>Chapter 3 - Part 4: The `if-else if-else` Statement: Handling Multiple Conditions

The if-else if-else statement is a powerful tool in Java for handling multiple conditions. It allows your program to execute different blocks of code based on which condition evaluates to true. This is essential for creating flexible and responsive applications that can adapt to various inputs and scenarios. Understanding how to use this statement effectively is crucial for building more complex and logical programs.

#### <a name="chapter3part4.1"></a>Chapter 3 - Part 4.1: Understanding the if-else if-else Statement

The if-else if-else statement is an extension of the if and if-else statements. It provides a way to check multiple conditions sequentially. The basic structure is as follows:

```java
if (condition1) {
    // Code to execute if condition1 is true
} else if (condition2) {
    // Code to execute if condition1 is false AND condition2 is true
} else if (condition3) {
    // Code to execute if condition1 and condition2 are false AND condition3 is true
} else {
    // Code to execute if all conditions are false
}
```

**Explanation**:

- The if statement evaluates condition1. If it's true, the code block within the first set of curly braces {} is executed, and the rest of the if-else if-else statement is skipped.
- If condition1 is false, the program moves to the first else if statement and evaluates condition2. If condition2 is true, its corresponding code block is executed, and the rest of the statement is skipped.
- This process continues for each else if statement. The program evaluates each condition in order until it finds one that is true.
- If none of the conditions are true, the code block within the else statement is executed. The else block is optional, but it's good practice to include it to handle cases where none of the specified conditions are met.

**Key Principles**:

- **Order Matters**: The order of the conditions is important. The conditions are evaluated from top to bottom, and the first condition that evaluates to true will have its corresponding code block executed.
- **Mutual Exclusivity**: The if-else if-else statement ensures that only one code block is executed. Once a condition is met, the remaining conditions are not evaluated.
- **Optional else Block**: The else block is optional, but it provides a default action to take when none of the if or else if conditions are met.

**Example 1: Grading System**

Let's create a simple grading system based on a student's score:

```java
public class GradingSystem {
    public static void main(String[] args) {
        int score = 85; // Example score
        char grade;

        if (score >= 90) {
            grade = 'A';
        } else if (score >= 80) {
            grade = 'B';
        } else if (score >= 70) {
            grade = 'C';
        } else if (score >= 60) {
            grade = 'D';
        } else {
            grade = 'F';
        }

        System.out.println("Score: " + score);
        System.out.println("Grade: " + grade);
    }
}
```

**Explanation**:

- The code checks the score against different ranges.
- If the score is 90 or above, the grade is set to 'A'.
- If the score is not 90 or above, but it is 80 or above, the grade is set to 'B'.
- This continues until a condition is met, or the else block is reached, setting the grade to 'F' if the score is below 60.

**Example 2: Determining the Sign of a Number**

This example demonstrates how to use if-else if-else to determine if a number is positive, negative, or zero:

```java
public class SignChecker {
    public static void main(String[] args) {
        int number = -5; // Example number

        if (number > 0) {
            System.out.println("The number is positive.");
        } else if (number < 0) {
            System.out.println("The number is negative.");
        } else {
            System.out.println("The number is zero.");
        }
    }
}
```

**Explanation**:

- The code first checks if the number is greater than 0. If it is, it prints "The number is positive."
- If the number is not greater than 0, it checks if it's less than 0. If it is, it prints "The number is negative."
- If neither of the above conditions is true (i.e., the number is not greater than 0 and not less than 0), the else block is executed, and it prints "The number is zero."

**Example 3: Multiple Discount Levels**

Imagine an e-commerce application where different discount levels are applied based on the total purchase amount.

```java
public class DiscountCalculator {
    public static void main(String[] args) {
        double purchaseAmount = 120.0; // Example purchase amount
        double discountRate = 0.0;

        if (purchaseAmount >= 200) {
            discountRate = 0.20; // 20% discount
        } else if (purchaseAmount >= 100) {
            discountRate = 0.10; // 10% discount
        } else if (purchaseAmount >= 50) {
            discountRate = 0.05; // 5% discount
        } else {
            discountRate = 0.0; // No discount
        }

        double discountAmount = purchaseAmount * discountRate;
        double finalAmount = purchaseAmount - discountAmount;

        System.out.println("Purchase Amount: $" + purchaseAmount);
        System.out.println("Discount Rate: " + (discountRate * 100) + "%");
        System.out.println("Discount Amount: $" + discountAmount);
        System.out.println("Final Amount: $" + finalAmount);
    }
}
```

**Explanation**:

- The code checks the purchaseAmount against different thresholds.
- If the amount is $200 or more, a 20% discount is applied.
- If the amount is between $100 and $200, a 10% discount is applied.
- If the amount is between $50 and $100, a 5% discount is applied.
- Otherwise, no discount is applied.

**Example 4: Hypothetical Scenario - Traffic Light Control**

Consider a hypothetical traffic light control system. The system needs to determine the appropriate action based on the current state of the traffic light.

```java
public class TrafficLight {
    public static void main(String[] args) {
        String lightColor = "yellow"; // Example light color

        if (lightColor.equals("green")) {
            System.out.println("Go!");
        } else if (lightColor.equals("yellow")) {
            System.out.println("Caution! Prepare to stop.");
        } else if (lightColor.equals("red")) {
            System.out.println("Stop!");
        } else {
            System.out.println("Invalid light color.");
        }
    }
}
```

**Explanation**:

- The code checks the lightColor against different possible values.
- If the color is "green", it prints "Go!".
- If the color is "yellow", it prints "Caution! Prepare to stop."
- If the color is "red", it prints "Stop!".
- If the color is none of the above, it prints "Invalid light color." This demonstrates the importance of the else block for handling unexpected or invalid inputs.

#### <a name="chapter3part5"></a>Chapter 3 - Part 5: The `switch` Statement: Selecting from Multiple Cases

The switch statement provides a way to execute different blocks of code based on the value of a single variable or expression. It offers a more structured and often more readable alternative to using multiple if-else if-else statements, especially when dealing with a fixed set of possible values. Understanding how to effectively use switch statements is crucial for writing clean, efficient, and maintainable Java code.

#### <a name="chapter3part5.1"></a>Chapter 3 - Part 5.1: Understanding the switch Statement

The switch statement allows you to select one of several code blocks to execute based on the value of an expression. This expression, often a variable, is evaluated once, and its value is compared against a series of case labels. If a case label matches the value of the expression, the code block associated with that case is executed.

**Syntax of the switch Statement**

The basic syntax of the switch statement in Java is as follows:

```java
switch (expression) {
    case value1:
        // Code to be executed if expression == value1;
        break;
    case value2:
        // Code to be executed if expression == value2;
        break;
    case valueN:
        // Code to be executed if expression == valueN;
        break;
    default:
        // Code to be executed if expression does not match any of the cases;
}
```

- **```switch (expression)```**: The expression is evaluated. It must result in a value of type byte, short, char, int, String, or an enum.
- **```case value1:```**: Each case label specifies a value to compare against the expression. The value must be a constant expression of the same type as the expression.
- **```// Code to be executed```**: This is the block of code that will be executed if the expression matches the case's value.
- **```break;```**: The break statement is crucial. It terminates the switch statement and prevents "fall-through" to the next case. If you omit the break statement, execution will continue to the next case, regardless of whether its value matches the expression.
- **```default:```**: The default label is optional. It specifies a block of code to be executed if the expression does not match any of the case labels.

**The Importance of the break Statement**

The break statement is essential for controlling the flow of execution within a switch statement. Without a break statement at the end of each case block, the program will "fall through" and execute the code in the subsequent case blocks, even if their values do not match the expression. This behavior can be useful in certain situations, but it's more commonly a source of errors if not handled intentionally.

**Example without break (Fall-Through)**:

```java
int day = 2;
String dayType;
switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        dayType = "Weekday";
        System.out.println("It's a Weekday");
    case 6:
    case 7:
        dayType = "Weekend";
        System.out.println("It's a Weekend");
    default:
        System.out.println("Invalid day");
}
```

In this example, because there are no break statements, if day is 2, the output will be:

```
It's a Weekday
It's a Weekend
Invalid day
```

**Example with ```break```**:

```java
int day = 2;
String dayType;
switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        dayType = "Weekday";
        System.out.println("It's a Weekday");
        break;
    case 6:
    case 7:
        dayType = "Weekend";
        System.out.println("It's a Weekend");
        break;
    default:
        System.out.println("Invalid day");
}
```

Now, the output will be:

```
It's a Weekday
```

**Using switch with Different Data Types**

The switch statement in Java can be used with several data types:

- ```int```: Integer values.
- ```char```: Character values.
- ```String```: String values (introduced in Java 7).
- ```enum```: Enumerated types.

**Example with String**:

```java
String fruit = "apple";
switch (fruit) {
    case "apple":
        System.out.println("It's an apple.");
        break;
    case "banana":
        System.out.println("It's a banana.");
        break;
    default:
        System.out.println("Unknown fruit.");
}
```

**Example with enum**:

First, define an enum:

```java
enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}
```

Then, use it in a switch statement:

```java
Day today = Day.WEDNESDAY;
switch (today) {
    case MONDAY:
        System.out.println("It's Monday.");
        break;
    case WEDNESDAY:
        System.out.println("It's Wednesday.");
        break;
    default:
        System.out.println("It's some other day.");
}
```

**The default Case**

The default case is an optional part of the switch statement. It provides a block of code to execute when none of the case values match the expression. It's good practice to include a default case, even if you think all possible values are covered by the case labels. This can help catch unexpected or invalid input.

**Example with default**:

```java
int month = 13; // Invalid month
switch (month) {
    case 1:
        System.out.println("January");
        break;
    case 2:
        System.out.println("February");
        break;
    default:
        System.out.println("Invalid month");
}
```

In this example, since month is 13, which doesn't match any of the case values, the default case will be executed, and "Invalid month" will be printed.

#### <a name="chapter3part5.2"></a>Chapter 3 - Part 5.2: Practical Examples and Demonstrations

Let's explore some practical examples to solidify your understanding of the switch statement.

**Example 1: Simple Calculator**

This example demonstrates a simple calculator that performs addition, subtraction, multiplication, or division based on user input.

```java
import java.util.Scanner;

public class Calculator {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter first number: ");
        double num1 = scanner.nextDouble();

        System.out.print("Enter an operator (+, -, *, /): ");
        char operator = scanner.next().charAt(0);

        System.out.print("Enter second number: ");
        double num2 = scanner.nextDouble();

        double result;

        switch (operator) {
            case '+':
                result = num1 + num2;
                break;
            case '-':
                result = num1 - num2;
                break;
            case '*':
                result = num1 * num2;
                break;
            case '/':
                if (num2 == 0) {
                    System.out.println("Cannot divide by zero.");
                    return;
                }
                result = num1 / num2;
                break;
            default:
                System.out.println("Invalid operator.");
                return;
        }

        System.out.println(num1 + " " + operator + " " + num2 + " = " + result);
        scanner.close();
    }
}
```

This code takes two numbers and an operator as input and performs the corresponding calculation using a switch statement. The default case handles invalid operators.

**Example 2: Determining the Number of Days in a Month**

This example uses a switch statement to determine the number of days in a given month.

```java
public class DaysInMonth {
    public static void main(String[] args) {
        int month = 2; // February
        int year = 2024; // Leap year

        int numDays = 0;

        switch (month) {
            case 1: case 3: case 5:
            case 7: case 8: case 10:
            case 12:
                numDays = 31;
                break;
            case 4: case 6:
            case 9: case 11:
                numDays = 30;
                break;
            case 2:
                if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
                    numDays = 29;
                } else {
                    numDays = 28;
                }
                break;
            default:
                System.out.println("Invalid month.");
        }

        if (numDays > 0) {
            System.out.println("Number of days in " + month + " is " + numDays);
        }
    }
}
```

This example demonstrates how to handle multiple case labels that execute the same code block (e.g., months with 31 days). It also includes a check for leap years when determining the number of days in February.

**Example 3: Traffic Light Simulation**

This example simulates a traffic light using an enum and a switch statement.

```java
enum TrafficLightColor {
    RED, YELLOW, GREEN
}

public class TrafficLight {
    public static void main(String[] args) {
        TrafficLightColor color = TrafficLightColor.GREEN;

        switch (color) {
            case RED:
                System.out.println("Stop!");
                break;
            case YELLOW:
                System.out.println("Caution!");
                break;
            case GREEN:
                System.out.println("Go!");
                break;
            default:
                System.out.println("Invalid traffic light color.");
        }
    }
}
```

This example showcases the use of enum types in a switch statement, making the code more readable and maintainable.

#### <a name="chapter3part6"></a>Chapter 3 - Part 6: The `while` Loop: Repeating Code While a Condition is True

The while loop is a fundamental control flow statement in Java that allows you to repeatedly execute a block of code as long as a specified condition remains true. It's a powerful tool for automating repetitive tasks and creating dynamic programs that respond to changing conditions. Understanding how to use while loops effectively is crucial for writing efficient and maintainable Java code.

#### <a name="chapter3part6.1"></a>Chapter 3 - Part 6.1: Understanding the while Loop

The while loop in Java is used to execute a block of code repeatedly as long as a given condition is true. The condition is evaluated before each iteration of the loop. If the condition is initially false, the loop body will not execute at all.

**Syntax of the while Loop**

The basic syntax of a while loop is as follows:

```java
while (condition) {
    // Code to be executed repeatedly
}
```

- ```while``` keyword: This keyword signifies the start of the while loop.
- ```condition```: This is a boolean expression that is evaluated before each iteration of the loop. If the condition is true, the loop body is executed. If the condition is false, the loop terminates, and the program continues with the next statement after the loop.
- ```{}``` (curly braces): These enclose the block of code that will be executed repeatedly. This block is often referred to as the "loop body." If the loop body consists of only one statement, the curly braces are technically optional, but it's considered good practice to always include them for clarity and to avoid potential errors when adding more statements later.

**How the while Loop Works: Step-by-Step**

- **Evaluate the Condition**: The while loop begins by evaluating the boolean expression specified as the condition.
- **Execute the Loop Body (if true)**: If the condition evaluates to true, the code inside the loop's curly braces (the loop body) is executed.
- **Re-evaluate the Condition**: After the loop body has been executed, the condition is evaluated again.
- **Repeat or Terminate**: If the condition is still true, the loop body is executed again. Steps 3 and 4 are repeated until the condition becomes false. When the condition evaluates to false, the loop terminates, and the program continues executing the code that follows the loop.

**Basic Example: Printing Numbers 1 to 5**

```java
public class WhileLoopExample {
    public static void main(String[] args) {
        int i = 1; // Initialize a counter variable

        while (i <= 5) { // Condition: loop as long as i is less than or equal to 5
            System.out.println(i); // Print the value of i
            i++; // Increment i (very important to avoid infinite loops!)
        }

        System.out.println("Loop finished!"); // This will be printed after the loop terminates
    }
}
```

**Explanation**:

- We initialize an integer variable i to 1. This variable acts as our loop counter.
- The while loop's condition is i <= 5. This means the loop will continue to execute as long as the value of i is less than or equal to 5.
- Inside the loop body, we first print the current value of i using System.out.println(i).
- Then, we increment i by 1 using i++. This is crucial because it ensures that the value of i eventually becomes greater than 5, causing the loop to terminate. Without this increment, the loop would run forever (an infinite loop).
- After the loop finishes, the line System.out.println("Loop finished!"); is executed, demonstrating that the program continues after the loop has terminated.

**Avoiding Infinite Loops**

A common mistake when working with while loops is creating an infinite loop. This occurs when the loop's condition never becomes false, causing the loop to execute indefinitely.

**Example of an Infinite Loop**:

```java
public class InfiniteLoopExample {
    public static void main(String[] args) {
        int i = 1;

        while (i <= 5) {
            System.out.println(i);
            // Missing i++ statement!
        }

        System.out.println("This will never be printed!");
    }
}
```

In this example, the i++ statement is missing. As a result, the value of i remains at 1, and the condition i <= 5 is always true. The loop will print the number 1 repeatedly, forever.

**How to Prevent Infinite Loops**:

- **Ensure the loop's condition will eventually become false**: Make sure that the variables involved in the condition are modified within the loop body in a way that will eventually lead to the condition being false.
- **Double-check your logic**: Carefully review your code to ensure that the condition and the loop body are behaving as you intend.
- **Use a debugger**: A debugger can help you step through your code line by line and observe the values of variables, making it easier to identify the cause of an infinite loop.

#### <a name="chapter3part6.2"></a>Chapter 3 - Part 6.2: Using while Loops with User Input

while loops are often used in conjunction with user input to create interactive programs. The loop can continue to execute until the user enters a specific value or performs a certain action.

**Example: Reading Input Until a Specific Value is Entered**

```java
import java.util.Scanner;

public class InputWhileLoop {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // Create a Scanner object to read input

        int number = 0;

        while (number != -1) { // Loop until the user enters -1
            System.out.print("Enter a number (-1 to quit): ");
            number = scanner.nextInt(); // Read the next integer entered by the user

            if (number != -1) {
                System.out.println("You entered: " + number);
            }
        }

        System.out.println("Goodbye!");
        scanner.close(); // Close the scanner to prevent resource leaks
    }
}
```

**Explanation**:

- We import the java.util.Scanner class, which allows us to read input from the console.
- We create a Scanner object named scanner.
- We initialize an integer variable number to 0.
- The while loop's condition is number != -1. This means the loop will continue to execute as long as the value of number is not equal to -1.
- Inside the loop, we prompt the user to enter a number using System.out.print().
- We read the integer entered by the user using scanner.nextInt() and store it in the number variable.
- We use an if statement to check if the entered number is not -1. If it's not, we print the number back to the user.
- When the user enters -1, the loop terminates, and the program prints "Goodbye!".
- Finally, we close the Scanner object using scanner.close() to release system resources. It's good practice to close the scanner when you're finished with it.

**Example: Validating User Input**

```java
import java.util.Scanner;

public class InputValidation {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int age;

        while (true) { // Infinite loop that breaks when valid input is received
            System.out.print("Enter your age (0-120): ");
            age = scanner.nextInt();

            if (age >= 0 && age <= 120) {
                System.out.println("Your age is: " + age);
                break; // Exit the loop if the input is valid
            } else {
                System.out.println("Invalid age. Please enter a value between 0 and 120.");
            }
        }
        scanner.close();
    }
}
```

**Explanation**:

- This example demonstrates how to use a while loop for input validation.
- The while (true) creates an infinite loop.
- Inside the loop, the program prompts the user to enter their age.
- An if statement checks if the entered age is within the valid range (0-120).
- If the age is valid, the program prints the age and uses the break statement to exit the loop.
- If the age is invalid, the program prints an error message and the loop continues, prompting the user to enter their age again.
- The break statement is crucial here. Without it, the loop would continue indefinitely, even after the user enters a valid age.

#### <a name="chapter3part6.3"></a>Chapter 3 - Part 6.3: Using while Loops with Boolean Flags

A boolean flag is a variable of type boolean that is used to control the execution of a loop. The flag is typically initialized to true and then set to false within the loop when a certain condition is met, causing the loop to terminate.

**Example: Searching for a Value in a Range**

```java
public class BooleanFlagExample {
    public static void main(String[] args) {
        int target = 7;
        int start = 1;
        int end = 10;
        boolean found = false; // Initialize the flag to false

        int current = start;
        while (current <= end) {
            System.out.println("Checking: " + current);
            if (current == target) {
                found = true; // Set the flag to true when the target is found
                break; // Exit the loop
            }
            current++;
        }

        if (found) {
            System.out.println("Target " + target + " found!");
        } else {
            System.out.println("Target " + target + " not found in the range.");
        }
    }
}
```

**Explanation**:

- We initialize a boolean variable found to false. This flag will indicate whether or not the target value has been found within the range.
- The while loop continues as long as current is less than or equal to end.
- Inside the loop, we check if the current value is equal to the target value.
- If the current value is equal to the target value, we set the found flag to true and use the break statement to exit the loop.
- After the loop, we check the value of the found flag. If it's true, we print a message indicating that the target was found. Otherwise, we print a message indicating that the target was not found.

#### <a name="chapter3part6.4"></a>Chapter 3 - Part 6.4: Nested while Loops

Just like if statements, while loops can be nested inside other while loops. This allows you to create more complex control flow structures. Nested loops are often used to process two-dimensional data structures, such as arrays (which we will cover in a later module).

**Example: Printing a Multiplication Table**

```java
public class NestedWhileLoop {
    public static void main(String[] args) {
        int i = 1;

        while (i <= 5) { // Outer loop
            int j = 1;
            while (j <= 5) { // Inner loop
                System.out.print(i * j + "\t"); // Print the product of i and j
                j++;
            }
            System.out.println(); // Move to the next line after each row
            i++;
        }
    }
}
```

**Explanation**:

- The outer while loop iterates from 1 to 5 (controlled by the variable i).
- The inner while loop also iterates from 1 to 5 (controlled by the variable j).
- For each iteration of the outer loop, the inner loop executes completely.
- Inside the inner loop, we print the product of i and j, followed by a tab character (\t) to create spacing between the numbers.
- After the inner loop completes, we print a newline character (\n) to move to the next line, creating the rows of the multiplication table.

#### <a name="chapter3part7"></a>Chapter 3 - Part 7: The `do-while` Loop: Ensuring Code Executes at Least Once

The do-while loop is a fundamental control flow statement in Java, offering a crucial variation on the standard while loop. Its key characteristic is that it guarantees the code block within the loop will execute at least once, regardless of whether the condition is initially true or false. This makes it ideal for scenarios where you need to perform an action before evaluating whether to repeat it. Understanding the do-while loop is essential for creating robust and flexible Java programs.

#### <a name="chapter3part7.1"></a>Chapter 3 - Part 7.1: Understanding the do-while Loop

The do-while loop is a post-test loop, meaning the condition is checked after the loop body executes. This contrasts with the while loop, which is a pre-test loop. The general structure of a do-while loop in Java is as follows:

```java
do {
    // Code to be executed
} while (condition);
```

The code within the do block is executed first. After the execution of the code block, the condition is evaluated. If the condition is true, the loop repeats; otherwise, the loop terminates. It's crucial to remember the semicolon (;) at the end of the while (condition) statement; this is a syntax requirement for the do-while loop.

**Key Differences from the while Loop**

The primary difference between the while and do-while loops lies in when the condition is checked.

|Feature|	while Loop|	do-while Loop|
| :-------------: |  :-------------: |  :-------------: |
|Condition Check|	Before executing the loop body	|After executing the loop body|
|Execution|	May not execute if condition is initially false	|Executes at least once|
|Use Case|	When you might not need to execute the loop body at all	|When you need to execute the loop body at least once|

**Anatomy of a do-while Loop**

Let's break down the components of a do-while loop:

- **```do``` Keyword**: This keyword marks the beginning of the loop's code block.
- **Code Block**: This is the set of statements that will be executed repeatedly as long as the condition is true. It's enclosed in curly braces {}.
- **```while``` Keyword**: This keyword, along with the condition in parentheses, determines whether the loop will continue to iterate.
- **Condition**: This is a boolean expression that is evaluated after each execution of the code block. If it evaluates to true, the loop continues. If it evaluates to false, the loop terminates.
- **Semicolon**: The do-while loop requires a semicolon after the closing parenthesis of the while condition. Forgetting this semicolon is a common syntax error.

#### <a name="chapter3part7.2"></a>Chapter 3 - Part 7.2: Practical Examples of do-while Loops

Let's explore some practical examples to illustrate the use of do-while loops.

**Example 1: Simple Counter**

This example demonstrates a basic counter that prints numbers from 1 to 5 using a do-while loop.

```java
public class DoWhileCounter {
    public static void main(String[] args) {
        int i = 1; // Initialize the counter variable

        do {
            System.out.println("Count: " + i); // Print the current count
            i++; // Increment the counter
        } while (i <= 5); // Continue looping as long as i is less than or equal to 5
    }
}
```

In this example, the code inside the do block will execute at least once, printing "Count: 1". Then, the condition i <= 5 is checked. Since i is 1, the condition is true, and the loop continues until i becomes 6.

**Example 2: User Input Validation**

A common use case for do-while loops is validating user input. This example prompts the user to enter a number between 1 and 10 and continues to prompt them until they enter a valid number.

```java
import java.util.Scanner;

public class InputValidation {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int number;

        do {
            System.out.print("Enter a number between 1 and 10: ");
            number = scanner.nextInt();

            if (number < 1 || number > 10) {
                System.out.println("Invalid input. Please enter a number between 1 and 10.");
            }
        } while (number < 1 || number > 10); // Continue looping if the number is outside the valid range

        System.out.println("You entered: " + number);
        scanner.close();
    }
}
```

Here, the loop always prompts the user for input at least once. The condition number < 1 || number > 10 checks if the input is invalid. If it is, the loop repeats, prompting the user again. This ensures that the program receives valid input before proceeding.

**Example 3: A Simple Game**

Let's create a simple number guessing game using a do-while loop. The program will generate a random number, and the user has to guess it. The loop continues until the user guesses the correct number.

```java
import java.util.Random;
import java.util.Scanner;

public class GuessingGame {
    public static void main(String[] args) {
        Random random = new Random();
        int randomNumber = random.nextInt(100) + 1; // Generate a random number between 1 and 100
        Scanner scanner = new Scanner(System.in);
        int guess;
        int attempts = 0;

        System.out.println("Welcome to the Guessing Game!");

        do {
            System.out.print("Enter your guess (1-100): ");
            guess = scanner.nextInt();
            attempts++;

            if (guess < randomNumber) {
                System.out.println("Too low! Try again.");
            } else if (guess > randomNumber) {
                System.out.println("Too high! Try again.");
            } else {
                System.out.println("Congratulations! You guessed the number in " + attempts + " attempts.");
            }
        } while (guess != randomNumber); // Continue looping until the guess matches the random number

        scanner.close();
    }
}
```

In this game, the user is always prompted to make a guess at least once. The loop continues until the user's guess matches the randomNumber. This demonstrates how do-while loops are useful when you need to execute a block of code before checking a condition.

**Example 4: Menu-Driven Program**

do-while loops are frequently used in menu-driven programs where you want to display a menu and process user choices until the user decides to exit.

```java
import java.util.Scanner;

public class MenuProgram {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int choice;

        do {
            System.out.println("Menu:");
            System.out.println("1. Option 1");
            System.out.println("2. Option 2");
            System.out.println("3. Exit");
            System.out.print("Enter your choice: ");
            choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    System.out.println("You selected Option 1.");
                    break;
                case 2:
                    System.out.println("You selected Option 2.");
                    break;
                case 3:
                    System.out.println("Exiting program.");
                    break;
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        } while (choice != 3); // Continue looping until the user chooses to exit (option 3)

        scanner.close();
    }
}
```

The menu is always displayed at least once. The loop continues until the user enters 3 to exit the program. This pattern is common in interactive command-line applications.

#### <a name="chapter3part8"></a>Chapter 3 - Part 8: The `for` Loop: Repeating Code a Specific Number of Times

The for loop is a fundamental control flow statement in Java, allowing you to execute a block of code repeatedly for a specific number of times. It's a powerful tool for automating repetitive tasks and is widely used in various programming scenarios. Understanding the for loop is crucial for writing efficient and concise Java code. This lesson will delve into the syntax, functionality, and practical applications of the for loop, equipping you with the knowledge to effectively utilize it in your programs.

#### <a name="chapter3part8.1"></a>Chapter 3 - Part 8.1: Understanding the for Loop Syntax

The for loop in Java has a specific syntax that you need to understand to use it correctly. The general structure of a for loop is as follows:

```java
for (initialization; condition; increment/decrement) {
    // Code to be executed repeatedly
}
```

Let's break down each part of the for loop:

- **Initialization**: This is the first part of the for loop, and it's executed only once at the beginning of the loop. It's typically used to declare and initialize a counter variable. For example: int i = 0;
- **Condition**: This is a boolean expression that's evaluated before each iteration of the loop. If the condition is true, the code inside the loop's body is executed. If the condition is false, the loop terminates. For example: i < 10;
- **Increment/Decrement**: This part is executed after each iteration of the loop. It's typically used to update the counter variable. For example: i++; or i--;
- **Loop Body**: This is the block of code that's executed repeatedly as long as the condition is true. It's enclosed in curly braces {}.

#### <a name="chapter3part8.2"></a>Chapter 3 - Part 8.2: How the for Loop Works

The for loop works in the following sequence:

- **Initialization**: The initialization statement is executed only once at the beginning of the loop.
- **Condition Check**: The condition is evaluated.
- **Execution**: If the condition is true, the code inside the loop's body is executed.
- **Increment/Decrement**: After the loop body is executed, the increment/decrement statement is executed.
- **Repeat**: Steps 2-4 are repeated until the condition becomes false.
- **Termination**: When the condition becomes false, the loop terminates, and the program continues with the next statement after the loop.

#### <a name="chapter3part8.3"></a>Chapter 3 - Part 8.3: Practical Examples of for Loops

Let's look at some practical examples of how to use for loops in Java.

**Example 1: Printing Numbers from 1 to 10**

This example demonstrates a basic for loop that prints numbers from 1 to 10.

```java
public class ForLoopExample1 {
    public static void main(String[] args) {
        // Initialize i to 1, loop as long as i is less than or equal to 10, increment i by 1 after each iteration
        for (int i = 1; i <= 10; i++) {
            // Print the value of i
            System.out.println(i);
        }
    }
}
```

In this example:

- ```int i = 1;``` initializes the counter variable i to 1.
- ```i <= 10;``` is the condition that checks if i is less than or equal to 10.
- ```i++;``` increments i by 1 after each iteration.
- ```System.out.println(i);``` prints the value of i in each iteration.

**Example 2: Calculating the Sum of Numbers from 1 to 100**

This example demonstrates how to use a for loop to calculate the sum of numbers from 1 to 100.

```java
public class ForLoopExample2 {
    public static void main(String[] args) {
        int sum = 0; // Initialize the sum to 0

        // Initialize i to 1, loop as long as i is less than or equal to 100, increment i by 1 after each iteration
        for (int i = 1; i <= 100; i++) {
            sum += i; // Add the value of i to the sum
        }

        // Print the final sum
        System.out.println("The sum of numbers from 1 to 100 is: " + sum);
    }
}
```

In this example:

- ```int sum = 0;``` initializes a variable sum to 0 to store the sum of the numbers.
- ```for (int i = 1; i <= 100; i++) is the for loop that iterates from 1 to 100.
- ```sum += i; adds the value of i to the sum in each iteration.
- ```System.out.println("The sum of numbers from 1 to 100 is: " + sum);``` prints the final sum after the loop completes.

**Example 3: Iterating Through an Array**

This example demonstrates how to use a for loop to iterate through an array and print its elements. This builds upon the array concepts introduced in Module 4.

```java
public class ForLoopExample3 {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50}; // Declare and initialize an array of integers

        // Loop through the array using the array's length as the loop's condition
        for (int i = 0; i < numbers.length; i++) {
            // Print the element at index i
            System.out.println("Element at index " + i + ": " + numbers[i]);
        }
    }
}
```

In this example:

- ```int[] numbers = {10, 20, 30, 40, 50};``` declares and initializes an array of integers.
- ```for (int i = 0; i < numbers.length; i++)``` is the for loop that iterates through the array. numbers.length gives the number of elements in the array.
- ```System.out.println("Element at index " + i + ": " + numbers[i]);``` prints the element at index i in each iteration.

**Example 4: Nested for Loops**

This example demonstrates how to use nested for loops to create a multiplication table.

```java
public class ForLoopExample4 {
    public static void main(String[] args) {
        // Outer loop iterates from 1 to 5
        for (int i = 1; i <= 5; i++) {
            // Inner loop iterates from 1 to 5
            for (int j = 1; j <= 5; j++) {
                // Print the product of i and j, followed by a tab
                System.out.print(i * j + "\t");
            }
            // Move to the next line after each row
            System.out.println();
        }
    }
}
```

In this example:

- ```The outer for loop iterates from 1 to 5, representing the rows of the multiplication table.
- ```The inner for loop iterates from 1 to 5, representing the columns of the multiplication table.
- ```System.out.print(i * j + "\t");``` prints the product of i and j, followed by a tab to create spacing.
- ```System.out.println();``` moves to the next line after each row is printed.

#### <a name="chapter3part8.4"></a>Chapter 3 - Part 8.4: Variations of the for Loop

While the standard for loop is commonly used, there are some variations that can be useful in specific situations.

**The Enhanced for Loop (for-each loop)**

The enhanced for loop, also known as the "for-each" loop, is a simplified way to iterate through arrays and collections. It was introduced in Java 5 and provides a more concise syntax for iterating through elements without explicitly managing an index.

```java
public class EnhancedForLoopExample {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};

        // Enhanced for loop to iterate through the array
        for (int number : numbers) {
            System.out.println(number);
        }
    }
}
```

In this example:

- ```for (int number : numbers)``` iterates through each element in the numbers array.
- ```int number``` declares a variable number that represents the current element in the array.
- ```System.out.println(number);``` prints the value of the current element.

The enhanced for loop is simpler and easier to read than the traditional for loop when you only need to access the elements of an array or collection sequentially. However, it doesn't provide access to the index of the elements, so it's not suitable for situations where you need to know the index.

**Infinite for Loop**

An infinite for loop is a loop that never terminates because the condition is always true. It can be created by omitting the condition in the for loop's syntax.

```java
public class InfiniteForLoopExample {
    public static void main(String[] args) {
        // Infinite for loop (condition is always true)
        for (;;) {
            System.out.println("This will print forever!");
        }
    }
}
```

In this example, the for loop has no initialization, condition, or increment/decrement statements. This means that the condition is always considered true, and the loop will continue to execute indefinitely.

Infinite loops are generally not desirable in most programs, as they can cause the program to freeze or crash. However, they can be useful in specific situations, such as in server applications that need to run continuously. You can use break statement (covered in the next lesson) to exit an infinite loop based on a certain condition.

#### <a name="chapter3part8.5"></a>Chapter 3 - Part 8.5: Common Mistakes and How to Avoid Them

When working with for loops, there are some common mistakes that beginners often make. Here are some of them and how to avoid them:

- **Off-by-one errors**: These occur when the loop iterates one too many or one too few times. To avoid this, carefully check the loop's condition and make sure it's correct. For example, if you want to iterate through an array of length n, the loop should iterate from 0 to n - 1, not 0 to n.
- **Incorrect initialization**: Initializing the counter variable to the wrong value can lead to unexpected results. Make sure to initialize the counter variable to the correct starting value.
- **Missing increment/decrement**: Forgetting to increment or decrement the counter variable can cause the loop to run indefinitely or not run at all. Make sure to include the increment/decrement statement in the loop's syntax.
- **Incorrect condition**: Using the wrong condition can cause the loop to terminate prematurely or run indefinitely. Carefully check the condition and make sure it accurately reflects the desired behavior.
- **Modifying the counter variable inside the loop**: Modifying the counter variable inside the loop's body can lead to unpredictable behavior and make the loop difficult to understand. Avoid modifying the counter variable inside the loop unless it's absolutely necessary.

#### <a name="chapter3part9"></a>Chapter 3 - Part 9: Using `break` and `continue` Statements

The break and continue statements are powerful tools in Java for controlling the flow of loops. They allow you to alter the normal execution of a loop based on specific conditions, providing flexibility and efficiency in your code. Understanding how to use these statements effectively is crucial for writing clean and optimized loops.

#### <a name="chapter3part9.1"></a>Chapter 3 - Part 9.1: Understanding the break Statement

The break statement is used to terminate a loop prematurely. When a break statement is encountered inside a loop (either a for, while, or do-while loop), the loop's execution is immediately stopped, and the program control transfers to the next statement after the loop.

**Basic Usage of break**

The most straightforward use of break is to exit a loop when a specific condition is met.

```java
public class BreakExample {
    public static void main(String[] args) {
        for (int i = 1; i <= 10; i++) {
            if (i == 5) {
                break; // Exit the loop when i is 5
            }
            System.out.println("i = " + i);
        }
        System.out.println("Loop finished.");
    }
}
```

In this example, the loop is designed to iterate from 1 to 10. However, when i becomes 5, the break statement is executed, causing the loop to terminate immediately. The output will be:

```
i = 1
i = 2
i = 3
i = 4
Loop finished.
```

**break in Nested Loops**

When dealing with nested loops (a loop inside another loop), the break statement only exits the innermost loop in which it is placed.

```java
public class NestedBreakExample {
    public static void main(String[] args) {
        for (int i = 1; i <= 3; i++) {
            System.out.println("Outer loop: i = " + i);
            for (int j = 1; j <= 3; j++) {
                if (j == 2) {
                    break; // Exit the inner loop when j is 2
                }
                System.out.println("  Inner loop: j = " + j);
            }
        }
    }
}
```

In this case, the break statement is inside the inner loop. When j is 2, only the inner loop terminates, and the outer loop continues its execution. The output will be:

```
Outer loop: i = 1
  Inner loop: j = 1
Outer loop: i = 2
  Inner loop: j = 1
Outer loop: i = 3
  Inner loop: j = 1
```

**Labeled break (Advanced)**

Java allows you to use labeled break statements to exit specific outer loops in nested loop scenarios. This is achieved by placing a label before the loop you want to exit and then using break labelName;.

```java
public class LabeledBreakExample {
    public static void main(String[] args) {
        outerLoop: // Label for the outer loop
        for (int i = 1; i <= 3; i++) {
            System.out.println("Outer loop: i = " + i);
            innerLoop:
            for (int j = 1; j <= 3; j++) {
                if (i == 2 && j == 2) {
                    break outerLoop; // Exit the outer loop when i is 2 and j is 2
                }
                System.out.println("  Inner loop: j = " + j);
            }
        }
        System.out.println("Loop finished.");
    }
}
```

Here, outerLoop is a label assigned to the outer loop. When i is 2 and j is 2, the break outerLoop; statement is executed, causing the outer loop to terminate. The output will be:

```
Outer loop: i = 1
  Inner loop: j = 1
  Inner loop: j = 2
  Inner loop: j = 3
Outer loop: i = 2
  Inner loop: j = 1
Loop finished.
```

#### <a name="chapter3part9.2"></a>Chapter 3 - Part 9.2: Understanding the continue Statement

The continue statement is used to skip the rest of the current iteration of a loop and proceed to the next iteration. When a continue statement is encountered, the remaining code within the loop for that iteration is skipped, and the loop proceeds to evaluate the loop's condition for the next iteration.

**Basic Usage of continue**

The primary use of continue is to bypass certain parts of a loop's body based on a condition.

```java
public class ContinueExample {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            if (i == 3) {
                continue; // Skip the rest of the iteration when i is 3
            }
            System.out.println("i = " + i);
        }
        System.out.println("Loop finished.");
    }
}
```

In this example, when i is 3, the continue statement is executed, causing the System.out.println("i = " + i); line to be skipped for that iteration. The output will be:

```
i = 1
i = 2
i = 4
i = 5
Loop finished.
```

**continue in Nested Loops**

Similar to break, when used in nested loops, continue only affects the innermost loop.

```java
public class NestedContinueExample {
    public static void main(String[] args) {
        for (int i = 1; i <= 3; i++) {
            System.out.println("Outer loop: i = " + i);
            for (int j = 1; j <= 3; j++) {
                if (j == 2) {
                    continue; // Skip the rest of the inner loop iteration when j is 2
                }
                System.out.println("  Inner loop: j = " + j);
            }
        }
    }
}
```

In this case, when j is 2, the continue statement skips the rest of the inner loop's iteration, but the outer loop continues its execution. The output will be:

```
Outer loop: i = 1
  Inner loop: j = 1
  Inner loop: j = 3
Outer loop: i = 2
  Inner loop: j = 1
  Inner loop: j = 3
Outer loop: i = 3
  Inner loop: j = 1
  Inner loop: j = 3
```

**Labeled continue (Advanced)**

Like break, continue can also be used with labels to skip to the next iteration of a specific outer loop.

```java
public class LabeledContinueExample {
    public static void main(String[] args) {
        outerLoop: // Label for the outer loop
        for (int i = 1; i <= 3; i++) {
            System.out.println("Outer loop: i = " + i);
            innerLoop:
            for (int j = 1; j <= 3; j++) {
                if (i == 2 && j == 2) {
                    continue outerLoop; // Skip to the next iteration of the outer loop
                }
                System.out.println("  Inner loop: j = " + j);
            }
        }
    }
}
```

Here, when i is 2 and j is 2, the continue outerLoop; statement is executed, causing the program to skip to the next iteration of the outer loop. The output will be:

```
Outer loop: i = 1
  Inner loop: j = 1
  Inner loop: j = 2
  Inner loop: j = 3
Outer loop: i = 2
  Inner loop: j = 1
Outer loop: i = 3
  Inner loop: j = 1
  Inner loop: j = 2
  Inner loop: j = 3
```

#### <a name="chapter3part9.3"></a>Chapter 3 - Part 9.3: Practical Examples and Demonstrations

**Example 1: Finding the First Even Number**

This example demonstrates how to use break to find the first even number in a range.

```java
public class FindFirstEven {
    public static void main(String[] args) {
        for (int i = 1; i <= 10; i++) {
            if (i % 2 == 0) {
                System.out.println("First even number found: " + i);
                break; // Exit the loop after finding the first even number
            }
        }
    }
}
```

**Example 2: Skipping Multiples of 3**

This example demonstrates how to use continue to skip multiples of 3 when printing numbers from 1 to 10.

```java
public class SkipMultiplesOfThree {
    public static void main(String[] args) {
        for (int i = 1; i <= 10; i++) {
            if (i % 3 == 0) {
                continue; // Skip this iteration if i is a multiple of 3
            }
            System.out.println("i = " + i);
        }
    }
}
```

**Example 3: Searching for an Element in an Array**

This example shows how to use break to efficiently search for a specific element in an array.

```java
public class ArraySearch {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int target = 7;
        boolean found = false;

        for (int number : numbers) {
            if (number == target) {
                System.out.println("Target " + target + " found!");
                found = true;
                break; // Exit the loop once the target is found
            }
        }

        if (!found) {
            System.out.println("Target " + target + " not found in the array.");
        }
    }
}
```

## <a name="chapter4"></a>Chapter 4: Working with Arrays and Strings

#### <a name="chapter4part1"></a>Chapter 4 - Part 1: Introduction to Arrays: Storing Collections of Data

Arrays are fundamental data structures in Java, allowing you to store and manage collections of elements of the same type. They provide a way to organize data efficiently and perform operations on multiple values using a single variable name. Understanding arrays is crucial for various programming tasks, from simple data storage to complex algorithms. This lesson will cover the basics of declaring, initializing, accessing, and looping through arrays in Java, laying the groundwork for more advanced data manipulation techniques.

In programming, "vector" is the name given to one-dimensional arrays.

Array is a data Structure:
- Homogeneous (data of the same type)
- Ordered (elements accessed through positions)
- Allocated at once, in a contiguous block of memory

Advantages:
- Immediate access to elements by their position

Disadvantages:
- Fixed Size
- Difficulty performing insertions and deletions

<br>

<div align="center"><img src="img/array1-w592-h173.png" width=592 height=173><br><sub>Fig 22 - Array - (<a href='https://www.geeksforgeeks.org/arrays-in-java/'>Work by geeksforgeeks</a>) </sub></div>

<br>

Arrays are used to store multiple values in a single variable, instead of declaring separate variables for each value.

To declare an array, define the variable type with **square brackets** ```[]```:

```java

String[] cars;

```

We have now declared a variable that holds an array of strings. To insert values to it, you can place the values in a comma-separated list, inside curly braces:

```java

String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};

```

To create an array of integers, you could write:

```java

int[] myNum = {10, 20, 30, 40};

```

**Access the Elements of an Array**

You can access an array element by referring to the index number.

This statement accesses the value of the first element in cars:

```java

String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
System.out.println(cars[0]);
// Outputs Volvo

```

OBS: Array indexes start with 0: [0] is the first element. [1] is the second element, etc.

**Change an Array Element**

To change the value of a specific element, refer to the index number:

```java

cars[0] = "Opel";

```

```java

String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
cars[0] = "Opel";
System.out.println(cars[0]);
// Now outputs Opel instead of Volvo

```

**Array Length**

To find out how many elements an array has, use the ```length``` property:

```java

String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
System.out.println(cars.length);
// Outputs 4

```

Example: Create a program that reads a certain amount of given double numbers and that in the end they are displayed on the screen

```java

import java.util.Locale;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		int N, i;
		
		System.out.print("How many numbers will be enter? ");
		N = sc.nextInt();
		
		double[] vet = new double[N];
		
		for (i = 0; i < N; i++) {
			System.out.print("Enter a number: ");
			vet[i] = sc.nextDouble();
		}
		
		System.out.println("\nTyped Numbers:");
		for (i = 0; i < N; i++) {
			System.out.println(String.format("%.1f", vet[i]));
		}
		
		sc.close();

	}

}

```


#### <a name="chapter4part1.1"></a>Chapter 4 - Part 1.1: Declaring and Initializing Arrays

In Java, arrays are declared with a specific data type and a fixed size. The declaration specifies the type of elements the array will hold, and the size determines the number of elements the array can store.

**Declaring Arrays**

To declare an array, you use the following syntax:

```java
dataType[] arrayName;
```

- ```dataType```: Specifies the type of elements the array will store (e.g., int, double, String).
- ```[]```: Indicates that you are declaring an array.
- ```arrayName```: The name you choose for the array variable.

For example, to declare an array of integers named numbers, you would write:

```java
int[] numbers;
```

This declaration only creates a reference to an array. It does not allocate any memory to store the array elements.

**Initializing Arrays**

After declaring an array, you need to initialize it to allocate memory and assign initial values to its elements. There are several ways to initialize an array in Java.

**Using the ```new``` Keyword

You can initialize an array using the new keyword, specifying the size of the array:

```java
arrayName = new dataType[arraySize];
```

- ```new```: Allocates memory for the array.
- ```dataType```: The type of elements the array will store.
- ```arraySize```: The number of elements the array can hold. This must be a non-negative integer.

For example, to initialize the numbers array to hold 5 integers, you would write:

```java
numbers = new int[5];
```

This creates an array of 5 integers, with each element initialized to the default value for the int type, which is 0.

**Initializing with Values**

You can also initialize an array with specific values during declaration using an array literal:

```java
dataType[] arrayName = {value1, value2, value3, ...};
```

- ```dataType```: The type of elements the array will store.
- ```arrayName```: The name you choose for the array variable.
- ```{value1, value2, value3, ...}```: An array literal containing the initial values for the array elements. The size of the array is determined by the number of values in the literal.

For example, to initialize an array of strings named names with three names, you would write:

```java
String[] names = {"Alice", "Bob", "Charlie"};
```

This creates an array of 3 strings, with the first element initialized to "Alice", the second to "Bob", and the third to "Charlie".

**Combining Declaration and Initialization**

You can combine the declaration and initialization steps into a single statement:

```java
dataType[] arrayName = new dataType[arraySize]; // Declaration and initialization with size
dataType[] arrayName = {value1, value2, value3, ...}; // Declaration and initialization with values
```

For example:

```java
int[] scores = new int[10]; // Declares an integer array named scores with a size of 10
double[] prices = {19.99, 29.99, 39.99}; // Declares a double array named prices with initial values
```

**Examples**

**Example 1: Initializing an array of integers with a specific size**:

```java
int[] ages = new int[4]; // Creates an integer array named ages with a size of 4
System.out.println(ages[0]); // Output: 0 (default value for int)
```

**Example 2: Initializing an array of strings with values**:

```java
String[] colors = {"red", "green", "blue"}; // Creates a string array named colors with initial values
System.out.println(colors[1]); // Output: green
```

**Example 3: Combining declaration and initialization**:

```java
boolean[] flags = {true, false, true, true}; // Creates a boolean array named flags with initial values
System.out.println(flags[2]); // Output: true
```

#### <a name="chapter4part1.2"></a>Chapter 4 - Part 1.2: Accessing Array Elements

Array elements are accessed using their index, which is an integer value that represents the position of the element in the array. Array indices start at 0 and go up to arraySize - 1.

**Using Indices**

To access an array element, you use the following syntax:

```java
arrayName[index]
```

- ```arrayName```: The name of the array.

- ```index```: The index of the element you want to access. This must be a non-negative integer less than the array size.

For example, to access the first element of the numbers array, you would write:

```java
numbers[0]
```

To access the third element, you would write:

```java
numbers[2]
```

**Assigning Values to Array Elements**

You can also assign values to array elements using their index:

```java
arrayName[index] = value;
```

- ```arrayName```: The name of the array.
- ```index```: The index of the element you want to assign a value to.
- ```value```: The value you want to assign to the element. This must be of the same type as the array's data type.

For example, to assign the value 10 to the first element of the numbers array, you would write:

```java
numbers[0] = 10;
```

**ArrayIndexOutOfBoundsException**

It's important to note that accessing an array element with an invalid index (i.e., an index that is less than 0 or greater than or equal to the array size) will result in an ArrayIndexOutOfBoundsException. This is a common error when working with arrays, so it's crucial to ensure that your indices are within the valid range.

**Examples**

**Example 1: Accessing and assigning values to an integer array**:

```java
int[] scores = new int[5]; // Creates an integer array named scores with a size of 5
scores[0] = 85; // Assigns the value 85 to the first element (index 0)
scores[1] = 90; // Assigns the value 90 to the second element (index 1)
System.out.println(scores[0]); // Output: 85
System.out.println(scores[1]); // Output: 90
```

**Example 2: Accessing and assigning values to a string array**:

```java
String[] names = new String[3]; // Creates a string array named names with a size of 3
names[0] = "Alice"; // Assigns the value "Alice" to the first element (index 0)
names[1] = "Bob"; // Assigns the value "Bob" to the second element (index 1)
System.out.println(names[0]); // Output: Alice
System.out.println(names[1]); // Output: Bob
```

**Example 3: Demonstrating ArrayIndexOutOfBoundsException**:

```java
int[] values = new int[3]; // Creates an integer array named values with a size of 3
// values[3] = 10; // This will cause an ArrayIndexOutOfBoundsException because the valid indices are 0, 1, and 2
```

#### <a name="chapter4part1.3"></a>Chapter 4 - Part 1.3: Looping Through Arrays

Looping through arrays is a common task that allows you to process each element in the array. Java provides several ways to loop through arrays, including the for loop and the enhanced for loop (also known as the "for-each" loop).

**Using the for Loop**

The for loop is a traditional way to iterate through an array using an index.

```java
for (int i = 0; i < arrayName.length; i++) {
    // Access array elements using arrayName[i]
}
```

- ```int i = 0```: Initializes a loop counter i to 0.
- ```i < arrayName.length```: Specifies the loop condition. The loop continues as long as i is less than the length of the array. arrayName.length returns the number of elements in the array.
- ```i++```: Increments the loop counter i after each iteration.
- ```arrayName[i]```: Accesses the element at index i in the array.

For example, to print all the elements of the numbers array, you would write:

```java
int[] numbers = {1, 2, 3, 4, 5};
for (int i = 0; i < numbers.length; i++) {
    System.out.println(numbers[i]);
}
```

This code will print each element of the numbers array to the console.

**Using the Enhanced for Loop (For-Each Loop)**

The enhanced for loop provides a more concise way to iterate through an array without using an index.

```java
for (dataType element : arrayName) {
    // Access each element directly using the element variable
}
```

- ```dataType```: The type of elements in the array.
- ```element```: A variable that represents the current element being processed in the loop.
- ```arrayName```: The name of the array.

For example, to print all the elements of the numbers array using the enhanced for loop, you would write:

```java
int[] numbers = {1, 2, 3, 4, 5};
for (int number : numbers) {
    System.out.println(number);
}
```

This code will also print each element of the numbers array to the console. The enhanced for loop is simpler to use when you only need to access the elements of the array and don't need to know their indices.

**Examples**

**Example 1: Using a for loop to calculate the sum of elements in an integer array**:

```java
int[] values = {10, 20, 30, 40, 50};
int sum = 0;
for (int i = 0; i < values.length; i++) {
    sum += values[i];
}
System.out.println("Sum: " + sum); // Output: Sum: 150
```

**Example 2: Using an enhanced for loop to print the elements of a string array**:

```java
String[] fruits = {"apple", "banana", "orange"};
for (String fruit : fruits) {
    System.out.println(fruit);
}
// Output:
// apple
// banana
// orange
```

**Example 3: Using a for loop to modify elements in an array**:

```java
int[] numbers = {1, 2, 3, 4, 5};
for (int i = 0; i < numbers.length; i++) {
    numbers[i] *= 2; // Multiply each element by 2
}
for (int number : numbers) {
    System.out.println(number);
}
// Output:
// 2
// 4
// 6
// 8
// 10
```

#### <a name="chapter4part2"></a>Chapter 4 - Part 2: Declaring and Initializing Arrays

Arrays are fundamental data structures in Java, allowing you to store and manage collections of elements of the same data type. Understanding how to declare and initialize arrays is crucial for efficiently handling data in your programs. This lesson will provide a comprehensive guide to declaring and initializing arrays in Java, covering various methods and best practices.

#### <a name="chapter4part2.1"></a>Chapter 4 - Part 2.1: Declaring Arrays

Declaring an array in Java involves specifying the data type of the elements it will hold and the name of the array variable. This declaration informs the compiler about the type of data the array will store, but it doesn't allocate any memory space for the array elements.

**Syntax for Array Declaration**

The general syntax for declaring an array is:

```java
dataType[] arrayName; // Preferred way
// or
dataType arrayName[]; // Also valid, but less common
```

- ```dataType```: Specifies the type of elements the array will store (e.g., int, String, double, or a custom class).
- ```[]```: Indicates that the variable is an array.
- ```arrayName```: The identifier (name) you choose for the array variable.

**Examples of Array Declarations**

Here are a few examples of declaring arrays of different data types:

```java
int[] numbers;         // Declares an array of integers
double[] prices;       // Declares an array of doubles
String[] names;         // Declares an array of Strings
boolean[] flags;       // Declares an array of booleans
```

In these examples, we've declared array variables named numbers, prices, names, and flags that can hold collections of integers, doubles, Strings, and booleans, respectively. At this point, these arrays do not yet exist in memory. We've only told the compiler that these names will refer to arrays of the specified types.

#### <a name="chapter4part2.2"></a>Chapter 4 - Part 2.2: Initializing Arrays

Initialization is the process of allocating memory space for the array and assigning initial values to its elements. In Java, arrays are objects, and they must be created using the new keyword.

**Initializing Arrays with a Fixed Size**

You can initialize an array by specifying its size, which determines the number of elements it can hold. All elements will be initialized with default values based on their data type (0 for numeric types, false for booleans, and null for object references).

**Syntax for Fixed-Size Initialization**

```java
dataType[] arrayName = new dataType[arraySize];
```

- ```dataType```: The data type of the array elements.
- ```arrayName```: The name of the array variable.
- ```new```: The keyword used to create a new array object.
- ```arraySize```: An integer specifying the number of elements the array can hold.

**Examples of Fixed-Size Initialization**

```java
int[] numbers = new int[5];       // Creates an array of 5 integers, initialized to 0
double[] prices = new double[10];    // Creates an array of 10 doubles, initialized to 0.0
String[] names = new String[3];      // Creates an array of 3 Strings, initialized to null
boolean[] flags = new boolean[8];     // Creates an array of 8 booleans, initialized to false
```

In these examples, we've created arrays of specific sizes. For instance, numbers can hold 5 integers, and each element is initially set to 0. Similarly, names can hold 3 Strings, and each element is initially null because String is an object.

**Initializing Arrays with Initial Values**

You can also initialize an array by directly providing the initial values for its elements. In this case, the size of the array is automatically determined based on the number of values provided.

**Syntax for Initialization with Values**

```java
dataType[] arrayName = {value1, value2, value3, ...};
```

- ```dataType```: The data type of the array elements.
- ```arrayName```: The name of the array variable.
- ```{}```: Curly braces enclose the initial values.
- ```value1, value2, value3, ...```: The initial values for the array elements, separated by commas.

**Examples of Initialization with Values**

```java
int[] numbers = {1, 2, 3, 4, 5};             // Creates an array of 5 integers with the specified values
double[] prices = {9.99, 19.99, 29.99};       // Creates an array of 3 doubles with the specified values
String[] names = {"Alice", "Bob", "Charlie"};  // Creates an array of 3 Strings with the specified values
boolean[] flags = {true, false, true};        // Creates an array of 3 booleans with the specified values
```

In these examples, the arrays are initialized with specific values. The size of each array is determined by the number of values provided within the curly braces. For example, numbers is an array of size 5, with elements initialized to 1, 2, 3, 4, and 5, respectively.

**Combining Declaration and Initialization**

You can combine the declaration and initialization steps into a single statement:

```java
int[] numbers = new int[5]; // Declaration and fixed-size initialization
int[] values = {10, 20, 30}; // Declaration and initialization with values
```

This approach is concise and often preferred for its readability.

#### <a name="chapter4part2.3"></a>Chapter 4 - Part 2.3: Accessing Array Elements

Array elements are accessed using their index, which is an integer representing the element's position in the array. Array indices start at 0 and go up to arraySize - 1.

**Syntax for Accessing Elements**

```java
arrayName[index]
```

- ```arrayName```: The name of the array.
- ```index```: An integer representing the position of the element you want to access.

**Examples of Accessing Elements**

```java
int[] numbers = {10, 20, 30, 40, 50};

System.out.println(numbers[0]); // Accesses the first element (10)
System.out.println(numbers[2]); // Accesses the third element (30)

numbers[1] = 25; // Modifies the second element to 25
System.out.println(numbers[1]); // Accesses the modified second element (25)
```

In this example, we access and modify elements of the numbers array using their indices. It's important to note that attempting to access an element with an index outside the valid range (0 to arraySize - 1) will result in an ArrayIndexOutOfBoundsException.

#### <a name="chapter4part2.4"></a>Chapter 4 - Part 2.4: Looping Through Arrays

Looping through arrays is a common operation used to process each element in the array. The for loop is particularly well-suited for this purpose. We will cover looping in more detail in the next lesson.

**Example of Looping Through an Array**

```java
int[] numbers = {1, 2, 3, 4, 5};

for (int i = 0; i < numbers.length; i++) {
    System.out.println("Element at index " + i + ": " + numbers[i]);
}
```

In this example, the for loop iterates through each element of the numbers array, printing the index and value of each element. The numbers.length property provides the size of the array, ensuring that the loop iterates through all valid indices.

#### <a name="chapter4part3"></a>Chapter 4 - Part 3: Accessing Array Elements

Arrays are fundamental data structures in Java, allowing you to store and manage collections of elements of the same data type. Accessing these elements is a core operation, enabling you to retrieve, modify, and manipulate the data stored within the array. Understanding how to correctly access array elements is crucial for effectively utilizing arrays in your Java programs. This lesson will cover the different ways to access array elements, potential pitfalls like ArrayIndexOutOfBoundsException, and best practices for working with array indices.

#### <a name="chapter4part3.1"></a>Chapter 4 - Part 3.1: Accessing Array Elements Using Indices

Arrays in Java are zero-indexed, meaning the first element in the array is located at index 0, the second element at index 1, and so on. To access a specific element, you use the array's name followed by the index of the element enclosed in square brackets [].

**Basic Access**

Let's consider an array of integers:

```java
int[] numbers = {10, 20, 30, 40, 50};

// Accessing the first element (index 0)
int firstElement = numbers[0];
System.out.println("First element: " + firstElement); // Output: First element: 10

// Accessing the third element (index 2)
int thirdElement = numbers[2];
System.out.println("Third element: " + thirdElement); // Output: Third element: 30

// Accessing the last element (index 4)
int lastElement = numbers[4];
System.out.println("Last element: " + lastElement); // Output: Last element: 50
```

In this example, numbers[0] accesses the element at index 0, which is 10. Similarly, numbers[2] accesses the element at index 2, which is 30, and numbers[4] accesses the element at index 4, which is 50.

**Modifying Array Elements**

You can also modify the value of an array element using its index:

```java
int[] numbers = {10, 20, 30, 40, 50};

// Modifying the second element (index 1)
numbers[1] = 25;
System.out.println("Second element after modification: " + numbers[1]); // Output: Second element after modification: 25

// Modifying the last element (index 4)
numbers[4] = 55;
System.out.println("Last element after modification: " + numbers[4]); // Output: Last element after modification: 55
```

Here, numbers[1] = 25 changes the value of the element at index 1 from 20 to 25. Likewise, numbers[4] = 55 changes the value of the element at index 4 from 50 to 55.

**Accessing Array Elements in a Loop**

A common task is to iterate through an array and access each element. This is typically done using a for loop. This prepares us for the next lesson on looping through arrays.

```java
int[] numbers = {10, 20, 30, 40, 50};

// Accessing each element using a for loop
for (int i = 0; i < numbers.length; i++) {
    System.out.println("Element at index " + i + ": " + numbers[i]);
}
```

In this code, numbers.length returns the number of elements in the array. The loop iterates from i = 0 to i < numbers.length, accessing each element numbers[i] in turn.

**Example with Strings**

Arrays aren't limited to just numbers. Here's an example using an array of strings:

```java
String[] names = {"Alice", "Bob", "Charlie"};

// Accessing the first name
String firstName = names[0];
System.out.println("First name: " + firstName); // Output: First name: Alice

// Accessing the last name
String lastName = names[2];
System.out.println("Last name: " + lastName); // Output: Last name: Charlie

// Modifying the second name
names[1] = "Robert";
System.out.println("Second name after modification: " + names[1]); // Output: Second name after modification: Robert
```

This example demonstrates accessing and modifying elements within a string array.

#### <a name="chapter4part3.2"></a>Chapter 4 - Part 3.2: ArrayIndexOutOfBoundsException

A common error when working with arrays is the ArrayIndexOutOfBoundsException. This exception occurs when you try to access an array element using an index that is outside the valid range of indices (i.e., less than 0 or greater than or equal to the array's length).

**Understanding the Exception**

Consider the following code:

```java
int[] numbers = {10, 20, 30};

// Attempting to access an element at an invalid index
try {
    int element = numbers[3]; // This will cause an ArrayIndexOutOfBoundsException
    System.out.println("Element: " + element); // This line will not be executed
} catch (ArrayIndexOutOfBoundsException e) {
    System.out.println("Error: ArrayIndexOutOfBoundsException caught!");
}
```

**Avoiding the Exception**

To avoid ArrayIndexOutOfBoundsException, always ensure that the index you are using to access an array element is within the valid range. Before accessing an element, you can check if the index is valid:

```java
int[] numbers = {10, 20, 30};
int index = 3;

if (index >= 0 && index < numbers.length) {
    int element = numbers[index];
    System.out.println("Element at index " + index + ": " + element);
} else {
    System.out.println("Error: Index is out of bounds!");
}
```

In this example, the code checks if the index is within the valid range (0 to numbers.length - 1) before attempting to access the array element. If the index is out of bounds, an error message is printed.

#### <a name="chapter4part3.3"></a>Chapter 4 - Part 3.3: Practical Examples and Demonstrations

**Example 1: Calculating the Sum of Array Elements**

```java
int[] scores = {85, 90, 78, 92, 88};
int sum = 0;

// Calculating the sum of all elements in the array
for (int i = 0; i < scores.length; i++) {
    sum += scores[i];
}

System.out.println("Sum of scores: " + sum); // Output: Sum of scores: 433
```

This example demonstrates how to use a loop to access each element in an array and calculate the sum of all elements.

**Example 2: Finding the Maximum Value in an Array**

```java
int[] values = {45, 23, 89, 12, 56};
int max = values[0]; // Assume the first element is the maximum

// Finding the maximum value in the array
for (int i = 1; i < values.length; i++) {
    if (values[i] > max) {
        max = values[i];
    }
}

System.out.println("Maximum value: " + max); // Output: Maximum value: 89
```

This example shows how to iterate through an array and find the maximum value. It initializes max with the first element and then compares each subsequent element to max, updating max if a larger value is found.

**Example 3: Reversing an Array**

```java
int[] original = {1, 2, 3, 4, 5};
int[] reversed = new int[original.length];

// Reversing the array
for (int i = 0; i < original.length; i++) {
    reversed[original.length - 1 - i] = original[i];
}

// Printing the reversed array
System.out.print("Reversed array: ");
for (int i = 0; i < reversed.length; i++) {
    System.out.print(reversed[i] + " ");
}
// Output: Reversed array: 5 4 3 2 1
```

This example demonstrates how to reverse an array by creating a new array and copying the elements from the original array in reverse order.

#### <a name="chapter4part4"></a>Chapter 4 - Part 4: Looping Through Arrays

Looping through arrays is a fundamental skill in Java programming. It allows you to access and manipulate each element within an array efficiently. This lesson will cover the different types of loops available in Java and how to use them effectively with arrays. Understanding how to iterate through arrays is crucial for performing various operations, such as searching, sorting, and modifying array elements.

#### <a name="chapter4part4.1"></a>Chapter 4 - Part 4.1: Understanding the Need for Loops

Arrays store collections of data of the same type. To work with the data stored in an array, you often need to access each element individually. Loops provide a way to automate this process, allowing you to execute a block of code repeatedly for each element in the array. Without loops, you would have to write separate lines of code to access each element, which is inefficient and impractical for large arrays.

Consider these scenarios:

- **Scenario 1**: Calculating the sum of elements in an array. You need to add up all the numbers stored in an array. A loop allows you to iterate through each element, adding it to a running total.
- **Scenario 2**: Searching for a specific value in an array. You want to find out if a particular value exists in an array. A loop allows you to check each element until you find the value or reach the end of the array.
- **Scenario 3**: Modifying elements in an array. You want to update the values of certain elements in an array based on a specific condition. A loop allows you to apply the condition to each element and modify it accordingly.

#### <a name="chapter4part4.2"></a>Chapter 4 - Part 4.2: Types of Loops in Java

Java provides several types of loops that can be used to iterate through arrays:

- ```for``` loop
- ```while``` loop
- ```do-while``` loop
- Enhanced ```for``` loop (also known as the "for-each" loop)
- Using Streams and Lambda Expressions to Loop Through Arrays

Each loop type has its own syntax and use cases. The for loop and enhanced for loop are the most commonly used for iterating through arrays because they provide a concise and readable way to access each element.

#### <a name="chapter4part4.3"></a>Chapter 4 - Part 4.3: The for Loop

The for loop is a powerful and versatile loop that is often used to iterate through arrays when you know the number of iterations in advance.

**Syntax of the for Loop**

```java
for (initialization; condition; increment/decrement) {
    // Code to be executed
}
```

- **Initialization**: This part is executed only once at the beginning of the loop. It typically involves declaring and initializing a counter variable.
- **Condition**: This is a boolean expression that is evaluated before each iteration of the loop. If the condition is true, the loop continues to execute. If the condition is false, the loop terminates.
- **Increment/Decrement**: This part is executed after each iteration of the loop. It typically involves incrementing or decrementing the counter variable.

**Using the for Loop with Arrays**

To use the for loop with arrays, you typically use the counter variable as an index to access each element of the array.

```java
public class ForLoopArray {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};

        // Iterate through the array using a for loop
        for (int i = 0; i < numbers.length; i++) {
            System.out.println("Element at index " + i + ": " + numbers[i]);
        }
    }
}
```

In this example:

- ```int i = 0;``` initializes the counter variable i to 0. This is the index of the first element in the array.
- ```i < numbers.length;``` is the condition that checks if the counter variable i is less than the length of the array. The length property of an array returns the number of elements in the array.
- ```i++;``` increments the counter variable i by 1 after each iteration. This moves to the next element in the array.
- ```System.out.println("Element at index " + i + ": " + numbers[i]);``` prints the value of the element at the current index i.

**Example: Calculating the Sum of Array Elements**

```java
public class SumArray {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};
        int sum = 0;

        // Calculate the sum of the elements in the array
        for (int i = 0; i < numbers.length; i++) {
            sum += numbers[i]; // sum = sum + numbers[i];
        }

        System.out.println("Sum of array elements: " + sum);
    }
}
```

In this example, the for loop iterates through each element of the numbers array, adding it to the sum variable. After the loop finishes, the sum variable contains the total sum of all the elements in the array.

**Example: Modifying Array Elements**

```java
public class ModifyArray {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};

        // Multiply each element in the array by 2
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = numbers[i] * 2;
        }

        // Print the modified array
        System.out.println("Modified array:");
        for (int i = 0; i < numbers.length; i++) {
            System.out.println(numbers[i]);
        }
    }
}
```

In this example, the for loop iterates through each element of the numbers array, multiplying it by 2 and updating the element's value. After the loop finishes, all the elements in the array have been modified.

#### <a name="chapter4part4.4"></a>Chapter 4 - Part 4.4: The Enhanced for Loop (For-Each Loop)

The enhanced for loop, also known as the "for-each" loop, provides a simpler and more concise way to iterate through arrays. It automatically iterates through each element of the array without requiring you to manage the index.

**Syntax of the Enhanced for Loop**

```java
for (dataType element : arrayName) {
    // Code to be executed
}
```

- **dataType**: The data type of the elements in the array.
- **element**: A variable that represents the current element being processed in the loop.
- **arrayName**: The name of the array you want to iterate through.

**Using the Enhanced for Loop with Arrays**

```java
public class EnhancedForLoopArray {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};

        // Iterate through the array using an enhanced for loop
        for (int number : numbers) {
            System.out.println("Element: " + number);
        }
    }
}
```

In this example:

- ```int number : numbers``` declares a variable number of type int that will hold the value of each element in the numbers array during each iteration of the loop.
- The loop automatically iterates through each element of the numbers array, assigning the value of the current element to the number variable.
- ```System.out.println("Element: " + number);``` prints the value of the current element.

**Example: Calculating the Sum of Array Elements (Enhanced for Loop)**

```java
public class SumArrayEnhanced {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};
        int sum = 0;

        // Calculate the sum of the elements in the array using an enhanced for loop
        for (int number : numbers) {
            sum += number;
        }

        System.out.println("Sum of array elements: " + sum);
    }
}
```

This example demonstrates how to calculate the sum of array elements using the enhanced for loop. The code is more concise and easier to read compared to using a traditional for loop.

**When to Use the Enhanced for Loop**

The enhanced for loop is ideal when you need to access each element of an array sequentially and you don't need to know the index of the element. It simplifies the code and makes it more readable.

However, the enhanced for loop has some limitations:

- You cannot modify the array elements directly within the loop. Any changes made to the element variable will not affect the original array.
- You cannot access the index of the current element.
- You cannot iterate through the array in reverse order.

If you need to perform any of these operations, you should use a traditional for loop instead.

#### <a name="chapter4part4.5"></a>Chapter 4 - Part 4.5: The while Loop

The while loop is another type of loop that can be used to iterate through arrays. It continues to execute a block of code as long as a specified condition is true.

**Syntax of the while Loop**

```java
while (condition) {
    // Code to be executed
}
```

- **Condition**: This is a boolean expression that is evaluated before each iteration of the loop. If the condition is true, the loop continues to execute. If the condition is false, the loop terminates.

**Using the while Loop with Arrays**

To use the while loop with arrays, you need to manually manage the index of the array.

```java
public class WhileLoopArray {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};
        int i = 0; // Initialize the index

        // Iterate through the array using a while loop
        while (i < numbers.length) {
            System.out.println("Element at index " + i + ": " + numbers[i]);
            i++; // Increment the index
        }
    }
}
```

In this example:

- ```int i = 0;``` initializes the index variable i to 0.
- ```while (i < numbers.length)``` is the condition that checks if the index i is less than the length of the array.
- ```System.out.println("Element at index " + i + ": " + numbers[i]);``` prints the value of the element at the current index i.
- ```i++;``` increments the index i by 1 after each iteration.

**Example: Searching for a Specific Value in an Array (While Loop)**

```java
public class SearchArrayWhile {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};
        int target = 30;
        int i = 0;
        boolean found = false;

        // Search for the target value in the array using a while loop
        while (i < numbers.length) {
            if (numbers[i] == target) {
                found = true;
                break; // Exit the loop if the target is found
            }
            i++;
        }

        if (found) {
            System.out.println("Target " + target + " found in the array.");
        } else {
            System.out.println("Target " + target + " not found in the array.");
        }
    }
}
```

In this example, the while loop iterates through the numbers array until the target value is found or the end of the array is reached. The break statement is used to exit the loop when the target is found.

**When to Use the while Loop**

The while loop is useful when you don't know the number of iterations in advance, and the loop should continue as long as a certain condition is true. In the context of arrays, it's less commonly used than the for loop or enhanced for loop, especially when you need to iterate through all elements sequentially. However, it can be useful for scenarios like searching or processing elements until a specific condition is met.

#### <a name="chapter4part4.6"></a>Chapter 4 - Part 4.6: The do-while Loop

The do-while loop is similar to the while loop, but it guarantees that the code block is executed at least once, even if the condition is initially false.

**Syntax of the do-while Loop**

```java
do {
    // Code to be executed
} while (condition);
```

- **Condition**: This is a boolean expression that is evaluated after each iteration of the loop. If the condition is true, the loop continues to execute. If the condition is false, the loop terminates.

**Using the do-while Loop with Arrays**

```java
public class DoWhileLoopArray {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};
        int i = 0;

        // Iterate through the array using a do-while loop
        do {
            System.out.println("Element at index " + i + ": " + numbers[i]);
            i++;
        } while (i < numbers.length);
    }
}
```

In this example, the code block inside the do block is executed at least once, even if the condition i < numbers.length is initially false (which it isn't in this case).

**When to Use the do-while Loop**

The do-while loop is useful when you want to ensure that a block of code is executed at least once, regardless of the initial condition. In the context of arrays, this is less common than using a for or while loop. A potential use case might be when you need to process the first element of an array before deciding whether to continue iterating through the rest of the array. However, in most array processing scenarios, a for or while loop is more appropriate.

#### <a name="chapter4part4.7"></a>Chapter 4 - Part 4.7: Using Streams and Lambda Expressions to Loop Through Arrays

This is a feature that became more prominent with the introduction of Streams in Java 8.

- **1**: Convert Array to Stream
  - First, you need to convert your array into a Stream. Java provides convenient ways to do this using the java.util.Arrays class.
 
- **2**: Use forEach with a Lambda
  - The Stream interface has a forEach method that accepts a Consumer functional interface. A lambda expression can be used to implement the Consumer, allowing you to define the action to perform on each element of the stream (and thus, each element of the array).
 
Here's a breakdown with an example:

```java
import java.util.Arrays;

public class ArrayLooping {

    public static void main(String[] args) {
        String[] names = {"Alice", "Bob", "Charlie", "David"};

        // Using streams and lambda to print each name
        Arrays.stream(names).forEach(name -> System.out.println("Hello, " + name + "!"));

        //Another example with integers
        int[] numbers = {1, 2, 3, 4, 5};
        Arrays.stream(numbers).forEach(number -> System.out.println("Number: " + number));

        // Using a method reference (a shorthand for a lambda in some cases)
        Arrays.stream(names).forEach(System.out::println);
    }
}
```

- ```Arrays.stream(names)```: This converts the names array into a Stream<String>. For primitive type arrays (like int[]), there are specialized streams like IntStream, LongStream, and DoubleStream that you should use (e.g., Arrays.stream(numbers) returns an IntStream).
- ```.forEach(name -> System.out.println("Hello, " + name + "!"))```: This is the core of the lambda expression.
  - ```forEach``` is a terminal operation on the stream, meaning it triggers the processing of the stream.
  - ```name -> System.out.println("Hello, " + name + "!")``` is a lambda expression. It takes each element from the stream (which represents an element from the array) and assigns it to the variable name. Then, it executes the code on the right side of the ->, which in this case prints a greeting to the console.
- ```System.out::println```: This is a method reference. It's equivalent to the lambda name -> System.out.println(name). It's a more concise way to write the lambda when you're simply calling a method on the element.

**Advantages of Using Streams and Lambdas for Looping:**

- **Conciseness**: The code is often more compact and readable than traditional for loops, especially for simple operations.

- **Functional Style**: It encourages a more functional programming style, which can lead to more maintainable and testable code.

- **Parallelism (Potential)**: Streams can be easily processed in parallel, which can significantly improve performance for large arrays and computationally intensive operations (though you need to be careful about thread safety).

**Important Considerations:**

- **Not a Replacement for All Loops**: While streams and lambdas are powerful, they are not always the best choice. For very simple loops where you just need to iterate through the array once, a traditional for loop might be more straightforward. Also, if you need to modify the original array in place during the loop, streams are generally not the right tool. Streams are designed for creating new collections or performing actions on elements, not for directly mutating the source array.

- **Primitive Type Streams**: Remember to use IntStream, LongStream, and DoubleStream when working with arrays of primitive types (int, long, double) to avoid boxing/unboxing overhead.

- **Terminal Operations**: forEach is a terminal operation. Once you call a terminal operation on a stream, you can't reuse that stream. If you need to perform multiple operations on the same data, you'll need to create a new stream.

#### <a name="chapter4part5"></a>Chapter 4 - Part 5: Multidimensional Arrays

Multidimensional arrays extend the concept of single-dimensional arrays by allowing you to store data in a grid-like structure, similar to a table with rows and columns. This is incredibly useful for representing data that has inherent two-dimensional or higher-dimensional relationships, such as game boards, image pixels, or spreadsheet data. Understanding how to declare, initialize, access, and manipulate multidimensional arrays is a fundamental skill for any Java programmer.

A multidimensional array is an array of arrays.

In programming, "Matriz" is the name given to two-dimensional arrays.
obs: array is an array of arrays.

Array is a data Structure:
- Homogeneous (data of the same type)
- Ordered (elements accessed through positions)
- Allocated at once, in a contiguous block of memory

Advantages:
- Immediate access to elements by their position

Disadvantages:
- Fixed Size
- Difficulty performing insertions and deletions

To create a two-dimensional array, add each array within its own set of **curly braces** ```[][]```:

<br>

<div align="center"><img src="img/array2-w740-h282.png" width=740 height=282><br><sub>Fig 23 - Multidimensional Array - (<a href='https://www.geeksforgeeks.org/multidimensional-arrays-in-java/?ref=lbp'>Work by geeksforgeeks</a>) </sub></div>

<br>

```java

int[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };

```

**myNumbers** is now an array with two arrays as its elements.

To access the elements of the **myNumbers** array, specify two indexes: one for the array, and one for the element inside that array. This example accesses the third element (2) in the second array (1) of myNumbers:

```java

int[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };
int x = myNumbers[1][2];
System.out.println(x); // Outputs 7

```

We can also use a ```for loop``` inside another ```for loop``` to get the elements of a two-dimensional array (we still have to point to the two indexes):

```java

public class Main {
  public static void main(String[] args) {
    int[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };
    for (int i = 0; i < myNumbers.length; ++i) {
      for(int j = 0; j < myNumbers[i].length; ++j) {
        System.out.println(myNumbers[i][j]);
      }
    }
  }
}

```

Example: Create a Matrix

```java

import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		
		int M, N, i, j;
		
		System.out.print("How many rows the matrix will be? ");
		M = sc.nextInt();
		System.out.print("How many columns the matrix will be? ");
		N = sc.nextInt();
		
		int[][] mat = new int[M][N];
		
		for (i = 0; i < M; i++) {
			for (j = 0; j < N; j++) {
				System.out.print("Element [" + i + "," + j + "]: ");
				mat[i][j] = sc.nextInt();
			}
		}
		
		System.out.println("\nTyped Matrix:");
		for (i = 0; i < M; i++) {
			for (j = 0; j < N; j++) {
				System.out.print(mat[i][j] + " ");	
			}
			System.out.println();
		}
		
		sc.close();
	}

}

```

#### <a name="chapter4part5.1"></a>Chapter 4 - Part 5.1: Understanding Multidimensional Arrays

A multidimensional array is essentially an array of arrays. The most common type is a two-dimensional array, which can be visualized as a table with rows and columns. You can also have arrays with three or more dimensions, although they are less frequently used.

**Declaring Multidimensional Arrays**

To declare a two-dimensional array, you use the following syntax:

```
dataType[][] arrayName;
```

For example, to declare a two-dimensional array of integers named matrix, you would write:

```java
int[][] matrix;
```

This declaration only creates a reference to an array. To actually create the array, you need to allocate memory for it.

**Initializing Multidimensional Arrays**

There are several ways to initialize a multidimensional array:

- **Using new keyword**: You can specify the number of rows and columns when creating the array:

```java
int[][] matrix = new int[3][4]; // Creates a 3x4 matrix (3 rows, 4 columns)
```

This creates a matrix where all elements are initialized to the default value for the int data type, which is 0.

- **Using an initializer list**: You can directly provide the values for the array elements:

```java
int[][] matrix = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};
```

This creates a 3x4 matrix with the specified values. Each inner set of curly braces represents a row in the matrix.

- **Combining declaration and initialization**:

```java
int[][] matrix;
matrix = new int[][] {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};
```

This is equivalent to the previous method but separates the declaration and initialization steps.

**Accessing Array Elements**

To access an element in a two-dimensional array, you use two indices: the row index and the column index. Array indices start at 0.

```java
int[][] matrix = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

int element = matrix[1][2]; // Accesses the element at row 1, column 2 (value is 7)
System.out.println(element); // Output: 7

matrix[0][0] = 100; // Modifies the element at row 0, column 0
System.out.println(matrix[0][0]); // Output: 100
```

**Looping Through Multidimensional Arrays**

You typically use nested loops to iterate through all the elements of a multidimensional array. The outer loop iterates through the rows, and the inner loop iterates through the columns.

```java
int[][] matrix = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

for (int i = 0; i < matrix.length; i++) { // Iterate through rows
    for (int j = 0; j < matrix[i].length; j++) { // Iterate through columns in the current row
        System.out.print(matrix[i][j] + " ");
    }
    System.out.println(); // Move to the next line after printing each row
}
```

This code will print the following output:

```
1 2 3 4
5 6 7 8
9 10 11 12
```

**Example: Game Board**

Consider a simple game board represented by a 2D array:

```java
char[][] board = new char[3][3]; // Creates a 3x3 board

// Initialize the board with empty spaces
for (int i = 0; i < board.length; i++) {
    for (int j = 0; j < board[i].length; j++) {
        board[i][j] = ' ';
    }
}

// Place an 'X' on the board
board[1][1] = 'X';

// Print the board
for (int i = 0; i < board.length; i++) {
    for (int j = 0; j < board[i].length; j++) {
        System.out.print(board[i][j] + " | ");
    }
    System.out.println();
    if (i < board.length - 1) {
        System.out.println("---------");
    }
}
```

This code will output:

```
  |   |   |
---------
  | X |   |
---------
  |   |   |
```

**Ragged Arrays**

In Java, you can create "ragged" or "jagged" arrays, where each row can have a different number of columns. This is achieved by creating an array of arrays where the inner arrays have different lengths.

```java
int[][] raggedArray = new int[3][]; // Creates an array with 3 rows, but no columns are defined yet

raggedArray[0] = new int[4]; // Row 0 has 4 columns
raggedArray[1] = new int[2]; // Row 1 has 2 columns
raggedArray[2] = new int[5]; // Row 2 has 5 columns

// Initialize the ragged array
for (int i = 0; i < raggedArray.length; i++) {
    for (int j = 0; j < raggedArray[i].length; j++) {
        raggedArray[i][j] = i * 10 + j;
    }
}

// Print the ragged array
for (int i = 0; i < raggedArray.length; i++) {
    for (int j = 0; j < raggedArray[i].length; j++) {
        System.out.print(raggedArray[i][j] + " ");
    }
    System.out.println();
}
```

This code will output:

```
0 1 2 3
10 11
20 21 22 23 24
```

**Three-Dimensional Arrays (and Beyond)**

While less common, Java supports arrays with three or more dimensions. A three-dimensional array can be thought of as a cube of data.

```java
int[][][] cube = new int[3][3][3];

// Initialize the cube
for (int i = 0; i < cube.length; i++) {
    for (int j = 0; j < cube[i].length; j++) {
        for (int k = 0; k < cube[i][j].length; k++) {
            cube[i][j][k] = i * 100 + j * 10 + k;
        }
    }
}

// Access an element
System.out.println(cube[1][2][0]); // Output: 120
```

The same principles apply to arrays with higher dimensions: you declare them with additional square brackets, initialize them using nested loops or initializer lists, and access elements using multiple indices.

#### <a name="chapter4part5.2"></a>Chapter 4 - Part 5.2: Practical Examples and Demonstrations

**Example 1: Calculating the Sum of Elements in a Matrix**

```java
public class MatrixSum {
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };

        int sum = 0;
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                sum += matrix[i][j];
            }
        }

        System.out.println("Sum of all elements: " + sum); // Output: Sum of all elements: 45
    }
}
```

This example demonstrates how to calculate the sum of all elements in a two-dimensional array using nested loops.

**Example 2: Finding the Maximum Element in a Matrix**

```java
public class MatrixMax {
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 20, 3},
            {4, 5, 60},
            {70, 8, 9}
        };

        int max = matrix[0][0]; // Initialize max with the first element
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                if (matrix[i][j] > max) {
                    max = matrix[i][j];
                }
            }
        }

        System.out.println("Maximum element: " + max); // Output: Maximum element: 70
    }
}
```

This example shows how to find the maximum element in a two-dimensional array by iterating through all elements and comparing them to the current maximum.

**Example 3: Matrix Multiplication**

```java
public class MatrixMultiplication {
    public static void main(String[] args) {
        int[][] matrixA = {
            {1, 2},
            {3, 4}
        };

        int[][] matrixB = {
            {5, 6},
            {7, 8}
        };

        int rowsA = matrixA.length;
        int colsA = matrixA[0].length;
        int rowsB = matrixB.length;
        int colsB = matrixB[0].length;

        if (colsA != rowsB) {
            System.out.println("Matrices cannot be multiplied.");
            return;
        }

        int[][] result = new int[rowsA][colsB];

        for (int i = 0; i < rowsA; i++) {
            for (int j = 0; j < colsB; j++) {
                for (int k = 0; k < colsA; k++) {
                    result[i][j] += matrixA[i][k] * matrixB[k][j];
                }
            }
        }

        // Print the result matrix
        System.out.println("Resultant Matrix:");
        for (int i = 0; i < rowsA; i++) {
            for (int j = 0; j < colsB; j++) {
                System.out.print(result[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

This example demonstrates matrix multiplication, a common operation in linear algebra and computer graphics. It highlights the use of nested loops to perform the necessary calculations.

#### <a name="chapter4part6"></a>Chapter 4 - Part 6: Introduction to Strings: Working with Text

Strings are fundamental to programming, as they allow us to represent and manipulate text, which is a crucial part of almost any application. From displaying messages to users to processing data from files, strings are everywhere. This lesson will introduce you to the concept of strings in Java, how to create them, and some of the basic operations you can perform on them. Understanding strings is essential for building more complex and interactive programs.

#### <a name="chapter4part6.1"></a>Chapter 4 - Part 6.1: Creating Strings

In Java, a string is an object that represents a sequence of characters. Unlike primitive data types like int or boolean, strings are objects of the String class. There are two primary ways to create strings in Java: using string literals and using the new keyword.

**String Literals**

The most common way to create a string is by using a string literal. A string literal is a sequence of characters enclosed in double quotes.

```java
String message = "Hello, world!";
String name = "Alice";
String emptyString = ""; // An empty string
```

When you create a string literal, Java checks if a string with the same content already exists in the string pool. The string pool is a special memory area in the Java Virtual Machine (JVM) that stores string literals. If the string already exists, Java will simply return a reference to the existing string in the pool. If it doesn't exist, Java will create a new string object in the pool and return a reference to it. This mechanism is called string interning and it helps to save memory and improve performance.

**Using the new Keyword**

You can also create a string using the new keyword, just like creating any other object in Java.

```java
String message = new String("Hello, world!");
String name = new String("Alice");
```

When you use the new keyword, Java always creates a new string object in the heap memory, regardless of whether a string with the same content already exists in the string pool. This means that using new to create strings is generally less efficient than using string literals.

**Example**:

```java
String str1 = "Hello";
String str2 = "Hello";
String str3 = new String("Hello");
String str4 = new String("Hello");

System.out.println(str1 == str2); // Output: true (both refer to the same string in the string pool)
System.out.println(str1 == str3); // Output: false (str1 is in the string pool, str3 is in the heap)
System.out.println(str3 == str4); // Output: false (both are different objects in the heap)
```

In the above example, str1 and str2 both refer to the same string object in the string pool. However, str3 and str4 are different string objects in the heap memory, even though they have the same content. This distinction is important when comparing strings, as we'll see later.

#### <a name="chapter4part6.2"></a>Chapter 4 - Part 6.2: String Manipulation

Strings in Java are immutable, which means that once a string object is created, its value cannot be changed. Any operation that appears to modify a string actually creates a new string object. This immutability has several advantages, such as thread safety and the ability to cache string hash codes.

**Concatenation**

String concatenation is the process of joining two or more strings together to create a new string. In Java, you can concatenate strings using the + operator or the concat() method.

**Using the + Operator**

The + operator is the most common and convenient way to concatenate strings in Java.

```java
String firstName = "John";
String lastName = "Doe";
String fullName = firstName + " " + lastName; // Concatenating with a space in between
System.out.println(fullName); // Output: John Doe
```

When you use the + operator to concatenate a string with a value of another data type (e.g., an integer or a boolean), Java automatically converts the other value to a string before performing the concatenation.

```java
String age = "30";
String message = "He is " + age + " years old.";
System.out.println(message); // Output: He is 30 years old.
```

**Using the concat() Method**

The String class also provides a concat() method that you can use to concatenate strings.

```java
String str1 = "Hello";
String str2 = " World";
String result = str1.concat(str2);
System.out.println(result); // Output: Hello World
```

The concat() method takes a single string argument and returns a new string that is the result of concatenating the original string with the argument.

**Performance Considerations**:

While both the + operator and the concat() method can be used for string concatenation, the + operator is generally more efficient, especially when concatenating multiple strings. This is because the Java compiler optimizes the + operator to use a StringBuilder object internally, which is more efficient for performing multiple concatenations. For simple concatenations, the performance difference is negligible. However, when performing a large number of concatenations in a loop, using a StringBuilder directly can significantly improve performance. We will cover StringBuilder in a later lesson.

**Substrings**

A substring is a contiguous sequence of characters within a string. The String class provides the substring() method to extract substrings from a string.

The substring() method has two overloaded versions:

- ```substring(int beginIndex)```: Returns a substring starting from the specified beginIndex to the end of the string.
- ```substring(int beginIndex, int endIndex)```: Returns a substring starting from the specified beginIndex up to (but not including) the specified endIndex.

```java
String message = "Hello, world!";

String sub1 = message.substring(7); // Substring from index 7 to the end
System.out.println(sub1); // Output: world!

String sub2 = message.substring(0, 5); // Substring from index 0 up to (but not including) index 5
System.out.println(sub2); // Output: Hello
```

**Important Notes**:

- The beginIndex is inclusive, meaning the character at that index is included in the substring.
- The endIndex is exclusive, meaning the character at that index is not included in the substring.
- The beginIndex must be between 0 and the length of the string (inclusive).
- The endIndex must be between 0 and the length of the string (inclusive).
- The beginIndex must be less than or equal to the endIndex.
- If any of these conditions are not met, the substring() method will throw a StringIndexOutOfBoundsException.

**Length**

The length() method returns the number of characters in a string.

```java
String message = "Hello, world!";
int length = message.length();
System.out.println(length); // Output: 13
```

The length of a string includes all characters, including spaces and punctuation marks.

#### <a name="chapter4part6.3"></a>Chapter 4 - Part 6.3: String Comparison: equals() vs. ==

Comparing strings in Java can be tricky because strings are objects. You need to understand the difference between comparing the content of strings and comparing the references to string objects.

**The equals() Method**

The equals() method compares the content of two strings. It returns true if the strings have the same sequence of characters, and false otherwise.

```java
String str1 = "Hello";
String str2 = "Hello";
String str3 = new String("Hello");

System.out.println(str1.equals(str2)); // Output: true (same content)
System.out.println(str1.equals(str3)); // Output: true (same content)
```

The equals() method is case-sensitive, meaning that "Hello" is not equal to "hello". If you want to perform a case-insensitive comparison, you can use the equalsIgnoreCase() method.

```java
String str1 = "Hello";
String str2 = "hello";

System.out.println(str1.equals(str2)); // Output: false (different case)
System.out.println(str1.equalsIgnoreCase(str2)); // Output: true (same content, ignoring case)
```

**The == Operator**

The == operator compares the references of two string objects. It returns true if the two variables refer to the same object in memory, and false otherwise.

```java
String str1 = "Hello";
String str2 = "Hello";
String str3 = new String("Hello");

System.out.println(str1 == str2); // Output: true (both refer to the same string in the string pool)
System.out.println(str1 == str3); // Output: false (str1 is in the string pool, str3 is in the heap)
```

As we saw earlier, string literals are interned in the string pool, so if you create two string literals with the same content, they will both refer to the same object in memory. However, if you create a string using the new keyword, it will always create a new object in the heap memory, even if a string with the same content already exists in the string pool.

**Best Practice**:

Always use the equals() method to compare the content of strings. Avoid using the == operator unless you specifically need to check if two variables refer to the same object in memory.



#### <a name="chapter4part6.4"></a>Chapter 4 - Part 6.4: String Methods: ```toUpperCase()```, ```toLowerCase()```, ```trim()```

The String class provides a variety of methods for manipulating strings. Here are three commonly used methods:

**```toUpperCase()```**

The toUpperCase() method converts all characters in a string to uppercase.

```java
String message = "Hello, world!";
String upperCaseMessage = message.toUpperCase();
System.out.println(upperCaseMessage); // Output: HELLO, WORLD!
```

**```toLowerCase()```**

The toLowerCase() method converts all characters in a string to lowercase.

```java
String message = "Hello, world!";
String lowerCaseMessage = message.toLowerCase();
System.out.println(lowerCaseMessage); // Output: hello, world!
```

**```trim()```**

The trim() method removes any leading and trailing whitespace from a string. Whitespace includes spaces, tabs, and newline characters.

```java
String message = "   Hello, world!   ";
String trimmedMessage = message.trim();
System.out.println(trimmedMessage); // Output: Hello, world!
```

**Example demonstrating all three methods**:

```java
String input = "  Java Programming  ";
String trimmedInput = input.trim(); // Remove leading/trailing spaces
String lowerCaseInput = trimmedInput.toLowerCase(); // Convert to lowercase
String upperCaseInput = trimmedInput.toUpperCase(); // Convert to uppercase

System.out.println("Original: " + input);
System.out.println("Trimmed: " + trimmedInput);
System.out.println("Lowercase: " + lowerCaseInput);
System.out.println("Uppercase: " + upperCaseInput);
```

#### <a name="chapter4part7"></a>Chapter 4 - Part 7: String Manipulation: Concatenation, Substrings, Length

Strings are fundamental to programming, representing and manipulating text. In Java, strings are objects, and the String class provides numerous methods for working with them. This lesson focuses on three essential string manipulation techniques: concatenation, extracting substrings, and determining string length. Mastering these techniques is crucial for tasks such as building dynamic messages, parsing data, and validating user input.

#### <a name="chapter4part7.1"></a>Chapter 4 - Part 7.1: String Concatenation

String concatenation is the process of combining two or more strings into a single, longer string. Java provides two primary ways to concatenate strings: the + operator and the concat() method.

**Using the + Operator**

The + operator is the most common and straightforward way to concatenate strings in Java. When used with strings, the + operator creates a new string that is the result of joining the operands.

```java
public class StringConcatenation {
    public static void main(String[] args) {
        String firstName = "John";
        String lastName = "Doe";
        String fullName = firstName + " " + lastName; // Concatenating with a space in between
        System.out.println(fullName); // Output: John Doe

        String greeting = "Hello, " + fullName + "!";
        System.out.println(greeting); // Output: Hello, John Doe!

        int age = 30;
        String ageMessage = "Age: " + age; // Concatenating a string with an integer
        System.out.println(ageMessage); // Output: Age: 30
    }
}
```

In the example above, the + operator is used to combine string literals, string variables, and even an integer with a string. Java automatically converts the integer to its string representation before concatenation.

**Important Note**: When using the + operator for concatenation within loops, especially with a large number of iterations, it can lead to performance issues because strings are immutable in Java. Each concatenation creates a new String object, which can be inefficient. In such cases, using StringBuilder or StringBuffer (discussed later in the course) is recommended.

**Using the concat() Method**

The String class provides a concat() method that performs string concatenation. This method takes a single string argument and returns a new string that is the result of appending the argument to the original string.

```java
public class StringConcatMethod {
    public static void main(String[] args) {
        String str1 = "Hello";
        String str2 = " World";
        String result = str1.concat(str2);
        System.out.println(result); // Output: Hello World

        String str3 = "Java";
        String str4 = str3.concat(" Programming");
        System.out.println(str4); // Output: Java Programming
    }
}
```

The concat() method is functionally equivalent to the + operator for simple string concatenation. However, the + operator is generally preferred for its readability and ease of use.

**Example**:

Let's say you're building a system that generates personalized email greetings. You can use string concatenation to combine a generic greeting with a user's name:

```java
public class EmailGreeting {
    public static void main(String[] args) {
        String baseGreeting = "Dear ";
        String userName = "Alice";
        String salutation = ",";
        String closing = "\nThank you,\nThe Team";

        String fullGreeting = baseGreeting + userName + salutation + closing;
        System.out.println(fullGreeting);
    }
}
```

This example demonstrates how concatenation can be used to dynamically create personalized messages.

#### <a name="chapter4part7.2"></a>Chapter 4 - Part 7.2: Extracting Substrings

A substring is a contiguous sequence of characters within a string. The String class provides methods to extract substrings based on starting and ending indices.

**The ```substring()``` Method**

The substring() method has two overloaded forms:

- ```substring(int beginIndex)```: Returns a substring starting from the specified beginIndex to the end of the string.
- ```substring(int beginIndex, int endIndex)```: Returns a substring starting from the specified beginIndex up to (but not including) the specified endIndex.

**Important Notes**:

- String indices are zero-based, meaning the first character is at index 0.
- The beginIndex is inclusive, while the endIndex is exclusive.
- If beginIndex is negative or greater than the string length, an IndexOutOfBoundsException is thrown.
- If endIndex is less than beginIndex or greater than the string length, an IndexOutOfBoundsException is thrown.

```java
public class SubstringExample {
    public static void main(String[] args) {
        String message = "Hello, World!";

        // Extracting a substring from index 7 to the end
        String sub1 = message.substring(7);
        System.out.println(sub1); // Output: World!

        // Extracting a substring from index 0 to index 5 (exclusive)
        String sub2 = message.substring(0, 5);
        System.out.println(sub2); // Output: Hello

        // Extracting "World" from the string
        String sub3 = message.substring(7, 12);
        System.out.println(sub3); // Output: World
    }
}
```

**Example**:

Suppose you have a string containing a file path, and you want to extract the file name. You can use the substring() method in conjunction with the lastIndexOf() method (which will be covered in a later lesson) to achieve this.

```java
public class FilePathExample {
    public static void main(String[] args) {
        String filePath = "/path/to/my/document.txt";
        int lastSlashIndex = filePath.lastIndexOf('/'); // Find the last occurrence of '/'
        String fileName = filePath.substring(lastSlashIndex + 1); // Extract the file name
        System.out.println(fileName); // Output: document.txt
    }
}
```

This example demonstrates how substrings can be used to parse and extract specific parts of a string.

#### <a name="chapter4part7.3"></a>Chapter 4 - Part 7.3: Determining String Length

The length of a string is the number of characters it contains. The String class provides the length() method to determine the length of a string.

**The ```length()``` Method**

The length() method returns the number of characters in the string.

```java
public class StringLengthExample {
    public static void main(String[] args) {
        String str1 = "Hello";
        int len1 = str1.length();
        System.out.println(len1); // Output: 5

        String str2 = "This is a sentence.";
        int len2 = str2.length();
        System.out.println(len2); // Output: 19

        String str3 = ""; // Empty string
        int len3 = str3.length();
        System.out.println(len3); // Output: 0
    }
}
```

Important Note: The length() method returns the number of characters, not the number of bytes. In Java, strings are represented using Unicode, where each character can be represented by one or more bytes.

**Example**:

You might want to validate user input to ensure it meets certain length requirements. For example, you might require a password to be at least 8 characters long.

```java
import java.util.Scanner;

public class PasswordValidation {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter your password: ");
        String password = scanner.nextLine();

        int minLength = 8;
        if (password.length() >= minLength) {
            System.out.println("Password is valid.");
        } else {
            System.out.println("Password must be at least " + minLength + " characters long.");
        }
        scanner.close();
    }
}
```

This example demonstrates how the length() method can be used for input validation.

#### <a name="chapter4part8"></a>Chapter 4 - Part 8: String Comparison: equals() vs. ==

String comparison is a fundamental operation in Java programming. It allows you to determine if two strings are the same or different, which is crucial for various tasks such as data validation, searching, and sorting. However, comparing strings in Java can be tricky because of the way strings are handled as objects. This lesson will delve into the nuances of string comparison in Java, focusing on the equals() method and the == operator, highlighting their differences and proper usage.

#### <a name="chapter4part8.1"></a>Chapter 4 - Part 8.1: Understanding String Immutability and the String Pool

Before diving into the comparison methods, it's essential to understand that strings in Java are immutable. This means that once a string object is created, its value cannot be changed. Any operation that appears to modify a string actually creates a new string object.

Java also uses a "string pool" (also known as the string intern pool) to optimize memory usage. When a string literal is created (e.g., "hello"), the JVM first checks if a string with the same value already exists in the string pool. If it does, the new string variable will point to the existing string object in the pool. If not, a new string object is created in the pool.

#### <a name="chapter4part8.2"></a>Chapter 4 - Part 8.2: The equals() Method: Comparing String Content

The equals() method is the correct way to compare the content of two strings in Java. It checks if the two strings have the exact same sequence of characters, regardless of whether they are stored in the same memory location.

**Syntax and Usage**

The equals() method is called on a string object and takes another string object as an argument:

```java
String str1 = "hello";
String str2 = "hello";

boolean isEqual = str1.equals(str2); // Returns true
```

**Case Sensitivity**

The equals() method is case-sensitive. This means that "Hello" and "hello" are considered different strings.

```java
String str1 = "Hello";
String str2 = "hello";

boolean isEqual = str1.equals(str2); // Returns false
```

**The equalsIgnoreCase() Method**

If you need to compare strings without regard to case, you can use the equalsIgnoreCase() method.

```java
String str1 = "Hello";
String str2 = "hello";

boolean isEqual = str1.equalsIgnoreCase(str2); // Returns true
```

**Comparing with Null**

It's important to be careful when using equals() with potentially null strings. Calling equals() on a null reference will result in a NullPointerException. To avoid this, you can either check for null explicitly or use the Objects.equals() method (introduced in Java 7), which handles null checks for you.

```java
String str1 = null;
String str2 = "hello";

// Avoid NullPointerException
boolean isEqual1 = (str1 != null) && str1.equals(str2); // Returns false

// Using Objects.equals()
boolean isEqual2 = java.util.Objects.equals(str1, str2); // Returns false
```

**Examples**

```java
public class StringEqualsExample {
    public static void main(String[] args) {
        String str1 = "Java";
        String str2 = "Java";
        String str3 = new String("Java");
        String str4 = "Python";

        System.out.println("str1 equals str2: " + str1.equals(str2)); // true
        System.out.println("str1 equals str3: " + str1.equals(str3)); // true
        System.out.println("str1 equals str4: " + str1.equals(str4)); // false

        String nullStr = null;
        String str5 = "test";

        //System.out.println("nullStr equals str5: " + nullStr.equals(str5)); // NullPointerException
        System.out.println("Objects.equals(nullStr, str5): " + java.util.Objects.equals(nullStr, str5)); // false
    }
}
```

#### <a name="chapter4part8.3"></a>Chapter 4 - Part 8.3: The == Operator: Comparing Object References

The == operator compares the references of two objects. In the context of strings, it checks if two string variables point to the same memory location (i.e., the same object). It does not compare the content of the strings.

**Behavior with String Literals**

When you create string literals, Java often uses the string pool. If two string literals have the same value, they will usually point to the same object in the string pool, and == will return true.

```java
String str1 = "hello";
String str2 = "hello";

boolean areSame = (str1 == str2); // Returns true because both point to the same object in the string pool
```

**Behavior with ```new String()```**

However, when you create a string object using the new String() constructor, a new string object is created in memory, even if a string with the same value already exists in the string pool. In this case, == will return false because the two variables point to different objects.

```java
String str1 = "hello";
String str2 = new String("hello");

boolean areSame = (str1 == str2); // Returns false because str2 is a new object
```

**Examples**

```java
public class StringEqualsOperatorExample {
    public static void main(String[] args) {
        String str1 = "Java";
        String str2 = "Java";
        String str3 = new String("Java");

        System.out.println("str1 == str2: " + (str1 == str2)); // true (both point to the same string in the pool)
        System.out.println("str1 == str3: " + (str1 == str3)); // false (str3 is a new object)
    }
}
```

#### <a name="chapter4part8.4"></a>Chapter 4 - Part 8.4: When to Use ```equals()``` vs. ```==```

- **```Use equals() (or equalsIgnoreCase())``` to compare the content of strings**. This is almost always what you want to do.

- **Avoid using == to compare strings unless you specifically need to check if two variables point to the exact same object in memory**. This is rarely the case in typical string manipulation scenarios.

#### <a name="chapter4part9"></a>Chapter 4 - Part 9: String Methods: toUpperCase(), toLowerCase(), trim()

Strings in Java are immutable sequences of characters, and the String class provides a rich set of methods for manipulating them. This lesson focuses on three fundamental string methods: toUpperCase(), toLowerCase(), and trim(). These methods are essential for standardizing and cleaning string data, which is a common task in many applications. Understanding how to use these methods effectively will enable you to write more robust and maintainable code.

#### <a name="chapter4part9.1"></a>Chapter 4 - Part 9.1: Understanding toUpperCase() and toLowerCase()

**Understanding toUpperCase() and toLowerCase()**

The toUpperCase() and toLowerCase() methods are used to convert a string to uppercase and lowercase, respectively. These methods are particularly useful when you need to perform case-insensitive comparisons or when you need to format strings for display purposes.

**```toUpperCase()```**

The toUpperCase() method converts all characters in a string to uppercase. It returns a new string with all characters converted to their uppercase equivalents. If a character does not have an uppercase equivalent, it remains unchanged.

```java
public class ToUpperCaseExample {
    public static void main(String[] args) {
        String str = "Hello World";
        String upperCaseStr = str.toUpperCase();
        System.out.println("Original String: " + str);
        System.out.println("Uppercase String: " + upperCaseStr);
    }
}
```

In this example, the toUpperCase() method converts the string "Hello World" to "HELLO WORLD".

**```toLowerCase()```**

The toLowerCase() method converts all characters in a string to lowercase. It returns a new string with all characters converted to their lowercase equivalents. If a character does not have a lowercase equivalent, it remains unchanged.

```java
public class ToLowerCaseExample {
    public static void main(String[] args) {
        String str = "Hello World";
        String lowerCaseStr = str.toLowerCase();
        System.out.println("Original String: " + str);
        System.out.println("Lowercase String: " + lowerCaseStr);
    }
}
```

In this example, the toLowerCase() method converts the string "Hello World" to "hello world".

**Locale-Specific Case Conversion**

Both toUpperCase() and toLowerCase() have overloaded versions that accept a Locale object as an argument. The Locale object specifies the cultural context for the conversion. This is important because the rules for case conversion can vary depending on the language and region.

```java
import java.util.Locale;

public class LocaleCaseConversionExample {
    public static void main(String[] args) {
        String str = "turkey";
        String upperCaseStrDefault = str.toUpperCase();
        String upperCaseStrTurkish = str.toUpperCase(new Locale("tr", "TR"));

        System.out.println("Original String: " + str);
        System.out.println("Uppercase String (Default Locale): " + upperCaseStrDefault);
        System.out.println("Uppercase String (Turkish Locale): " + upperCaseStrTurkish);
    }
}
```

In this example, the toUpperCase() method is called with and without a Locale object. The default locale conversion might not correctly handle characters specific to the Turkish language. Using the Turkish locale ensures that the conversion is performed according to Turkish language rules. The output of this code demonstrates the difference: the default locale might not convert the "i" correctly, while the Turkish locale will.

**Practical Examples**

- **User Input Normalization**: When accepting user input, you might want to convert the input to a consistent case before processing it. For example, if you are checking if a user has entered "yes" to confirm an action, you can convert the input to lowercase before comparing it to "yes".

```java
import java.util.Scanner;

public class UserInputNormalization {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Do you want to continue? (yes/no)");
        String answer = scanner.nextLine();
        String normalizedAnswer = answer.toLowerCase();

        if (normalizedAnswer.equals("yes")) {
            System.out.println("Continuing...");
        } else {
            System.out.println("Stopping...");
        }
        scanner.close();
    }
}
```

- **Data Standardization**: When processing data from different sources, you might encounter inconsistencies in the case of strings. Converting all strings to a consistent case can help to standardize the data and make it easier to process.

```java
public class DataStandardization {
    public static void main(String[] args) {
        String[] data = {"Apple", "banana", "ORANGE"};
        for (int i = 0; i < data.length; i++) {
            data[i] = data[i].toLowerCase();
        }

        for (String item : data) {
            System.out.println(item);
        }
    }
}
```

#### <a name="chapter4part9.2"></a>Chapter 4 - Part 9.2: Understanding trim()

The trim() method removes leading and trailing whitespace from a string. Whitespace includes spaces, tabs, and newline characters. This method is useful for cleaning up strings that may have unwanted whitespace, such as user input or data read from a file.

**Basic Usage**

The trim() method returns a new string with all leading and trailing whitespace removed. If the string has no leading or trailing whitespace, it returns the original string.

```java
public class TrimExample {
    public static void main(String[] args) {
        String str = "   Hello World   ";
        String trimmedStr = str.trim();
        System.out.println("Original String: \"" + str + "\"");
        System.out.println("Trimmed String: \"" + trimmedStr + "\"");
    }
}
```

In this example, the trim() method removes the leading and trailing spaces from the string " Hello World ".

**Practical Examples**

- **User Input Validation**: When accepting user input, you might want to trim the input to remove any leading or trailing whitespace that the user may have accidentally entered.

```java
import java.util.Scanner;

public class UserInputValidation {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter your username:");
        String username = scanner.nextLine();
        String trimmedUsername = username.trim();

        if (trimmedUsername.isEmpty()) {
            System.out.println("Username cannot be empty.");
        } else {
            System.out.println("Username: " + trimmedUsername);
        }
        scanner.close();
    }
}
```

- **Data Cleaning**: When processing data from different sources, you might encounter strings with leading or trailing whitespace. Trimming these strings can help to ensure that the data is consistent and accurate.

```java
public class DataCleaning {
    public static void main(String[] args) {
        String[] data = {"  Apple", "banana  ", "  Orange  "};
        for (int i = 0; i < data.length; i++) {
            data[i] = data[i].trim();
        }

        for (String item : data) {
            System.out.println("\"" + item + "\"");
        }
    }
}
```

#### <a name="chapter4part9.3"></a>Chapter 4 - Part 9.3: Combining String Methods

You can combine these string methods to perform more complex string manipulations. For example, you can convert a string to lowercase and then trim it to remove any leading or trailing whitespace.

```java
public class CombinedStringMethods {
    public static void main(String[] args) {
        String str = "   Hello World   ";
        String processedStr = str.toLowerCase().trim();
        System.out.println("Original String: \"" + str + "\"");
        System.out.println("Processed String: \"" + processedStr + "\"");
    }
}
```

In this example, the toLowerCase() method is called first to convert the string to lowercase, and then the trim() method is called to remove any leading or trailing whitespace.

## <a name="chapter5"></a>Chapter 5: Object-Oriented Programming (OOP) Fundamentals

#### <a name="chapter5part1"></a>Chapter 5 - Part 1: Introduction to Object-Oriented Programming (OOP)

#### <a name="chapter5part1.1"></a>Chapter 5 - Part 1.1: Understanding Classes and Objects

#### <a name="chapter5part1.2"></a>Chapter 5 - Part 1.2: Defining Classes: Attributes (Fields) and Behaviors (Methods)

#### <a name="chapter5part1.3"></a>Chapter 5 - Part 1.3: Creating Objects: Instantiating Classes

#### <a name="chapter5part1.4"></a>Chapter 5 - Part 1.4: Accessing Object Attributes and Calling Methods

#### <a name="chapter5part1.5"></a>Chapter 5 - Part 1.5: Constructors: Initializing Objects

#### <a name="chapter5part1.6"></a>Chapter 5 - Part 1.6: The this Keyword: Referring to the Current Object

#### <a name="chapter5part1.7"></a>Chapter 5 - Part 1.7: Introduction to Encapsulation: Hiding Data

#### <a name="chapter5part1.8"></a>Chapter 5 - Part 1.8: Exercises

#### <a name="chapter5part1.9"></a>Chapter 5 - Part 1.9: Summary

#### <a name="chapter5part1.10"></a>Chapter 5 - Part 1.10: Next Steps

#### <a name="chapter5part2"></a>Chapter 5 - Part 2: Understanding Classes and Objects

#### <a name="chapter5part2.1"></a>Chapter 5 - Part 2.1: Understanding Classes

#### <a name="chapter5part2.2"></a>Chapter 5 - Part 2.2: Creating Objects: Instantiating Classes

#### <a name="chapter5part2.3"></a>Chapter 5 - Part 2.3: Accessing Object Attributes and Calling Methods

#### <a name="chapter5part2.4"></a>Chapter 5 - Part 2.4: Constructors: Initializing Objects

#### <a name="chapter5part2.5"></a>Chapter 5 - Part 2.5: The this Keyword: Referring to the Current Object

#### <a name="chapter5part2.6"></a>Chapter 5 - Part 2.6: Introduction to Encapsulation: Hiding Data

#### <a name="chapter5part2.7"></a>Chapter 5 - Part 2.7: Exercises

#### <a name="chapter5part3"></a>Chapter 5 - Part 3: Defining Classes: Attributes (Fields) and Behaviors (Methods)

#### <a name="chapter5part3.1"></a>Chapter 5 - Part 3.1: Understanding Classes and Objects

#### <a name="chapter5part3.2"></a>Chapter 5 - Part 3.2: Defining Classes: Attributes (Fields)

#### <a name="chapter5part3.3"></a>Chapter 5 - Part 3.3: Defining Classes: Behaviors (Methods)

#### <a name="chapter5part3.4"></a>Chapter 5 - Part 3.4: Practical Examples and Demonstrations

#### <a name="chapter5part3.5"></a>Chapter 5 - Part 3.5: Exercises

#### <a name="chapter5part3.6"></a>Chapter 5 - Part 3.6: Summary and Next Steps

#### <a name="chapter5part4"></a>Chapter 5 - Part 4: Creating Objects: Instantiating Classes

#### <a name="chapter5part4.1"></a>Chapter 5 - Part 4.1: Understanding Object Instantiation

#### <a name="chapter5part4.2"></a>Chapter 5 - Part 4.2: Practical Examples and Demonstrations

#### <a name="chapter5part4.3"></a>Chapter 5 - Part 4.3: Exercises

#### <a name="chapter5part4.4"></a>Chapter 5 - Part 4.4: Summary and Next Steps

#### <a name="chapter5part5"></a>Chapter 5 - Part 5: Accessing Object Attributes and Calling Methods

#### <a name="chapter5part5.1"></a>Chapter 5 - Part 5.1: Accessing Object Attributes

#### <a name="chapter5part5.2"></a>Chapter 5 - Part 5.2: Calling Methods

#### <a name="chapter5part5.3"></a>Chapter 5 - Part 5.3: Practice Activities

#### <a name="chapter5part5.4"></a>Chapter 5 - Part 5.4: Summary and Next Steps

#### <a name="chapter5part6"></a>Chapter 5 - Part 6: Constructors: Initializing Objects

#### <a name="chapter5part6.1"></a>Chapter 5 - Part 6.1: Understanding Constructors

#### <a name="chapter5part6.2"></a>Chapter 5 - Part 6.2: Default Constructor (No-Argument Constructor)

#### <a name="chapter5part6.3"></a>Chapter 5 - Part 6.3: Parameterized Constructor

#### <a name="chapter5part6.4"></a>Chapter 5 - Part 6.4: The this Keyword

#### <a name="chapter5part6.5"></a>Chapter 5 - Part 6.5: Practical Examples and Demonstrations

#### <a name="chapter5part6.6"></a>Chapter 5 - Part 6.6: Exercises

#### <a name="chapter5part6.7"></a>Chapter 5 - Part 6.7: Summary

#### <a name="chapter5part6.8"></a>Chapter 5 - Part 6.8: Next Steps and Future Learning Directions

#### <a name="chapter5part7"></a>Chapter 5 - Part 7: The `this` Keyword: Referring to the Current Object

#### <a name="chapter5part7.1"></a>Chapter 5 - Part 7.1: Understanding the this Keyword

#### <a name="chapter5part7.2"></a>Chapter 5 - Part 7.2: Practical Examples and Demonstrations

#### <a name="chapter5part7.3"></a>Chapter 5 - Part 7.3: Exercises

#### <a name="chapter5part7.4"></a>Chapter 5 - Part 7.4: Summary and Next Steps

#### <a name="chapter5part8"></a>Chapter 5 - Part 8: Introduction to Encapsulation: Hiding Data

#### <a name="chapter5part8.1"></a>Chapter 5 - Part 8.1: Understanding Encapsulation

#### <a name="chapter5part8.2"></a>Chapter 5 - Part 8.2: Implementing Encapsulation in Java

#### <a name="chapter5part8.3"></a>Chapter 5 - Part 8.3: Advanced Encapsulation Techniques

#### <a name="chapter5part8.4"></a>Chapter 5 - Part 8.4: Practice Activities

#### <a name="chapter5part8.5"></a>Chapter 5 - Part 8.5: Summary

#### <a name="chapter5part8.6"></a>Chapter 5 - Part 8.6: Next Steps and Future Learning Directions

## <a name="chapter6"></a>Chapter 6: Methods and Classes in Depth

#### <a name="chapter6part1"></a>Chapter 6 - Part 1: Method Overloading: Creating Methods with the Same Name

#### <a name="chapter6part1.1"></a>Chapter 6 - Part 1.1: Understanding Method Overloading

#### <a name="chapter6part1.2"></a>Chapter 6 - Part 1.2: Practical Examples and Demonstrations

#### <a name="chapter6part1.3"></a>Chapter 6 - Part 1.3: Exercises and Practice Activities

#### <a name="chapter6part1.4"></a>Chapter 6 - Part 1.4: Summary and Next Steps

#### <a name="chapter6part2"></a>Chapter 6 - Part 2: Method Parameters and Return Types

#### <a name="chapter6part2.1"></a>Chapter 6 - Part 2.1: Understanding Method Parameters

#### <a name="chapter6part2.2"></a>Chapter 6 - Part 2.2: Understanding Return Types

#### <a name="chapter6part2.3"></a>Chapter 6 - Part 2.3: Practical Examples and Demonstrations

#### <a name="chapter6part2.4"></a>Chapter 6 - Part 2.4: Exercises

#### <a name="chapter6part2.5"></a>Chapter 6 - Part 2.5: Summary and Next Steps

#### <a name="chapter6part3"></a>Chapter 6 - Part 3: Static Variables and Methods: Class-Level Members

#### <a name="chapter6part3.1"></a>Chapter 6 - Part 3.1: Understanding Static Variables

#### <a name="chapter6part3.2"></a>Chapter 6 - Part 3.2: Understanding Static Methods

#### <a name="chapter6part3.3"></a>Chapter 6 - Part 3.3: Static Blocks

#### <a name="chapter6part3.4"></a>Chapter 6 - Part 3.4: Real-World Applications

#### <a name="chapter6part3.5"></a>Chapter 6 - Part 3.5: Summary

#### <a name="chapter6part3.6"></a>Chapter 6 - Part 3.6: Next Steps

#### <a name="chapter6part4"></a>Chapter 6 - Part 4: Understanding Access Modifiers: public, private, protected, default

#### <a name="chapter6part4.1"></a>Chapter 6 - Part 4.1: Understanding Access Modifiers

#### <a name="chapter6part4.2"></a>Chapter 6 - Part 4.2: Access Levels: A Summary

#### <a name="chapter6part4.3"></a>Chapter 6 - Part 4.3: Practical Examples and Demonstrations

#### <a name="chapter6part4.4"></a>Chapter 6 - Part 4.4: Exercises

#### <a name="chapter6part4.5"></a>Chapter 6 - Part 4.5: Summary and Next Steps

#### <a name="chapter6part5"></a>Chapter 6 - Part 5: Introduction to Inheritance: Creating Hierarchies of Classes

#### <a name="chapter6part5.1"></a>Chapter 6 - Part 5.1: Understanding Inheritance

#### <a name="chapter6part5.2"></a>Chapter 6 - Part 5.2: The extends Keyword

#### <a name="chapter6part5.3"></a>Chapter 6 - Part 5.3: Method Overriding

#### <a name="chapter6part5.4"></a>Chapter 6 - Part 5.4: The super Keyword

#### <a name="chapter6part5.5"></a>Chapter 6 - Part 5.5: Practice Activities

#### <a name="chapter6part5.6"></a>Chapter 6 - Part 5.6: Summary and Next Steps

#### <a name="chapter6part6"></a>Chapter 6 - Part 6: The `extends` Keyword: Inheriting from a Parent Class

#### <a name="chapter6part6.1"></a>Chapter 6 - Part 6.1: Understanding the extends Keyword

#### <a name="chapter6part6.2"></a>Chapter 6 - Part 6.2: Practical Examples and Demonstrations

#### <a name="chapter6part6.3"></a>Chapter 6 - Part 6.3: Exercises

#### <a name="chapter6part6.4"></a>Chapter 6 - Part 6.4: Summary and Next Steps

#### <a name="chapter6part7"></a>Chapter 6 - Part 7: Method Overriding: Changing Inherited Behavior

#### <a name="chapter6part7.1"></a>Chapter 6 - Part 7.1: Understanding Method Overriding

#### <a name="chapter6part7.2"></a>Chapter 6 - Part 7.2: The super Keyword and Method Overriding

#### <a name="chapter6part7.3"></a>Chapter 6 - Part 7.3: Method Overriding vs. Method Overloading

#### <a name="chapter6part7.4"></a>Chapter 6 - Part 7.4: Practical Examples and Demonstrations

#### <a name="chapter6part7.5"></a>Chapter 6 - Part 7.5: Exercises

#### <a name="chapter6part7.6"></a>Chapter 6 - Part 7.6: Summary

#### <a name="chapter6part7.7"></a>Chapter 6 - Part 7.7: Next Steps and Future Learning Directions

#### <a name="chapter6part8"></a>Chapter 6 - Part 8: The `super` Keyword: Accessing Parent Class Members

#### <a name="chapter6part8.1"></a>Chapter 6 - Part 8.1: Understanding the super Keyword

#### <a name="chapter6part8.2"></a>Chapter 6 - Part 8.2: Exercises

#### <a name="chapter6part8.3"></a>Chapter 6 - Part 8.3: Summary

## <a name="chapter7"></a>Chapter 7: Exception Handling and Basic Input/Output

#### <a name="chapter7part1"></a>Chapter 7 - Part 1: Introduction to Exception Handling: Dealing with Errors

#### <a name="chapter7part1.1"></a>Chapter 7 - Part 1.1: Understanding Exceptions

#### <a name="chapter7part1.2"></a>Chapter 7 - Part 1.2: The try-catch Block: Handling Exceptions

#### <a name="chapter7part1.3"></a>Chapter 7 - Part 1.3: Common Exception Types

#### <a name="chapter7part1.4"></a>Chapter 7 - Part 1.4: Best Practices for Exception Handling

#### <a name="chapter7part1.5"></a>Chapter 7 - Part 1.5: Exercises

#### <a name="chapter7part1.6"></a>Chapter 7 - Part 1.6: Summary

#### <a name="chapter7part1.7"></a>Chapter 7 - Part 1.7: Next Steps

#### <a name="chapter7part2"></a>Chapter 7 - Part 2: The `try-catch` Block: Handling Exceptions

#### <a name="chapter7part2.1"></a>Chapter 7 - Part 2.1: Understanding Exceptions

#### <a name="chapter7part2.2"></a>Chapter 7 - Part 2.2: The try-catch Block: A Detailed Explanation

#### <a name="chapter7part2.3"></a>Chapter 7 - Part 2.3: Best Practices for Using try-catch Blocks

#### <a name="chapter7part2.4"></a>Chapter 7 - Part 2.4: Exercises

#### <a name="chapter7part3"></a>Chapter 7 - Part 3: The `finally` Block: Ensuring Code Executes

#### <a name="chapter7part3.1"></a>Chapter 7 - Part 3.1: Understanding the finally Block

#### <a name="chapter7part3.2"></a>Chapter 7 - Part 3.2: Practical Examples of Using finally

#### <a name="chapter7part3.3"></a>Chapter 7 - Part 3.3: Best Practices and Considerations

#### <a name="chapter7part3.4"></a>Chapter 7 - Part 3.4: Exercises

#### <a name="chapter7part4"></a>Chapter 7 - Part 4: Common Exception Types: NullPointerException, ArrayIndexOutOfBoundsException

#### <a name="chapter7part4.1"></a>Chapter 7 - Part 4.1: Understanding Exceptions

#### <a name="chapter7part4.2"></a>Chapter 7 - Part 4.2: The NullPointerException

#### <a name="chapter7part4.3"></a>Chapter 7 - Part 4.3: The ArrayIndexOutOfBoundsException

#### <a name="chapter7part4.4"></a>Chapter 7 - Part 4.4: Exercises

#### <a name="chapter7part4.5"></a>Chapter 7 - Part 4.5: Summary

#### <a name="chapter7part5"></a>Chapter 7 - Part 5: Custom Exceptions

#### <a name="chapter7part5.1"></a>Chapter 7 - Part 5.1: What is Custom Exception

#### <a name="chapter7part5.2"></a>Chapter 7 - Part 5.2: Creating Custom Exceptions

#### <a name="chapter7part6"></a>Chapter 7 - Part 6: Reading Input from the Console: Using the `Scanner` Class

#### <a name="chapter7part6.1"></a>Chapter 7 - Part 6.1: Introduction to the Scanner Class

#### <a name="chapter7part6.2"></a>Chapter 7 - Part 6.2: Reading Different Data Types

#### <a name="chapter7part6.3"></a>Chapter 7 - Part 6.3: Handling Input Mismatch Exceptions

#### <a name="chapter7part6.4"></a>Chapter 7 - Part 6.4: Practical Examples and Demonstrations

#### <a name="chapter7part6.5"></a>Chapter 7 - Part 6.5: Exercises

#### <a name="chapter7part7"></a>Chapter 7 - Part 7: Writing Output to the Console: Using `System.out.println()`

#### <a name="chapter7part7.1"></a>Chapter 7 - Part 7.1: Understanding System.out.println()

#### <a name="chapter7part7.2"></a>Chapter 7 - Part 7.2: Practical Examples and Demonstrations

#### <a name="chapter7part7.3"></a>Chapter 7 - Part 7.3: Exercises

#### <a name="chapter7part7.4"></a>Chapter 7 - Part 7.4: Summary

#### <a name="chapter7part7.5"></a>Chapter 7 - Part 7.5: Next Steps

#### <a name="chapter7part8"></a>Chapter 7 - Part 8: Introduction to File Input/Output: Reading and Writing Text Files

#### <a name="chapter7part8.1"></a>Chapter 7 - Part 8.1: Understanding File Input/Output (I/O)

#### <a name="chapter7part8.2"></a>Chapter 7 - Part 8.2: Reading Text Files

#### <a name="chapter7part8.3"></a>Chapter 7 - Part 8.3: Writing Text Files

#### <a name="chapter7part8.4"></a>Chapter 7 - Part 8.4: Practice Activities

#### <a name="chapter7part8.5"></a>Chapter 7 - Part 8.5: Summary

## <a name="chapter8"></a>Chapter 8: Java Date and Time

#### <a name="chapter8part1"></a>Chapter 8 - Part 1: Java Date and Time

## <a name="chapter9"></a>Chapter 9: Java Enums

#### <a name="chapter9part1"></a>Chapter 9 - Part 1: Java Enums

## <a name="chapter10"></a>Chapter 10: Reference Type vs. Value Types, Garbage Collector, Boxing, unboxing and wrapper classes

#### <a name="chapter8part1"></a>Chapter 10 - Part 1: Reference Type vs. Value Types

#### <a name="chapter8part2"></a>Chapter 10 - Part 2: Garbage Collector

#### <a name="chapter8part3"></a>Chapter 10 - Part 3:  Boxing, unboxing and wrapper classes

#### <a name="chapter8part4"></a>Chapter 10 - Part 4:  hashCode and equals

## <a name="chapter14"></a>Chapter 11: Java Interfaces

#### <a name="chapter11part1"></a>Chapter 11 - Part 1: Java Interfaces

#### <a name="chapter11part2"></a>Chapter 11 - Part 2: Dependency Injection and Inversion of Control

#### <a name="chapter11part3"></a>Chapter 11 - Part 3: Inheritance vs Interfaces

#### <a name="chapter11part4"></a>Chapter 11 - Part 4: Multiple Inheritance and Interfaces

#### <a name="chapter11part5"></a>Chapter 11 - Part 5: Comparable Interface

#### <a name="chapter11part6"></a>Chapter 11 - Part 6: Default methods

## <a name="chapter12"></a>Chapter 12: Collections

#### <a name="chapter12part1"></a>Chapter 12 - Part 1: ArrayList

#### <a name="chapter12part2"></a>Chapter 12 - Part 2: HashMap

#### <a name="chapter12part3"></a>Chapter 12 - Part 3: HashSet

## <a name="chapter13"></a>Chapter 13: Java Lambda Expression

#### <a name="chapter13part1"></a>Chapter 13 - Part 1: Java Lambda Expression

Lambda Expressions were added in Java 8.

A lambda expression is a short block of code which takes in parameters and returns a value. Lambda expressions are similar to methods, but they do not need a name and they can be implemented right in the body of a method.
	
**Syntax**
	
The simplest lambda expression contains a single parameter and an expression:
	
```java
	
parameter -> expression
	
```
	
To use more than one parameter, wrap them in parentheses:
	
```java
	
(parameter1, parameter2) -> expression
	
```
	
Expressions are limited. They have to immediately return a value, and they cannot contain variables, assignments or statements such as if or for. In order to do more complex operations, a code block can be used with curly braces. If the lambda expression needs to return a value, then the code block should have a return statement.
	
```java
	
(parameter1, parameter2) -> { code block }
	
```
	
**Using Lambda Expressions**
	
Lambda expressions are usually passed as parameters to a function:
	
Use a lambda expression in the ArrayList's forEach() method to print every item in the list:

```java

import java.util.ArrayList;

public class Main {
  public static void main(String[] args) {
    ArrayList<Integer> numbers = new ArrayList<Integer>();
    numbers.add(5);
    numbers.add(9);
    numbers.add(8);
    numbers.add(1);
    numbers.forEach( (n) -> { System.out.println(n); } );
  }
}

```
	
Lambda expressions can be stored in variables if the variable's type is an interface which has only one method. The lambda expression should have the same number of parameters and the same return type as that method. Java has many of these kinds of interfaces built in, such as the ```Consumer``` interface (found in the ```java.util``` package) used by lists.
	
Use Java's Consumer interface to store a lambda expression in a variable:
	
```java
	
import java.util.ArrayList;
import java.util.function.Consumer;

public class Main {
  public static void main(String[] args) {
    ArrayList<Integer> numbers = new ArrayList<Integer>();
    numbers.add(5);
    numbers.add(9);
    numbers.add(8);
    numbers.add(1);
    Consumer<Integer> method = (n) -> { System.out.println(n); };
    numbers.forEach( method );
  }
}
	
```
	
To use a lambda expression in a method, the method should have a parameter with a single-method interface as its type. Calling the interface's method will run the lambda expression:
	
```java
	
interface StringFunction {
  String run(String str);
}

public class Main {
  public static void main(String[] args) {
    StringFunction exclaim = (s) -> s + "!";
    StringFunction ask = (s) -> s + "?";
    printFormatted("Hello", exclaim);
    printFormatted("Hello", ask);
  }
  public static void printFormatted(String str, StringFunction format) {
    String result = format.run(str);
    System.out.println(result);
  }
}
	
```




#### <a name="chapter7part4"></a>Chapter 7 - Part 4: Comments

Block Comment: 

```java

/*

Your comment her

*/

```

Line Comment: 

```java

// Your comment her

```

```java

import java.util.Locale;
import java.util.Scanner;

/*
Este programa calcula as raízes de uma equação do segundo grau

Os valores dos coeficientes devem ser digitados um por linha
*/

public class Program {
	public static void main(String[] args) {
		
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		double a, b, c, delta;
		
		System.out.println("Digite os valores dos coeficientes:");
		a = sc.nextDouble();
		b = sc.nextDouble();
		c = sc.nextDouble();
		
		delta = b * b - 4 * a * c; // cálculo do valor de delta
		
		System.out.println(delta);
		
		sc.close();

	}
}

```

#### <a name="chapter7part5"></a>Chapter 7 - Part 5: Functions

They represent a processing that has a meaning:

- Math.sqrt(double)
-  System.out.println(string)

Main advantages:

- modularization, delegation and reuse

Functions can Input and output data:

- Functions can receive input data (parameters or arguments)
- Functions may or may not return an output

 In object orientation, functions in classes are called "methods"
 
 Example: Write a program to read three integers and display the largest one on the screen
 
 **Without Function Implementation**
 
 ```java
 
 import java.util.Scanner;

public class Program {
	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter three numbers:");
		int a = sc.nextInt();
		int b = sc.nextInt();
		int c = sc.nextInt();
		
		if (a > b && a > c) {
			System.out.println("Higher = " + a);
		} else if (b > c) {
			System.out.println("Higher = " + b);
		} else {
			System.out.println("Higher = " + c);
		}
		
		sc.close();

	}
}
 
 ```
 
 **With Function Implementation**
 
  ```java
  
  import java.util.Scanner;

public class Program {
	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter three numbers:");
		int a = sc.nextInt();
		int b = sc.nextInt();
		int c = sc.nextInt();
		
		int higher = max(a, b, c);
		
		showResult(higher);
		
		sc.close();
	}

	public static int max(int x, int y, int z) { //max function creation
		int aux;
		if (x > y && x > z) {
			aux = x;
		} else if (y > z) {
			aux = y;
		} else {
			aux = z;
		}
		return aux;
	}

	public static void showResult(int value) {
		System.out.println("Higher = " + value);
	}

}
  
   ```

#### <a name="chapter9part2"></a>Chapter 9 - Part 2: Classes, Objects and Attributes in Java

Classes and objects are the two main aspects of object-oriented programming.

**Class**

- Class: is the definition of the type

- It is a structured type that can contain (members):
  - Attributes (data / fields)
  - Methods (functions / operations)

- The class can also provide many other features, such as:
  - Constructors
  - Overloading
  - Encapsulation
  - Inheritance
  - Polymorphism

- Examples:
  - Entities: Product, Customer, Triangle
  - Services: ProductService, ClienteService, EmailService, StorageService
  - Controllers: ProductController, ClienteController
  - Utilities: Calculator, Compactor
  - Others (views, repositories, managers, etc.)

Everything in Java is associated with classes and objects, along with its attributes and methods. For example: in real life, a car is an object. The car has attributes, such as weight and color, and methods, such as drive and brake. 

A Class is like an object constructor, or a "blueprint" for creating objects.

**Create a Class**

To create a class, use the keyword ```class```:

```java

public class Triangle { //class Triangle
	public double a; // attribute of a triangle
	public double b; // attribute of a triangle
	public double c; // attribute of a triangle
}

```

**Object**

- Objects: are instances of the class

**Create a Object**

In Java, an object is created from a class. We have already created the class named ```Triangle```, so now we can use this to create objects.

To create an object of ```Triangle```, specify the class name, followed by the object name, and use the keyword ```new```:

```java

public class Program {
	
	public static void main(String[] args) {
	
		Triangle x, y;
		x = new Triangle();
		y = new Triangle();
	}
}

```

Now we created two objects of Class type Triagle, x and y.

Look at the following illustration to see the difference between class and objects:

<br>

<div align="center"><img src="img/classandobjects1-w1291-h563.png" width=1291 height=563><br><sub>Fig 28 - Class and objects - (<a href='https://www.w3schools.com/java/java_oop.asp'>Work by  w3schools</a>) </sub></div>

<br>

So, a class is a template for objects, and an object is an instance of a class.

When the individual objects are created, they inherit all the variables and methods from the class.

**Attributes**

In the class ```Triangle``` we used the term "variable" for ```a```, ```b``` and ```c```. It is actually an attribute of the class. Or you could say that class attributes are variables within a class.


```java

public class Triangle { //class Triangle
	public double a; // attribute of a triangle
	public double b; // attribute of a triangle
	public double c; // attribute of a triangle
}

```

**Accessing Attributes**

You can access attributes by creating an object of the class, and by using the dot syntax (```.```):

```java

import java.util.Locale;

public class Program {
	
	public static void main(String[] args) {
		
		Locale.setDefault(Locale.US);
		

		Triangle x, y;
		x = new Triangle();
		y = new Triangle();
		
		x.a = 3.00;
		x.b = 4.00;
		x.c = 5.00;
		
		y.a = 7.50;
		y.b = 4.50;
		y.c = 4.02;
		
	}
}

```

**Modify Attributes**

You can also modify attribute values:

```java

public class Main {
  int x;

  public static void main(String[] args) {
    Main myObj = new Main();
    myObj.x = 40;
    System.out.println(myObj.x);
  }
}


```

Or override existing values:

```java

public class Main {
  int x = 10;

  public static void main(String[] args) {
    Main myObj = new Main();
    myObj.x = 25; // x is now 25
    System.out.println(myObj.x);
  }
}

```

If you don't want the ability to override existing values, declare the attribute as ```final```:

```java

public class Main {
  final int x = 10;

  public static void main(String[] args) {
    Main myObj = new Main();
    myObj.x = 25; // will generate an error: cannot assign a value to a final variable
    System.out.println(myObj.x);
  }
}

```

OBS1: The ```final``` keyword is useful when you want a variable to always store the same value, like PI (3.14159...).

OBS2: The ```final``` keyword is called a "modifier".

#### <a name="chapter9part3"></a>Chapter 9 - Part 3: Solving the same Problem with object orientation

Create the class ```Triangle``` with the attributes

```java

public class Triangle { //class Triangle
	public double a; // attribute of a triangle
	public double b; // attribute of a triangle
	public double c; // attribute of a triangle
}

```

Now, create the Program, calling the class ```Triangle```

```java

import java.util.Locale;
import java.util.Scanner;

public class Program {
	
	public static void main(String[] args) {
		
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		

		Triangle x, y;
		x = new Triangle();
		y = new Triangle();
		
		System.out.println("Enter the measures of triangle X: ");
		x.a = sc.nextDouble();
		x.b = sc.nextDouble();
		x.c = sc.nextDouble();
		System.out.println("Enter the measures of triangle Y: ");
		y.a = sc.nextDouble();
		y.b = sc.nextDouble();
		y.c = sc.nextDouble();
		
		double p = (x.a + x.b + x.c) / 2.0;
		double areaX = Math.sqrt(p * (p - x.a) * (p - x.b) * (p - x.c));
		
		p = (y.a + y.b + y.c) / 2.0;
		double areaY = Math.sqrt(p * (p - y.a) * (p - y.b) * (p - y.c));
		
		System.out.printf("Triangle X area: %.4f%n", areaX);
		System.out.printf("Triangle Y area: %.4f%n", areaY);
		
		if (areaX > areaY) {
			System.out.println("Larger area: X");
		} else {
			System.out.println("Larger area: Y");
		}
		
		sc.close();
	}
}

```

#### <a name="chapter9part4"></a>Chapter 9 - Part 4: Methods in Java

A method is a block of code which only runs when it is called.

You can pass data, known as parameters, into a method.

Methods are used to perform certain actions, and they are also known as functions.

Why use methods? To reuse code: define the code once, and use it many times.

**Create a Method**

A method must be declared within a class. It is defined with the name of the method, followed by parentheses ```()```. Java provides some pre-defined methods, such as ```System.out.println()```, but you can also create your own methods to perform certain actions:

Create a method inside Main:

```java

public class Main {
  static void myMethod() {
    // code to be executed
  }
}

```

Example Explained: 

- ```myMethod()``` is the name of the method
- ```static``` means that the method belongs to the Main class and not an object of the Main class. You will learn more about objects and how to access methods through objects later in this tutorial.

- ```void``` means that this method does not have a return value. You will learn more about return values later in this chapter

**Call a Method**

To call a method in Java, write the method's name followed by two parentheses ```()``` and a semicolon```;```

In the following example, ```myMethod()``` is used to print a text (the action), when it is called:

Inside ```main```, call the ```myMethod()``` method:

```java

public class Main {
  static void myMethod() {
    System.out.println("I just got executed!");
  }

  public static void main(String[] args) {
    myMethod();
  }
}

// Outputs "I just got executed!"

```

A method can also be called multiple times:

```java

public class Main {
  static void myMethod() {
    System.out.println("I just got executed!");
  }

  public static void main(String[] args) {
    myMethod();
    myMethod();
    myMethod();
  }
}

// I just got executed!
// I just got executed!
// I just got executed!

```

**Parameters and Arguments**

Information can be passed to methods as parameter. Parameters act as variables inside the method.

Parameters are specified after the method name, inside the parentheses. You can add as many parameters as you want, just separate them with a comma.

The following example has a method that takes a ```String``` called fname as parameter. When the method is called, we pass along a first name, which is used inside the method to print the full name: 

```java

public class Main {
  static void myMethod(String fname) {
    System.out.println(fname + " Refsnes");
  }

  public static void main(String[] args) {
    myMethod("Liam");
    myMethod("Jenny");
    myMethod("Anja");
  }
}
// Liam Refsnes
// Jenny Refsnes
// Anja Refsnes

```

OBS: When a **parameter** is passed to the method, it is called an **argument**. So, from the example above: ```fname``` is a **parameter**, while ```Liam```, ```Jenny``` and ```Anja``` are **arguments**.

**Multiple Parameters**

You can have as many parameters as you like:

```java

public class Main {
  static void myMethod(String fname, int age) {
    System.out.println(fname + " is " + age);
  }

  public static void main(String[] args) {
    myMethod("Liam", 5);
    myMethod("Jenny", 8);
    myMethod("Anja", 31);
  }
}

// Liam is 5
// Jenny is 8
// Anja is 31

```

OBS:Note that when you are working with multiple parameters, the method call must have the same number of arguments as there are parameters, and the arguments must be passed in the same order.

**Return Values**

The ```void``` keyword, used in the examples above, indicates that the method should not return a value. If you want the method to return a value, you can use a primitive data type (such as ```int```, ```char```, etc.) instead of ```void```, and use the ```return``` keyword inside the method:

```java

public class Main {
  static int myMethod(int x) {
    return 5 + x;
  }

  public static void main(String[] args) {
    System.out.println(myMethod(3));
  }
}
// Outputs 8 (5 + 3)

```

This example returns the sum of a method's two parameters:

```java

public class Main {
  static int myMethod(int x, int y) {
    return x + y;
  }

  public static void main(String[] args) {
    System.out.println(myMethod(5, 3));
  }
}
// Outputs 8 (5 + 3)

```

You can also store the result in a variable (recommended, as it is easier to read and maintain):

```java

public class Main {
  static int myMethod(int x, int y) {
    return x + y;
  }

  public static void main(String[] args) {
    int z = myMethod(5, 3);
    System.out.println(z);
  }
}
// Outputs 8 (5 + 3)

```

**A Method with If...Else**

It is common to use ```if...else``` statements inside methods:

```java

public class Main {

  // Create a checkAge() method with an integer variable called age
  static void checkAge(int age) {

    // If age is less than 18, print "access denied"
    if (age < 18) {
      System.out.println("Access denied - You are not old enough!");

    // If age is greater than, or equal to, 18, print "access granted"
    } else {
      System.out.println("Access granted - You are old enough!");
    }

  }

  public static void main(String[] args) {
    checkAge(20); // Call the checkAge method and pass along an age of 20
  }
}

// Outputs "Access granted - You are old enough!"

```

**Method Overloading**

With method overloading, multiple methods can have the same name with different parameters:

```java

int myMethod(int x)
float myMethod(float x)
double myMethod(double x, double y)

```

Consider the following example, which has two methods that add numbers of different type:

```java

static int plusMethodInt(int x, int y) {
  return x + y;
}

static double plusMethodDouble(double x, double y) {
  return x + y;
}

public static void main(String[] args) {
  int myNum1 = plusMethodInt(8, 5);
  double myNum2 = plusMethodDouble(4.3, 6.26);
  System.out.println("int: " + myNum1);
  System.out.println("double: " + myNum2);
}

```

Instead of defining two methods that should do the same thing, it is better to overload one.

In the example below, we overload the ```plusMethod``` method to work for both ```int``` and ```double```:

```java

static int plusMethod(int x, int y) {
  return x + y;
}

static double plusMethod(double x, double y) {
  return x + y;
}

public static void main(String[] args) {
  int myNum1 = plusMethod(8, 5);
  double myNum2 = plusMethod(4.3, 6.26);
  System.out.println("int: " + myNum1);
  System.out.println("double: " + myNum2);
}

```

OBS: Note: Multiple methods can have the same name as long as the number and/or type of parameters are different.

**Method Scope**

Variables declared directly inside a method are available anywhere in the method following the line of code in which they were declared:

```java

public class Main {
  public static void main(String[] args) {

    // Code here CANNOT use x

    int x = 100;

    // Code here can use x
    System.out.println(x);
  }
}

```

**Block Scope**

A block of code refers to all of the code between curly braces ```{}```.

Variables declared inside blocks of code are only accessible by the code between the curly braces, which follows the line in which the variable was declared:

```java

public class Main {
  public static void main(String[] args) {

    // Code here CANNOT use x

    { // This is a block

      // Code here CANNOT use x

      int x = 100;

      // Code here CAN use x
      System.out.println(x);

   } // The block ends here

  // Code here CANNOT use x

  }
}

```

OBS: A block of code may exist on its own or it can belong to an ```if```, ```while``` or ```for``` statement. In the case of ```for``` statements, variables declared in the statement itself are also available inside the block's scope.

**Static vs. Public**

You will often see Java programs that have either ```static``` or ```public``` attributes and methods.

In the example above, we created a ```static``` method, which means that it can be accessed without creating an object of the class, unlike ```public```, which can only be accessed by objects:

An example to demonstrate the differences between ```static``` and ```public``` methods:

```java

public class Main {
  // Static method
  static void myStaticMethod() {
    System.out.println("Static methods can be called without creating objects");
  }

  // Public method
  public void myPublicMethod() {
    System.out.println("Public methods must be called by creating objects");
  }

  // Main method
  public static void main(String[] args) {
    myStaticMethod(); // Call the static method
    // myPublicMethod(); This would compile an error

    Main myObj = new Main(); // Create an object of Main
    myObj.myPublicMethod(); // Call the public method on the object
  }
}

```

**Access Methods With an Object**

Create a Car object named ```myCar```. Call the ```fullThrottle()``` and ```speed()``` methods on the ```myCar``` object, and run the program:

```java

// Create a Main class
public class Main {
 
  // Create a fullThrottle() method
  public void fullThrottle() {
    System.out.println("The car is going as fast as it can!");
  }

  // Create a speed() method and add a parameter
  public void speed(int maxSpeed) {
    System.out.println("Max speed is: " + maxSpeed);
  }

  // Inside main, call the methods on the myCar object
  public static void main(String[] args) {
    Main myCar = new Main();   // Create a myCar object
    myCar.fullThrottle();      // Call the fullThrottle() method
    myCar.speed(200);          // Call the speed() method
  }
}

// The car is going as fast as it can!
// Max speed is: 200


```

**Example explained**

- 1) We created a custom ```Main``` class with the ```class``` keyword.

- 2) We created the ```fullThrottle()``` and ```speed()``` methods in the ```Main``` class.

- 3) The ```fullThrottle()``` method and the ```speed()``` method will print out some text, when they are called.

- 4) The ```speed()``` method accepts an ```int``` parameter called ```maxSpeed``` - we will use this in VIII).

- 5) In order to use the ```Main``` class and its methods, we need to create an **object** of the ```Main``` Class.

- 6) Then, go to the ```main()``` method, which you know by now is a built-in Java method that runs your program (any code inside main is executed).

- 7) By using the ```new``` keyword we created an object with the name ```myCar```.

- 8) Then, we call the ```fullThrottle()``` and ```speed()``` methods on the ```myCar``` object, and run the program using the name of the object (```myCar```), followed by a dot (```.```), followed by the name of the method (```fullThrottle();``` and ```speed(200);```). Notice that we add an ```int``` parameter of **200** inside the ```speed()``` method.

#### <a name="chapter9part5"></a>Chapter 9 - Part 5: Continuing to solve the Problem with object orientation

Create the class ```Triangle``` with the attributes

```java

public class Triangle { //class Triangle
	public double a; // attribute of a triangle
	public double b; // attribute of a triangle
	public double c; // attribute of a triangle
	
	public double area() { // method of triangle
		double p = (a + b + c) / 2.0;
		return Math.sqrt(p * (p - a) * (p - b) * (p - c));
	}
}

```

Now, create the Program, calling the class ```Triangle```

```java

import java.util.Locale;
import java.util.Scanner;

public class Program {
	
	public static void main(String[] args) {
		
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		

		Triangle x, y;
		x = new Triangle();
		y = new Triangle();
		
		System.out.println("Enter the measures of triangle X: ");
		x.a = sc.nextDouble();
		x.b = sc.nextDouble();
		x.c = sc.nextDouble();
		System.out.println("Enter the measures of triangle Y: ");
		y.a = sc.nextDouble();
		y.b = sc.nextDouble();
		y.c = sc.nextDouble();
		
		double areaX = x.area();
		double areaY = y.area();
		
		System.out.printf("Triangle X area: %.4f%n", areaX);
		System.out.printf("Triangle Y area: %.4f%n", areaY);
		
		if (areaX > areaY) {
			System.out.println("Larger area: X");
		} else {
			System.out.println("Larger area: Y");
		}
		
		sc.close();
	}
}

```

#### <a name="chapter9part6"></a>Chapter 9 - Part 6: Second problem with object orientation

Write a program to read the data of a product in stock (name, price and quantity in stock).

Then:

- Show product data (name, price, quantity in stock, total value on inventory)

- Make a stock entry and show the product data again

- Carry out an issue in the stock and show the product data again

To solve this problem, you must create a CLASS according to the project on the side:

<br>

<div align="center"><img src="img/problemopp2-w417-h253.png" width=417 height=253><br><sub>Fig 29 - Problem with OOP - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

<div align="center"><img src="img/problemopp3-w1232-h458.png" width=1232 height=458><br><sub>Fig 29 - Problem with OOP - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

To solve this problem, we need to understand the Object Class in Java

#### <a name="chapter9part7"></a>Chapter 9 - Part 7: Object Class in Java

**Object Class in Java**

The **Object class** is the parent class of all the classes in java by default. In other words, it is the topmost class of java.

The Object class is beneficial if you want to refer any object whose type you don't know. Notice that parent class reference variable can refer the child class object, know as upcasting.

<br>

<div align="center"><img src="img/objectclass2-w612-h314.png" width=612 height=314><br><sub>Fig 30 - Class Object Inheritance in Java - (<a href='https://www.javatpoint.com/object-class'>Work by  java T Point</a>) </sub></div>

<br>

Let's take an example, there is getObject() method that returns an object but it can be of any type like Employee,Student etc, we can use Object class reference to refer that object. For example:

```java

Object obj=getObject();//we don't know what object will be returned from this method  

```

The Object class provides some common behaviors to all the objects such as object can be compared, object can be cloned, object can be notified etc. 


<br>

<div align="center"><img src="img/objectclass1-w696-h476.png" width=696 height=476><br><sub>Fig 31 - Class Object Methods in Java - (<a href='https://www.javatpoint.com/object-class'>Work by  java T Point</a>) </sub></div>

<br>

**Methods of Object class**

| Method                                                                      | Description     |
| :--------------------------------------------------------------------------:| :--------------:|
| public final Class getClass()                                               | returns the Class class object of this object. The Class class can further be used to get the metadata of this class.       |
| public int hashCode()                                                       | returns the hashcode number for this object. | 
| public boolean equals(Object obj)                                           | compares the given object to this object.             |
| protected Object clone() throws CloneNotSupportedException                  | creates and returns the exact copy (clone) of this object.       |
| public String toString()                                                    |returns the string representation of this object.       |
| public final void notify()                                                  | wakes up single thread, waiting on this object's monitor.       |
| public final void notifyAll()                                               | wakes up all the threads, waiting on this object's monitor.       |
| public final void wait(long timeout)throws InterruptedException             | causes the current thread to wait for the specified milliseconds, until another thread notifies (invokes notify() or notifyAll() method).       |
| public final void wait(long timeout,int nanos)throws InterruptedException   | causes the current thread to wait for the specified milliseconds and nanoseconds, until another thread notifies (invokes notify() or notifyAll() method).       |
| public final void wait()throws InterruptedException                         | causes the current thread to wait, until another thread notifies (invokes notify() or notifyAll() method).       |
| protected void finalize()throws Throwable                                   | is invoked by the garbage collector before object is being garbage collected.       |


Now, we will use the method ```toString()``` that will be able to display the name and attributes of the Product.

**Class Product**

```java

public class Product {

	public String name;
	public double price;
	public int quantity;

	public double totalValueInStock() {
		return price * quantity;
	}

	public void addProducts(int quantity) {
		this.quantity += quantity;
	}

	public void removeProducts(int quantity) {
		this.quantity -= quantity;
	}
	
	public String toString() {
		return name
		+ ", $ "
		+ String.format("%.2f", price)
		+ ", "
		+ quantity
		+ " units, Total: $ "
		+ String.format("%.2f", totalValueInStock());
	}

}

```

**Program**

```java

import java.util.Locale;
import java.util.Scanner;

public class Program {
	
	public static void main(String[] args) {
		
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		Product product = new Product();
		System.out.println("Enter product data: ");
		System.out.print("Name: ");
		product.name = sc.nextLine();
		System.out.print("Price: ");
		product.price = sc.nextDouble();
		System.out.print("Quantity in stock: ");
		product.quantity = sc.nextInt();
		
		System.out.println();
		System.out.println("Product data: " + product);
		
		System.out.println();
		System.out.print("Enter the number of products to be added in stock: ");
		int quantity = sc.nextInt();
		product.addProducts(quantity);
		
		System.out.println();
		System.out.println("Updated data: " + product);
		
		System.out.println();
		System.out.print("Enter the number of products to be removed from stock: ");
		quantity = sc.nextInt();
		product.removeProducts(quantity);
		
		System.out.println();
		System.out.println("Updated data: " + product);
		
		sc.close();
	}
}

```

#### <a name="chapter9part8"></a>Chapter 9 - Part 8: Third problem with object orientation

Make a program to read any numerical value, and then display what would be the value of a circle and the volume of a sphere for a radius of that value. Also inform the value of PI with two decimal places.

Ex:

Enter radius: 3.0
Circumference: 18.85
Volume: 113.10
PI value: 3.14

**Version 1**: methods in the program's own class. OBS: inside a static method you cannot call members of instance of the same class.

```java

import java.util.Locale;
import java.util.Scanner;

public class Program {
	
	public static final double PI = 3.14159;
	
	public static void main(String[] args) {
		
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		System.out.print("Enter radius: ");
		double radius = sc.nextDouble();
		
		double c = circumference(radius);
		
		double v = volume(radius);
		
		sc.close();
	}
	
	public static double circumference(double radius) {
		return 2.0 * PI * radius;
	}
	
	public static double volume(double radius) {
		return 4.0 * PI * radius * radius * radius / 3.0;
	}
}

```

**Version 2**: Calculator class with instance members

Class Calculator

```java

public class Calculator {
	
	public final double PI = 3.14159;
	
	public double circumference(double radius) {
		return 2.0 * PI * radius;
	}
	
	public double volume(double radius) {
		return 4.0 * PI * radius * radius * radius / 3.0;
	}

}

```

Program

```java

public class Program {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		Calculator calc = new Calculator();
		
		System.out.print("Enter radius: ");
		double radius = sc.nextDouble();
		
		double c = calc.circumference(radius);
		
		double v = calc.volume(radius);
		
		System.out.printf("Circumference: %.2f%n", c);
		System.out.printf("Volume: %.2f%n", v);
		System.out.printf("PI value: %.2f%n", calc.PI);
		
		sc.close();
	}
}

```

**Version 3**: Calculator class with static method

Class Calculator

```java

public class Calculator {
	
	public static final double PI = 3.14159;
	
	public static double circumference(double radius) {
		return 2.0 * PI * radius;
	}
	
	public static double volume(double radius) {
		return 4.0 * PI * radius * radius * radius / 3.0;
	}

}

```

```java

public class Program {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		System.out.print("Enter radius: ");
		double radius = sc.nextDouble();
		
		double c = Calculator.circumference(radius);
		
		double v = Calculator.volume(radius);
		
		System.out.printf("Circumference: %.2f%n", c);
		System.out.printf("Volume: %.2f%n", v);
		System.out.printf("PI value: %.2f%n", Calculator.PI);
		
		sc.close();
	}
}

```

#### <a name="chapter9part9"></a>Chapter 9 - Part 9: Constructors in Java

**Java Constructors**

A constructor in Java is a **special method** that is used to initialize objects.

Common uses:
- Start attribute values
- Allow or oblige the object to receive data / dependencies at the time of its instantiation (dependency injection)

If a custom constructor is not specified, the class provides the default constructor:
- ```Product p = new Product();```

It is possible to specify more than one constructor in the same class (overload):

The constructor is called when an object of a class is created. It can be used to set initial values for object attributes:

Create a constructor:

```java

// Create a Main class
public class Main {
  int x;  // Create a class attribute

  // Create a class constructor for the Main class
  public Main() {
    x = 5;  // Set the initial value for the class attribute x
  }

  public static void main(String[] args) {
    Main myObj = new Main(); // Create an object of class Main (This will call the constructor)
    System.out.println(myObj.x); // Print the value of x
  }
}

// Outputs 5

```

OBS1: Note that the constructor name must match the class name, and it cannot have a return type (like void).

OBS2: Also note that the constructor is called when the object is created.

OBS3: All classes have constructors by default: if you do not create a class constructor yourself, Java creates one for you. However, then you are not able to set initial values for object attributes.

**Constructor Parameters**

Constructors can also take parameters, which is used to initialize attributes.

The following example adds an ```int y``` parameter to the constructor. Inside the constructor we set x to y (x=y). When we call the constructor, we pass a parameter to the constructor (5), which will set the value of x to 5:

```java

public class Main {
  int x;

  public Main(int y) {
    x = y;
  }

  public static void main(String[] args) {
    Main myObj = new Main(5);
    System.out.println(myObj.x);
  }
}

// Outputs 5

```

You can have as many parameters as you want:

```java

public class Main {
  int modelYear;
  String modelName;

  public Main(int year, String name) {
    modelYear = year;
    modelName = name;
  }

  public static void main(String[] args) {
    Main myCar = new Main(1969, "Mustang");
    System.out.println(myCar.modelYear + " " + myCar.modelName);
  }
}

// Outputs 1969 Mustang

```

**Definition and Usage of ```this``` keyword**

The this keyword refers to the current object in a method or constructor.

The most common use of the ```this``` keyword is to eliminate the confusion between class attributes and parameters with the same name (because a class attribute is shadowed by a method or constructor parameter). If you omit the keyword in the example above, the output would be "0" instead of "5".

```this``` can also be used to:

- Invoke current class constructor
- Invoke current class method
- Return the current class object
- Pass an argument in the method call
- Pass an argument in the constructor call

Using ```this``` with a class attribute (x):

```java

public class Main {
  int x;

  // Constructor with a parameter
  public Main(int x) {
    this.x = x;
  }

  // Call the constructor
  public static void main(String[] args) {
    Main myObj = new Main(5);
    System.out.println("Value of x = " + myObj.x);
  }
}


```

```java

public class Product {

	public String name;
	public double price;
	public int quantity;
	
	public Product(String name, double price, int quantity) {
		this.name = name;
		this.price = price;
		this.quantity = quantity;
	}

	public double totalValueInStock() {
		return price * quantity;
	}

	public void addProducts(int quantity) {
		this.quantity += quantity;
	}

	public void removeProducts(int quantity) {
		this.quantity -= quantity;
	}
	
	public String toString() {
		return name
		+ ", $ "
		+ String.format("%.2f", price)
		+ ", "
		+ quantity
		+ " units, Total: $ "
		+ String.format("%.2f", totalValueInStock());
	}

}

```

**Overloading**

It is a feature that a class has to offer more than one operation with the same name, but with different lists of parameters.

```java

public class Product {

	public String name;
	public double price;
	public int quantity;
	
	public Product() {
	}
	
	public Product(String name, double price, int quantity) {
		this.name = name;
		this.price = price;
		this.quantity = quantity;
	}
	
	public Product(String name, double price) {
		this.name = name;
		this.price = price;
	}

	public double totalValueInStock() {
		return price * quantity;
	}

	public void addProducts(int quantity) {
		this.quantity += quantity;
	}

	public void removeProducts(int quantity) {
		this.quantity -= quantity;
	}
	
	public String toString() {
		return name
		+ ", $ "
		+ String.format("%.2f", price)
		+ ", "
		+ quantity
		+ " units, Total: $ "
		+ String.format("%.2f", totalValueInStock());
	}

}

```

#### <a name="chapter9part10"></a>Chapter 9 - Part 10: Modifiers in Java

By now, you are quite familiar with the ```public``` keyword that appears in almost all of our examples:

```java

public class Main

```

The ```public``` keyword is an **access modifier**, meaning that it is used to set the access level for classes, attributes, methods and constructors.

We divide modifiers into two groups:

- Access Modifiers - controls the access level
- Non-Access Modifiers - do not control access level, but provides other functionality

**Access Modifiers**

For **classes**, you can use either ```public``` or default:

| Modifier | Description                                                                                                   |
| :-------:| :------------------------------------------------------------------------------------------------------------:|
| public   | The class is accessible by any other class                                                                    |
| default  | The class is only accessible by classes in the same package. This is used when you don't specify a modifier.  | 

For **attributes, methods and constructors**, you can use the one of the following:

| Modifier   | Description                                                                                       |
| :---------:| :------------------------------------------------------------------------------------------------:|
| public     | The code is accessible for all classes                                                            |
| private    | The code is only accessible within the declared class                                             |
| default    | The code is only accessible in the same package. This is used when you don't specify a modifier.  | 
| protected  | The code is accessible in the same package and subclasses.                                        | 

<br>

<div align="center"><img src="img/modifiers-w1046-h434.png" width=1046 height=434><br><sub>Fig 32 - Modifiers in Java - (<a href='https://stackoverflow.com/questions/215497/what-is-the-difference-between-public-protected-package-private-and-private-in'>Work by  aioobe</a>) </sub></div>

<br>

**Non-Access Modifiers**

For **classes**, you can use either ```final``` or ```abstract```:

| Modifier  | Description                                                                                                       |
| :--------:| :----------------------------------------------------------------------------------------------------------------:|
| final     | The class cannot be inherited by other classes                                                                    |
| abstract  | The class cannot be used to create objects (To access an abstract class, it must be inherited from another class. | 

For **attributes and methods**, you can use the one of the following:

| Modifier      | Description                                                                                                       |
| :------------:| :----------------------------------------------------------------------------------------------------------------:|
| final         | Attributes and methods cannot be overridden/modified                                                                    |
| static        | Attributes and methods belongs to the class, rather than an object |
| abstract      | Can only be used in an abstract class, and can only be used on methods. The method does not have a body, for example **abstract void run();**. The body is provided by the subclass (inherited from).  | 
| transient     | Attributes and methods are skipped when serializing the object containing them | 
| synchronized  | Methods can only be accessed by one thread at a time | 
| volatile      | The value of an attribute is not cached thread-locally, and is always read from the "main memory" |

**Final**

If you don't want the ability to override existing attribute values, declare attributes as ```final```:

```java

public class Main {
  final int x = 10;
  final double PI = 3.14;

  public static void main(String[] args) {
    Main myObj = new Main();
    myObj.x = 50; // will generate an error: cannot assign a value to a final variable
    myObj.PI = 25; // will generate an error: cannot assign a value to a final variable
    System.out.println(myObj.x);
  }
}

```

**Static**

A ```static``` method means that it can be accessed without creating an object of the class, unlike ```public```:

An example to demonstrate the differences between ```static``` and ```public``` methods:

```java

public class Main {
  // Static method
  static void myStaticMethod() {
    System.out.println("Static methods can be called without creating objects");
  }

  // Public method
  public void myPublicMethod() {
    System.out.println("Public methods must be called by creating objects");
  }

  // Main method
  public static void main(String[ ] args) {
    myStaticMethod(); // Call the static method
    // myPublicMethod(); This would output an error

    Main myObj = new Main(); // Create an object of Main
    myObj.myPublicMethod(); // Call the public method
  }
}

```

**Abstract**

An ```abstract``` method belongs to an ```abstract``` class, and it does not have a body. The body is provided by the subclass:

```java

// Code from filename: Main.java
// abstract class
abstract class Main {
  public String fname = "John";
  public int age = 24;
  public abstract void study(); // abstract method
}

// Subclass (inherit from Main)
class Student extends Main {
  public int graduationYear = 2018;
  public void study() { // the body of the abstract method is provided here
    System.out.println("Studying all day long");
  }
}
// End code from filename: Main.java

// Code from filename: Second.java
class Second {
  public static void main(String[] args) {
    // create an object of the Student class (which inherits attributes and methods from Main)
    Student myObj = new Student();

    System.out.println("Name: " + myObj.fname);
    System.out.println("Age: " + myObj.age);
    System.out.println("Graduation Year: " + myObj.graduationYear);
    myObj.study(); // call abstract method
  }
}

```

#### <a name="chapter9part11"></a>Chapter 9 - Part 11: Encapsulation in Java

It is a principle consisting of hide implementation details of a class, exposing only safe operations and maintain objects in a consistent state.

Golden rule: the object must always be in a consistent state, and the class itself must guarantee this.

**An object must NOT expose any attributes (access modifier private)**

**Attributes must be accessed via get and set methods. [JavaBeans](https://en.wikipedia.org/wiki/JavaBeans)**

The meaning of Encapsulation, is to make sure that "sensitive" data is hidden from users. To achieve this, you must:

- declare class variables/attributes as ```private```.
- provide public get and set methods to access and update the value of a ```private``` variable

**Get and Set**

You learned from the previous chapter that ```private``` variables can only be accessed within the same class (an outside class has no access to it). However, it is possible to access them if we provide public get and set methods.

The ```get``` method returns the variable value, and the ```set``` method sets the value.

Syntax for both is that they start with either ```get``` or ```set```, followed by the name of the variable, with the first letter in upper case:

```java

public class Person {
  private String name; // private = restricted access

  // Getter
  public String getName() {
    return name;
  }

  // Setter
  public void setName(String newName) {
    this.name = newName;
  }
}

```

The ```get``` method returns the value of the variable ```name```.

The ```set``` method takes a parameter (```newName```) and assigns it to the ```name``` variable. The ```this``` keyword is used to refer to the current object.

However, as the ```name``` variable is declared as ```private```, we cannot access it from outside this class:

```java

public class Main {
  public static void main(String[] args) {
    Person myObj = new Person();
    myObj.name = "John";  // error
    System.out.println(myObj.name); // error 
  }
}


```

If the variable was declared as ```public```, we would expect the following output:

```John```

However, as we try to access a ```private``` variable, we get an error:

Instead, we use the ```getName()``` and ```setName()``` methods to access and update the variable:

```java

public class Main {
  public static void main(String[] args) {
    Person myObj = new Person();
    myObj.setName("John"); // Set the value of the name variable to "John"
    System.out.println(myObj.getName());
  }
}

// Outputs "John"

```

**Why Encapsulation?**

- Better control of class attributes and methods
- Class attributes can be made read-only (if you only use the ```get``` method), or write-only (if you only use the set method)
- Flexible: the programmer can change one part of the code without affecting other parts
- Increased security of data


```java

public class Product {

	private String name;
	private double price;
	private int quantity;
	
	public Product() {
	}
	
	public Product(String name, double price, int quantity) {
		this.name = name;
		this.price = price;
		this.quantity = quantity;
	}
	
	public Product(String name, double price) {
		this.name = name;
		this.price = price;
	}
	
	public String getName() {
		return name;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public double getPrice() {
		return price;
	}
	
	public void setPrice(double price) {
		this.price = price;
	}
	
	public int getQuantity() {
		return quantity;
	}

```

#### <a name="chapter9part12"></a>Chapter 9 - Part 12: Classes Composition in Java

It is a type of association that allows one object to contain another

"has-one" or "has-many" relationship

Advantages
- Organization: division of responsibilities
- Cohesion
- Flexibility
- Reuse

<br>

<div align="center"><img src="img/compostion1-w865-h453.png" width=865 height=453><br><sub>Fig 39 - Composition - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Exercise: Read data from a worker with N contracts (N provided by the user). then request a month and show the employee's salary in that month, as shown in the example

<br>

<div align="center"><img src="img/compostion2-w766-h399.png" width=766 height=399><br><sub>Fig 39 - Compostion Exercise - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

<div align="center"><img src="img/compostion3-w658-h553.png" width=658 height=553><br><sub>Fig 39 - Compostion Exercise - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Resolution:

**WorkerLevel Class (enum)**

```java

package entities.enums;

public enum WorkerLevel {

	JUNIOR,
	MID_LEVEL,
	SENIOR;
}

```

**Department Class**

```java

package entities;

public class Department {

	private String name;
	
	public Department() {
	}

	public Department(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}

```

**HourContract Class**

```java

package entities;

import java.util.Date;

public class HourContract {

	private Date date;
	private Double valuePerHour;
	private Integer hours;
	
	public HourContract() {
	}

	public HourContract(Date date, Double valuePerHour, Integer hours) {
		this.date = date;
		this.valuePerHour = valuePerHour;
		this.hours = hours;
	}

	public Date getDate() {
		return date;
	}

	public void setDate(Date date) {
		this.date = date;
	}

	public Double getValuePerHour() {
		return valuePerHour;
	}

	public void setValuePerHour(Double valuePerHour) {
		this.valuePerHour = valuePerHour;
	}

	public Integer getHours() {
		return hours;
	}

	public void setHours(Integer hours) {
		this.hours = hours;
	}
	
	public double totalValue() {
		return valuePerHour * hours;
	}
}

```

**Worker Class**

```java

package entities;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;

import entities.enums.WorkerLevel;

public class Worker {

	private String name;
	private WorkerLevel level;
	private Double baseSalary;
	
	private Department department;
	private List<HourContract> contracts = new ArrayList<>();
	
	public Worker() {
	}

	public Worker(String name, WorkerLevel level, Double baseSalary, Department department) {
		this.name = name;
		this.level = level;
		this.baseSalary = baseSalary;
		this.department = department;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public WorkerLevel getLevel() {
		return level;
	}

	public void setLevel(WorkerLevel level) {
		this.level = level;
	}

	public Double getBaseSalary() {
		return baseSalary;
	}

	public void setBaseSalary(Double baseSalary) {
		this.baseSalary = baseSalary;
	}

	public Department getDepartment() {
		return department;
	}

	public void setDepartment(Department department) {
		this.department = department;
	}

	public List<HourContract> getContracts() {
		return contracts;
	}

	public void addContract(HourContract contract) {
		contracts.add(contract);
	}
	
	public void removeContract(HourContract contract) {
		contracts.remove(contract);
	}
	
	public double income(int year, int month) {
		double sum = baseSalary;
		Calendar cal = Calendar.getInstance();
		for (HourContract c : contracts) {
			cal.setTime(c.getDate());
			int c_year = cal.get(Calendar.YEAR);
			int c_month = 1 + cal.get(Calendar.MONTH);
			if (year == c_year && month == c_month) {
				sum += c.totalValue();
			}
		}
		return sum;
	}
}

```

**Program**

```java

package application;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.Scanner;

import entities.Department;
import entities.HourContract;
import entities.Worker;
import entities.enums.WorkerLevel;

public class Program {

	public static void main(String[] args) throws ParseException {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
		
		System.out.print("Enter department's name: ");
		String departmentName = sc.nextLine();
		System.out.println("Enter worker data:");
		System.out.print("Name: ");
		String workerName = sc.nextLine();
		System.out.print("Level: ");
		String workerLevel = sc.nextLine();
		System.out.print("Base salary: ");
		double baseSalary = sc.nextDouble();
		Worker worker = new Worker(workerName, WorkerLevel.valueOf(workerLevel), baseSalary, new Department(departmentName));
		
		System.out.print("How many contracts to this worker? ");
		int n = sc.nextInt();
		
		for (int i=1; i<=n; i++) {
			System.out.println("Enter contract #" + i + " data:");
			System.out.print("Date (DD/MM/YYYY): ");
			Date contractDate = sdf.parse(sc.next());
			System.out.print("Value per hour: ");
			double valuePerHour = sc.nextDouble();
			System.out.print("Duration (hours): ");
			int hours = sc.nextInt();
			HourContract contract = new HourContract(contractDate, valuePerHour, hours);
			worker.addContract(contract);
		}
		
		System.out.println();
		System.out.print("Enter month and year to calculate income (MM/YYYY): ");
		String monthAndYear = sc.next();
		int month = Integer.parseInt(monthAndYear.substring(0, 2));
		int year = Integer.parseInt(monthAndYear.substring(3));
		System.out.println("Name: " + worker.getName());
		System.out.println("Department: " + worker.getDepartment().getName());
		System.out.println("Income for " + monthAndYear + ": " + String.format("%.2f", worker.income(year, month)));
		
		sc.close();
	}
}

```

#### <a name="chapter9part13"></a>Chapter 9 - Part 13: Inheritance in Java

It is an association type that allows a class to inherit all data and behaviors of another

- Benefits
  - reuse
  - Polymorphism
  
In Java, it is possible to inherit attributes and methods from one class to another. We group the "inheritance concept" into two categories:

- **subclass** (child) - the class that inherits from another class
- **superclass** (parent) - the class being inherited from

To inherit from a class, use the ```extends``` keyword.

Example: In the example below, the ```Car``` class (subclass) inherits the attributes and methods from the ```Vehicle``` class (superclass):

```java

class Vehicle {
  protected String brand = "Ford";        // Vehicle attribute
  public void honk() {                    // Vehicle method
    System.out.println("Tuut, tuut!");
  }
}

class Car extends Vehicle {
  private String modelName = "Mustang";    // Car attribute
  public static void main(String[] args) {

    // Create a myCar object
    Car myCar = new Car();

    // Call the honk() method (from the Vehicle class) on the myCar object
    myCar.honk();

    // Display the value of the brand attribute (from the Vehicle class) and the value of the modelName from the Car class
    System.out.println(myCar.brand + " " + myCar.modelName);
  }
}

```

Another Example: Suppose a banking business that has a common account and an account for companies, and the company account has all account members common plus a borrowing limit and a borrowing operation.

<br>

<div align="center"><img src="img/inheritance1-w774-h342.png" width=774 height=342><br><sub>Fig 40 - Inheritance - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>



Important Definitions:

- "is-a" relationship

- generalization/specialization

- Superclass (base class) / subclass (class derivative)

- inheritance / extension

- Inheritance is an association between classes (not between objects)

Class Account

```java

package entities;

public class Account {

	private Integer number;
	private String holder;
	protected Double balance;
		
	public Account() {
	}
	
	public Account(Integer number, String holder, Double balance) {
		this.number = number;
		this.holder = holder;
		this.balance = balance;
	}

	public Integer getNumber() {
		return number;
	}

	public void setNumber(Integer number) {
		this.number = number;
	}

	public String getHolder() {
		return holder;
	}

	public void setHolder(String holder) {
		this.holder = holder;
	}

	public Double getBalance() {
		return balance;
	}

	public void withdraw(double amount) {
		balance -= amount;
	}

	public void deposit(double amount) {
		balance += amount;
	}
}

```

Did you notice the ```protected``` modifier in ```Account```?

We set the ```balance``` attribute in ```Account``` to a ```protected``` access modifier. If it was set to ```private```, the ```BusinessAccount``` class would not be able to access it.

class BussinesAccount

```java

package entities;

public class BusinessAccount extends Account {

	private Double loanLimit;
	
	public BusinessAccount() {
		super();
	}

	public BusinessAccount(Integer number, String holder, Double balance, Double loanLimit) {
		super(number, holder, balance);
		this.loanLimit = loanLimit;
	}

	public Double getLoanLimit() {
		return loanLimit;
	}

	public void setLoanLimit(Double loanLimit) {
		this.loanLimit = loanLimit;
	}
	
	public void loan(double amount) {
		if (amount <= loanLimit) {
			balance += amount - 10.0;
		}
	}
}

```

Program

```java

package application;

import entities.BusinessAccount;

public class Program {

	public static void main(String[] args) {

		BusinessAccount account = new BusinessAccount(8010, "Bob Brown", 0.0, 500.0);

		System.out.println(account.getBalance());
	}
}

```

**Upcasting and downcasting**

- Upcasting
  - Casting from subclass to superclass
  - Common usage: polymorphism

- Downcasting
  - Casting from superclass to subclass
  - instanceof ```keyword```
  - Common usage: methods that take generic parameters (ex: Equals)
  
Example:

<br>

<div align="center"><img src="img/updowncasting-w493-h400.png" width=493 height=400><br><sub>Fig 41 - Upcasting and Downcasting - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Class SavingsAccount

```java

package entities;

public class SavingsAccount extends Account {
	
	private Double interestRate;
	
	public SavingsAccount() {
		super();
	}

	public SavingsAccount(Integer number, String holder, Double balance, Double interestRate) {
		super(number, holder, balance);
		this.interestRate = interestRate;
	}

	public Double getInterestRate() {
		return interestRate;
	}

	public void setInterestRate(Double interestRate) {
		this.interestRate = interestRate;
	}
	
	public void updateBalance() {
		balance += balance * interestRate;
	}
}

```

Program

```java

package application;

import entities.Account;
import entities.BusinessAccount;
import entities.SavingsAccount;

public class Program {

	public static void main(String[] args) {

		Account acc = new Account(1001, "Alex", 0.0);
		BusinessAccount bacc = new BusinessAccount(1002, "Maria", 0.0, 500.0);
		
		// UPCASTING
		
		Account acc1 = bacc;
		Account acc2 = new BusinessAccount(1003, "Bob", 0.0, 200.0);
		Account acc3 = new SavingsAccount(1004, "Anna", 0.0, 0.01);
		
		// DOWNCASTING
		
		BusinessAccount acc4 = (BusinessAccount)acc2;
		acc4.loan(100.0);
		
		// BusinessAccount acc5 = (BusinessAccount)acc3;
		if (acc3 instanceof BusinessAccount) {
			BusinessAccount acc5 = (BusinessAccount)acc3;
			acc5.loan(200.0);
			System.out.println("Loan!");
		}
		
		if (acc3 instanceof SavingsAccount) {
			SavingsAccount acc5 = (SavingsAccount)acc3;
			acc5.updateBalance();
			System.out.println("Update!");
		}
	}
}

```

**Override**

- It is the implementation of a method of a superclass in the subclass
- It is strongly recommended to use the @Override annotation in a method envelope
  - Facilitates reading and understanding of code
  - We notify the compiler (good practice)

class Account

```Java

public void withdraw(double amount) {
	balance -= amount + 5.0;
}

```

SavingsAccount

```java

@Override
public void withdraw(double amount) {
	balance -= amount;
}

```

**Keyword Super**

You can call the superclass implementation using the word super.

Example: suppose that, in the BusinessAccount class, the rule for withdrawal is to perform the draw normally from the superclass, and deduct another 2.0.

In this case, the withdraw method is the same, but with one moddification in the BissinesAccount class, because is tho only diference.

Class BissinesAccount

```java

@Override
public void withdraw(double amount) {
	super.withdraw(amount);
	balance -= 2.0;
}

```

**Keyword Final**

If you don't want other classes to inherit from a class, use the ```final``` keyword:

Example: If you try to access a ```final``` class, Java will generate an error:

```java

final class Vehicle {
  ...
}

class Car extends Vehicle {
  ...
}

// Main.java:9: error: cannot inherit from final Vehicle
//class Main extends Vehicle {
//                  ^
// 1 error)

```

You can use in method. In this case prevents the method under from being overridden

Example: Suppose you don't want the Withdraw method of SavingsAccount is overridden

```java

@Override
public final void withdraw(double amount) {
	balance -= amount;
}

```

why use final?

- Security: Depending on business rules, it is sometimes desirable ensure that a class is not inherited, or that a method is not be superimposed.
  - It is generally convenient to add final in overlapping methods, as Multiple overlays can be a gateway to inconsistencies

- Performance: type attributes of a final class are parsed accordingly. faster at runtime.
  - Classic example: String

#### <a name="chapter9part14"></a>Chapter 9 - Part 14: Polymorphism in Java

In Object Oriented Programming, polymorphism is a resource that allows variables of the same more generic type to be point to objects of different specific types, thus having different behaviors depending on each specific type.

```java

Account x = new Account(1020, "Alex", 1000.0);
Account y = new SavingsAccount(1023, "Maria", 1000.0, 0.01);

x.withdraw(50.0);
y.withdraw(50.0);

```

Another Example:

For example, think of a superclass called ```Animal``` that has a method called ```animalSound()```. Subclasses of Animals could be Pigs, Cats, Dogs, Birds - And they also have their own implementation of an animal sound (the pig oinks, and the cat meows, etc.):

```java

class Animal {
  public void animalSound() {
    System.out.println("The animal makes a sound");
  }
}

class Pig extends Animal {
  public void animalSound() {
    System.out.println("The pig says: wee wee");
  }
}

class Dog extends Animal {
  public void animalSound() {
    System.out.println("The dog says: bow wow");
  }
}

```
Now we can create ```Pig``` and ```Dog``` objects and call the ```animalSound()``` method on both of them:

```java

class Animal {
  public void animalSound() {
    System.out.println("The animal makes a sound");
  }
}

class Pig extends Animal {
  public void animalSound() {
    System.out.println("The pig says: wee wee");
  }
}

class Dog extends Animal {
  public void animalSound() {
    System.out.println("The dog says: bow wow");
  }
}

class Main {
  public static void main(String[] args) {
    Animal myAnimal = new Animal();  // Create a Animal object
    Animal myPig = new Pig();  // Create a Pig object
    Animal myDog = new Dog();  // Create a Dog object
    myAnimal.animalSound();
    myPig.animalSound();
    myDog.animalSound();
  }
}

```

Why And When To Use "Inheritance" and "Polymorphism"?

- It is useful for code reusability: reuse attributes and methods of an existing class when you create a new class.

Exercise:  A company has its own and outsourced employees. For each employee, you want to record name, hours worked and hourly rate. outsourced employees have an additional expense.

Employee pay corresponds to the hourly rate multiplied by the hours worked, with the outsourced employees still receive a bonus corresponding to 110% of your additional expense.

Write a program to read the data of N employees (N provided by the user) and store them in a list. Later to read all data, show name and payment of each employee in the same order they were entered.

Build the program according to the project on the side. Look example on the next page.

<br>

<div align="center"><img src="img/polymorphism1-w383-h532.png" width=383 height=532><br><sub>Fig 42 - Exercise Polymorphism - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

<div align="center"><img src="img/polymorphism2-w384-h461.png" width=383 height=461><br><sub>Fig 43 - Exercise Polymorphism - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Class Employee

```java

package entities;

public class Employee {

	private String name;
	private Integer hours;
	private Double valuePerHour;
	
	public Employee() {
	}

	public Employee(String name, Integer hours, Double valuePerHour) {
		this.name = name;
		this.hours = hours;
		this.valuePerHour = valuePerHour;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Integer getHours() {
		return hours;
	}

	public void setHours(Integer hours) {
		this.hours = hours;
	}

	public Double getValuePerHour() {
		return valuePerHour;
	}

	public void setValuePerHour(Double valuePerHour) {
		this.valuePerHour = valuePerHour;
	}
	
	public double payment() {
		return hours * valuePerHour;
	}
}

```

Class OutsourcedEmployee

```java

package entities;

public class OutsourcedEmployee extends Employee {

	private Double additionalCharge;

	public OutsourcedEmployee() {
		super();
	}
	
	public OutsourcedEmployee(String name, Integer hours, Double valuePerHour, Double additionalCharge) {
		super(name, hours, valuePerHour);
		this.additionalCharge = additionalCharge;
	}

	public Double getAdditionalCharge() {
		return additionalCharge;
	}

	public void setAdditionalCharge(Double additionalCharge) {
		this.additionalCharge = additionalCharge;
	}
	
	@Override
	public double payment() {
		return super.payment() + additionalCharge * 1.1;
	}
}

```

Program

```java

package application;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Scanner;

import entities.Employee;
import entities.OutsourcedEmployee;

public class Program {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		List<Employee> list = new ArrayList<>();
		
		System.out.print("Enter the number of employees: ");
		int n = sc.nextInt();
		
		for (int i=1; i<=n; i++) {
			System.out.println("Employee #" + i + " data:");
			System.out.print("Outsourced (y/n)? ");
			char ch = sc.next().charAt(0);
			System.out.print("Name: ");
			sc.nextLine();
			String name = sc.nextLine();
			System.out.print("Hours: ");
			int hours = sc.nextInt();
			System.out.print("Value per hour: ");
			double valuePerHour = sc.nextDouble();
			//OBS: A List of Employee can add Employe or OutsourcedEmploye (polymorphism)
			if (ch == 'y') {
				System.out.print("Additional charge: ");
				double additionalCharge = sc.nextDouble();
				list.add(new OutsourcedEmployee(name, hours, valuePerHour, additionalCharge));
			}
			else {
				list.add(new Employee(name, hours, valuePerHour));
			}
		}
		
		System.out.println();
		System.out.println("PAYMENTS:");
		for (Employee emp : list) {
			System.out.println(emp.getName() + " - $ " + String.format("%.2f", emp.payment()));
		}
		
		sc.close();
	}
}

```

#### <a name="chapter9part15"></a>Chapter 9 - Part 15: Abstraction Class and methods

Data **abstraction** is the process of hiding certain details and showing only essential information to the user.
Abstraction can be achieved with either **abstract classes** or **interfaces** (which you will learn more about in the next chapter).

The ```abstract``` keyword is a non-access modifier, used for classes and methods:
- **Abstract class**: is a restricted class that cannot be used to create objects (to access it, it must be inherited from another class).
- **Abstract method**: can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from).

NOTE: In UML is Italic

An abstract class can have both abstract and regular methods:

```java

abstract class Animal {
  public abstract void animalSound();
  public void sleep() {
    System.out.println("Zzz");
  }
}

```

From the example above, it is not possible to create an object of the Animal class:

```java

Animal myObj = new Animal(); // will generate an error

```

To access the abstract class, it must be inherited from another class. Let's convert the Animal class we used in the Polymorphism chapter to an abstract class:

Remember from the Inheritance chapter that we use the extends keyword to inherit from a class.

```java

// Abstract class
abstract class Animal {
  // Abstract method (does not have a body)
  public abstract void animalSound();
  // Regular method
  public void sleep() {
    System.out.println("Zzz");
  }
}

// Subclass (inherit from Animal)
class Pig extends Animal {
  public void animalSound() {
    // The body of animalSound() is provided here
    System.out.println("The pig says: wee wee");
  }
}

class Main {
  public static void main(String[] args) {
    Pig myPig = new Pig(); // Create a Pig object
    myPig.animalSound();
    myPig.sleep();
  }
}

```

NOTE:  If a class has at least one method abstract, so this class is also abstract

Why And When To Use Abstract Classes and Methods?

To achieve security - hide certain details and only show the important details of an object.

Note: Abstraction can also be achieved with Interfaces, which you will learn more about in the next chapter.

Exercise: Write a program to read data from N figures (N provided by the user), and then show the areas of these figures in the same order in which they were entered.

<br>

<div align="center"><img src="img/abstraction-w1062-h461.png" width=1062 height=461><br><sub>Fig 44 - Exercise Abstraction - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Class Color

```java

package entities.enums;

public enum Color {
	BLACK,
	BLUE,
	RED;
}

```

Class Shape

```java

package entities;

import entities.enums.Color;

public abstract class Shape {

	private Color color;
	
	public Shape() {
	}
	
	public Shape(Color color) {
		this.color = color;
	}

	public Color getColor() {
		return color;
	}

	public void setColor(Color color) {
		this.color = color;
	}
	
	public abstract double area(); //OBS: when you put abstract in the method, you are obligated to put abstract in the class Shape
}

```

Class Circle

```java

package entities;

import entities.enums.Color;

public class Circle extends Shape {

	private Double radius;
	
	public Circle() {
		super();
	}
	
	public Circle(Color color, Double radius) {
		super(color);
		this.radius = radius;
	}

	public Double getRadius() {
		return radius;
	}

	public void setRadius(Double radius) {
		this.radius = radius;
	}

	@Override
	public double area() {
		return Math.PI * radius * radius;
	}
}

```

Class Retangle

```java

package entities;

import entities.enums.Color;

public class Rectangle extends Shape {

	private Double width;
	private Double height;
	
	public Rectangle() {
		super();
	}

	public Rectangle(Color color, Double width, Double height) {
		super(color);
		this.width = width;
		this.height = height;
	}

	public Double getWidth() {
		return width;
	}

	public void setWidth(Double width) {
		this.width = width;
	}

	public Double getHeight() {
		return height;
	}

	public void setHeight(Double height) {
		this.height = height;
	}

	@Override
	public double area() {
		return width * height;
	}
}

```

Program

```java

package application;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Scanner;

import entities.Shape;
import entities.Rectangle;
import entities.Circle;
import entities.enums.Color;

public class Program {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		List<Shape> list = new ArrayList<>();
		
		System.out.print("Enter the number of shapes: ");
		int n = sc.nextInt();
		
		for (int i=1; i<=n; i++) {
			System.out.println("Shape #" + i + " data:");
			System.out.print("Rectangle or Circle (r/c)? ");
			char ch = sc.next().charAt(0);
			System.out.print("Color (BLACK/BLUE/RED): ");
			Color color = Color.valueOf(sc.next());
			if (ch == 'r') {
				System.out.print("Width: ");
				double width = sc.nextDouble();
				System.out.print("Height: ");
				double height = sc.nextDouble();
				list.add(new Rectangle(color, width, height));
			}
			else {
				System.out.print("Radius: ");
				double radius = sc.nextDouble();
				list.add(new Circle(color, radius));
			}
		}
		
		System.out.println();
		System.out.println("SHAPE AREAS:");
		for (Shape shape : list) {
			System.out.println(String.format("%.2f", shape.area()));
		}
		
		sc.close();
	}
}

```

## <a name="chapter10"></a>Chapter 10: Reference Type vs. Value Types, Garbage Collector, Boxing, unboxing and wrapper classes

#### <a name="chapter10part1"></a>Chapter 10 - Part 1: Reference Type vs. Value Types

Java provides two types of data types **primitive** and **reference** data type. The **primitive data types (value type)** are predefined in Java that serves as a fundamental building block while the **reference** data type refers to where data is stored.

<br>

<div align="center"><img src="img/data-types-w8000-h4500.png" width=600 height=350><br><sub>Fig 13 -Java Data Types - (<a href='https://getkt.com/blog/reintroduction-to-java-data-types/'>Work by neotam</a>) </sub></div>

<br>

**Reference types**

In Java, **non-primitive** data types are known as **reference types**. In other words, a variable of class type is called **reference data type**. It contains the address (or reference) of dynamically created objects. For example, if **Demo** is a class and we have created its object **d**, then the variable d is known as a reference type.

It refers to objects. It is not pre-defined. It is created by the programmer if required. The reference types hold the references of objects. All **reference types** are a subclass of type **java.lang.Object**. It provides access to the objects stored in the memory.

Example: In the example above the p2 variable refence the memory address where p1 was created.

```java

Product p1, p2;
p1 = new Product("TV", 900.00, 0);
p2 = p1;

```

<br>

<div align="center"><img src="img/referency_memory-w681-h362.png" width=681 height=362><br><sub>Fig 34 -Referency Types - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by Nelio Alves</a>) </sub></div>

<br>

The default values when we use ```new``` in Class and Arrays is:

- Numbers: 0
- boolean: false
- char: 0 code
- object: null

Reference type alow "null" value. This means they not reference any body.

**Primitive types**

In Java, primitive types is value types.

Example: y receive a copy of x

```java

double x, y;
x = 10;
y = x;

```

The primitive types needs a value to initiate:

```java

int p;
System.out.println(p); // error: variable not initiated

p = 10;
System.out.println(p);

```

<br>

<div align="center"><img src="img/primitive_memory-w641-h378.png" width=641 height=378><br><sub>Fig 35 -Primitive Types - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by Nelio Alves</a>) </sub></div>

<br>

<br>

<div align="center"><img src="img/data-types2-w1920-h1080.jpg" width=600 height=300><br><sub>Fig 14 -Java Data Primitive Types - (<a href='https://getkt.com/blog/reintroduction-to-java-data-types/'>Work by neotam</a>) </sub></div>

<br>

| Reference Type                                                                 | Primitive Type                                                         |
| :-----------------------------------------------------------------------------:| :---------------------------------------------------------------------:|
| It is not pre-defined except the String.                                       | It is pre-defined in Java.                                             |
| All reference type begins with Uppercase letter.                               | All primitive type begins with a lowercase letter.                     | 
| Non-primitive types have all the same size.                                    | The size of a primitive type depends on the data type.                 |
| It is used to invoke or call methods.                                          | We cannot invoke the method with a primitive type.                     |
| It can be null.                                                                | It cannot be null. It always has value.                                |
| Examples of reference data types are class, Arrays, String, Interface, etc.    | Examples of primitive data types are int, float, double, Boolean, long.|
| JVM allocates 8 bytes for each reference variable, by default.                 | Its size depends on the data type.                                     |
| **Example**: Demo d1;                                                          | **Example**: int num=78;                                               |
| Advantage: enjoys all OO features                                              | Advantage: it is simpler and more performant                           |
| Objects must be instantiated using new, or point to an existing object.        | Does not instantiate. Once declared, they are ready for use.           |
| Accepts null value                                                             | Does not accept null value                                             |
| Y = X; "Y starts pointing to where X points Y = X;                             | Y = X; "Y receives a copy of X"                                        |
| Objects instantiated on the heap                                               | "Objects" instantiated on the stack                                    |
| Unused objects are deallocated in a close moment by garbage collector          | "Objects" are deallocated immediately when your execution scope is terminated   |

#### <a name="chapter10part2"></a>Chapter 10 - Part 2: Garbage Collector

In Java, the ```new``` keyword is used to create an **instance** of the class. In other words, it instantiates a class by allocating **memory** for a new object and returning a reference to that memory. Objects occupy memory in the **Java heap space**. We can also use the ```new``` keyword to create the array object.

```java

ClassName objectName = new ClassName();  

```

If there are no references to an object, the memory used by that object can be reclaimed during the garbage collection process.

**Garbage Collector

It is a process that automates the memory management of a program running

Garbage collector monitors dynamically allocated objects by the program (on the heap), deallocating those that are no longer being used.

In java, garbage means unreferenced objects.

Garbage Collection is process of reclaiming the runtime unused memory automatically. In other words, it is a way to destroy the unused objects.

To do so, we were using free() function in C language and delete() in C++. But, in java it is performed automatically. So, java provides better memory management.

**Advantage of Garbage Collection**

- It makes java memory efficient because garbage collector removes the unreferenced objects from heap memory.

- It is automatically done by the garbage collector(a part of JVM) so we don't need to make extra efforts.

**How can an object be unreferenced?**

- By nulling the reference

```java

    Employee e=new Employee();  
    e=null;  

```

- By assigning a reference to another

```java

    Employee e1=new Employee();  
    Employee e2=new Employee();  
    e1=e2;//now the first object referred by e1 is available for garbage collection  

```

- By anonymous object etc.

```java

    new Employee();  

```

**finalize() method**

The finalize() method is invoked each time before the object is garbage collected. This method can be used to perform cleanup processing. This method is defined in Object class as:

```java

    protected void finalize(){}  

```

OBS: The Garbage collector of JVM collects only those objects that are created by new keyword. So if you have created any object without new, you can use finalize method to perform cleanup processing (destroying remaining objects).

**gc() method**

The gc() method is used to invoke the garbage collector to perform cleanup processing. The gc() is found in System and Runtime classes. 

```java

    public static void gc(){}  

```

OBS: Garbage collection is performed by a daemon thread called Garbage Collector(GC). This thread calls the finalize() method before object is garbage collected.

```java

    public class TestGarbage1{  
     public void finalize(){System.out.println("object is garbage collected");}  
     public static void main(String args[]){  
      TestGarbage1 s1=new TestGarbage1();  
      TestGarbage1 s2=new TestGarbage1();  
      s1=null;  
      s2=null;  
      System.gc();  
     }  
    }  
    
    //object is garbage collected
    //object is garbage collected

```

#### <a name="chapter10part3"></a>Chapter 10 - Part 3: Boxing, unboxing and wrapper classes

**Boxing**

It is the process of converting a value type object to an object compatible reference type

```java

int x = 20;

Object obj = x;

```

**Unboxing**

It is the process of converting a reference-type object to a object type compatible value

```java

int x = 20;

Object obj = x;

int y = (int) obj;

```

**Comparing Reference Type**

Reference types are comparable in Java. Equality operators and the equals method can be used to assist with comparisons.

- Using the Equality Operators ```(==)```

The ```!=``` and ```==``` equality operators are used to compare the memory locations of two objects. If the memory addresses of the objects being compared are the same, the objects are considered equal. These equality operators are not used to compare the contents of two objects.

```java

String guest1 = new String("name");
String guest2 = guest1;
if (guest1 == guest2)
  System.out.println("They are equal");

```

In the following example, the memory addresses are not equal, so the statement "They are not equal" is output:

```java

String guest1 = new String("name");
String guest2 = new String("name");
if (guest1 != guest2)
  System.out.println("They are not equal");


```

- Using the ```equals()``` Method

To compare the contents of two class objects, the ```equals()``` method from class ```Object``` can be used or overridden. When the ```equals()``` method is overridden, the ```hashCode()``` method should also be overridden. This is done for compatibility with hash-based collections such as ```HashMap()``` and ```HashSet()```.

By default, the ```equals()``` method uses only the ```==``` operator for comparisons. This method has to be overridden to really be useful.

For example, if you want to compare values contained in two instances of the same class, you should use a programmer-defined equals() method.

**Comparing Strings**

There are two ways to check whether strings are equal in Java, but the definition of “equal” for each of them is different:

- The ```equals()``` method compares two strings, character by character, to determine equality. This is not the default implementation of the ```equals()``` method provided by the Object class. This is the overridden implementation provided by String class.

- The ```==``` operator checks to see whether two object references refer to the same instance of an object.

Here is a program that shows how strings are evaluated using the ```equals()``` method and the ```==``` operator

```java

class MyComparisons {

  // Add string to pool
  String first = "chairs";
  // Use string from pool
  String second = "chairs";
  // Create a new string
  String third = new String ("chairs");

 void myMethod() {

  /*
   * Contrary to popular belief, this evaluates
   * to true. Try it!
   */
  if (first == second) {
    System.out.println("first == second");
  }

  // This evaluates to true
  if (first.equals(second)) {
    System.out.println("first equals second");
  }
  // This evaluates to false
  if (first == third) {
    System.out.println("first == third");
  }
  // This evaluates to true
  if (first.equals(third)) {
    System.out.println("first equals third");
  }
 } // End myMethod()
} //end class

```


**Wrapper Classes**

These are classes that are equivalent to primitive types.

Boxing and unboxing is done automaticaly

Common usage: Entity fields in information systems (IMPORTANT!)
Because reference types (classes) accept null value and take advantage of Object Oriented resources

<br>

<div align="center"><img src="img/wrapper_classes-w541-h251.png" width=541 height=251><br><sub>Fig 37 - Wrapper Classes - (<a href='https://www.javatpoint.com/collections-in-java'>Work by  Java T Point</a>) </sub></div>

<br>

#### <a name="chapter10part4"></a>Chapter 10 - Part 4: hashCode and equals

**hashCode and equals**

- They are operations of the Object class used to compare if an object is the same as another
- equals: slow, 100% response
- hashCode: fast, but positive response is not 100%
- Common types (String, Date, Integer, Double, etc.) already have implementation for these operations. custom classes need to overlay them.

**Equals**

- Method that compares if the object is equal to another, returning true or false.

```java

String a = "Maria";
String b = "Alex";

System.out.println(a.equals(b)); //false

```

```java

String a = "Maria";
String b = "Naria";

System.out.println(a.equals(b)); //true

```

**HashCode**

- Method that returns an integer representing a generated code from object information

```java

String a = "Maria";
String b = "Alex";

System.out.println(a.hashCode()); //74113750
System.out.println(b.hashCode()); //2043454

```

```java

String a = "Maria";
String b = "Maria";

System.out.println(a.hashCode()); //74113750
System.out.println(b.hashCode()); //74113750

```

If the hashCode of two objects is different, then the two objects are many different

If the code of two objects is the same, most likely the objects they are the same

## <a name="chapter11"></a>Chapter 11: Collections

<br>

<div align="center"><img src="img/java_collection-w854-h715.png" width=854 height=715><br><sub>Fig 36 - Collections - (<a href='https://www.javatpoint.com/collections-in-java'>Work by  Java T Point</a>) </sub></div>

<br>

#### <a name="chapter11part1"></a>Chapter 11 - Part 1: ArrayList

ArrayList is a data Structure:
- Homogeneous (data of the same type)
- Ordered (elements accessed through positions)
- Starts empty, and its elements are allocated on demand
- Each element occupies a "node" (or node) of the list

Type (interface): List

Implementing classes: ArrayList, LinkedList, etc

Advantages:
- Variable Size
- Ease of insertion and deletion

Disadvantages:
- Fixed Size
- Sequential access to elements -> In the case of ArrayList, they are otimizaded

**Java ArrayList**

The ```ArrayList``` class is a resizable array, which can be found in the ```java.util``` package.

The difference between a built-in array and an ```ArrayList``` in Java, is that the size of an array cannot be modified (if you want to add or remove elements to/from an array, you have to create a new one). While elements can be added and removed from an ```ArrayList``` whenever you want. The syntax is also slightly different:

```java

import java.util.ArrayList; // import the ArrayList class

ArrayList<String> cars = new ArrayList<String>(); // Create an ArrayList object

```

- Add Items

The ```ArrayList``` class has many useful methods. For example, to add elements to the ```ArrayList```, use the ```add()``` method:

```java

import java.util.ArrayList;

public class Main {
  public static void main(String[] args) {
    ArrayList<String> cars = new ArrayList<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    cars.add("Mazda");
    System.out.println(cars);
  }
}

```

- Access an Item

To access an element in the ```ArrayList```, use the ```get()``` method and refer to the index number:

```java

cars.get(0);

```

- Change an Item

To modify an element, use the ```set()``` method and refer to the index number:

```java

cars.set(0, "Opel");

```

- Remove an Item

To remove an element, use the ```remove()``` method and refer to the index number:

```java

cars.remove(0);

```

To remove all the elements in the ```ArrayList```, use the ```clear()``` method:

```java

cars.clear();

```

- ArrayList Size

To find out how many elements an ArrayList have, use the ```size``` method:

```java

cars.size();

```

- Loop Through an ArrayList

Loop through the elements of an ```ArrayList``` with a ```for``` loop, and use the ```size()``` method to specify how many times the loop should run:

```java

public class Main {
  public static void main(String[] args) {
    ArrayList<String> cars = new ArrayList<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    cars.add("Mazda");
    for (int i = 0; i < cars.size(); i++) {
      System.out.println(cars.get(i));
    }
  }
}


```

You can also loop through an ArrayList with the for-each loop:

```java

public class Main {
  public static void main(String[] args) {
    ArrayList<String> cars = new ArrayList<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    cars.add("Mazda");
    for (String i : cars) {
      System.out.println(i);
    }
  }
}


```

- Other Types

Elements in an ArrayList are actually objects. In the examples above, we created elements (objects) of type "String". Remember that a String in Java is an object (not a primitive type). To use other types, such as int, you must specify an equivalent wrapper class: ```Integer```. For other primitive types, use: ```Boolean``` for boolean, ```Character``` for char, ```Double``` for double, etc:

```java

import java.util.ArrayList;

public class Main {
  public static void main(String[] args) {
    ArrayList<Integer> myNumbers = new ArrayList<Integer>();
    myNumbers.add(10);
    myNumbers.add(15);
    myNumbers.add(20);
    myNumbers.add(25);
    for (int i : myNumbers) {
      System.out.println(i);
    }
  }
}


```

- Sort an ArrayList

Another useful class in the ```java.util``` package is the ```Collections``` class, which include the ```sort()``` method for sorting lists alphabetically or numerically:

Example: Sort an ArrayList of Strings:

```java

import java.util.ArrayList;
import java.util.Collections;  // Import the Collections class

public class Main {
  public static void main(String[] args) {
    ArrayList<String> cars = new ArrayList<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    cars.add("Mazda");
    Collections.sort(cars);  // Sort cars
    for (String i : cars) {
      System.out.println(i);
    }
  }
}


```

Example: Sort an ArrayList of Integers:

```java

import java.util.ArrayList;
import java.util.Collections;  // Import the Collections class

public class Main {
  public static void main(String[] args) {
    ArrayList<Integer> myNumbers = new ArrayList<Integer>();
    myNumbers.add(33);
    myNumbers.add(15);
    myNumbers.add(20);
    myNumbers.add(34);
    myNumbers.add(8);
    myNumbers.add(12);

    Collections.sort(myNumbers);  // Sort myNumbers

    for (int i : myNumbers) {
      System.out.println(i);
    }
  }
}


```

```java

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class Program {

	public static void main(String[] args) {

		List<String> list = new ArrayList<>();

		list.add("Maria");
		list.add("Alex");
		list.add("Bob");
		list.add("Anna");
		list.add(2, "Marco");

		System.out.println(list.size()); // 5
		for (String x : list) {
			System.out.println(x); // Maria Alex Marco Bob Anna
		}
		System.out.println("---------------------");
		list.removeIf(x -> x.charAt(0) == 'M');
		for (String x : list) {
			System.out.println(x); // Alex Bob Anna
		}
		System.out.println("---------------------");
		System.out.println("Index of Bob: " + list.indexOf("Bob")); // -1
		System.out.println("Index of Marco: " + list.indexOf("Marco")); // -1
		System.out.println("---------------------");
		List<String> result = list.stream().filter(x -> x.charAt(0) == 'A').collect(Collectors.toList());
		for (String x : result) {
			System.out.println(x); //Alex Anna
		}
		System.out.println("---------------------");
		String name = list.stream().filter(x -> x.charAt(0) == 'J').findFirst().orElse(null);
		System.out.println(name); //null
	}
}

```

Exercise: Make a program to read an integer N and then the data (id, name and salary) of N employees. There should be no repetition of id

Then, increase the salary of a given employee by X percent. For this, the program must read an id and the value X. If the informed id does not exist, display a message and abort the operation. At the end, show the updated list of employees, according to examples.

Remember to apply the encapsulation technique to not allow the salary to be changed freely. A salary can only be increased on the basis of a increase by given percentage

<br>

<div align="center"><img src="img/arraylist_exercise-w677-h786.png" width=677 height=786><br><sub>Fig 37 - ArrayList Exercise - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Neilo Alves</a>) </sub></div>

<br>

<div align="center"><img src="img/arraylist1_exercise-w428-h179.png" width=428 height=179><br><sub>Fig 38 - ArrayList Exercise - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Class Employe

```java

public class Employee {

	private Integer id;
	private String name;
	private Double salary;
	
	public Employee() {
	}
	
	public Employee(Integer id, String name, Double salary) {
		this.id = id;
		this.name = name;
		this.salary = salary;
	}

	public Integer getId() {
		return id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Double getSalary() {
		return salary;
	}

	public void setSalary(Double salary) {
		this.salary = salary;
	}
	
	public void increaseSalary(double percentage) {
		salary += salary * percentage / 100.0;
	}
	
	public String toString() {
		return id + ", " + name + ", " + String.format("%.2f", salary);
	}
}

```

Program

```java

package application;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Scanner;

import entities.Employee;

public class Program {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		List<Employee> list = new ArrayList<>();
		
		// PART 1 - READING DATA:
		
		System.out.print("How many employees will be registered? ");
		int n = sc.nextInt();
		
		for (int i=1; i<=n; i++) {
			System.out.println();
			System.out.println("Employee #" + i + ": ");

			System.out.print("Id: ");
			int id = sc.nextInt();
			while (hasId(list, id)) {
				System.out.print("Id already taken. Try again: ");
				id = sc.nextInt();
			}
			
			System.out.print("Name: ");
			sc.nextLine();
			String name = sc.nextLine();
			System.out.print("Salary: ");
			double salary = sc.nextDouble();
			list.add(new Employee(id, name, salary));
		}

		// PART 2 - UPDATING SALARY OF GIVEN EMPLOYEE:
		
		System.out.println();
		System.out.print("Enter the employee id that will have salary increase: ");
		int id = sc.nextInt();
		Employee emp = list.stream().filter(x -> x.getId() == id).findFirst().orElse(null);
		if (emp == null) {
			System.out.println("This id does not exist!");
		}
		else {
			System.out.print("Enter the percentage: ");
			double percentage = sc.nextDouble();
			emp.increaseSalary(percentage);
		}
		
		// PART 3 - LISTING EMPLOYEES:
		
		System.out.println();
		System.out.println("List of employees:");
		for (Employee obj : list) {
			System.out.println(obj);
		}
				
		sc.close(); 
	}
	
	public static boolean hasId(List<Employee> list, int id) {
		Employee emp = list.stream().filter(x -> x.getId() == id).findFirst().orElse(null);
		return emp != null;
	}
}

```

#### <a name="chapter11part2"></a>Chapter 12 - Part 2: HashMap

- It is a collection of key/value pairs
  - Does not support key object repetitions
  - Elements are indexed by the key object (have no position)
  - Accessing, inserting and removing elements is fast

- Common usage: cookies, local storage, any key-value model

- Main implementations:
  - HashMap: faster (O(1) operations on hash table) and unordered
  - TreeMap: slower (O(log(n)) operations in red-black tree) and sorted by object compareTo (or Comparator)
  - LinkedHashMap: intermediate speed and elements in the order they are added

**Some important methods**

- put(key, value), remove(key), containsKey(key), get(key)
  - Based on equals and hashCode
  - If equals and hashCode do not exist, pointer comparison is used

- clear()

- size()

- keySet(): return a Set<K>

- values(): return a Collection<V>

	
In the ```ArrayList``` chapter, you learned that Arrays store items as an ordered collection, and you have to access them with an index number (```int``` type). A ```HashMap``` however, store items in "**key/value**" pairs, and you can access them by an index of another type (e.g. a ```String```).
	
One object is used as a key (index) to another object (value). It can store different types: ```String``` keys and ```Integer``` values, or the same type, like: ```String``` keys and ```String``` values:
	
Example: Create a ```HashMap``` object called **capitalCities** that will store ```String``` keys and ```String``` values:
	
```java
	
import java.util.HashMap; // import the HashMap class

HashMap<String, String> capitalCities = new HashMap<String, String>();
	
```
	
**Add Items**
	
The HashMap class has many useful methods. For example, to add items to it, use the ```put()``` method:
	
```java

// Import the HashMap class
import java.util.HashMap;

public class Main {
  public static void main(String[] args) {
    // Create a HashMap object called capitalCities
    HashMap<String, String> capitalCities = new HashMap<String, String>();

    // Add keys and values (Country, City)
    capitalCities.put("England", "London");
    capitalCities.put("Germany", "Berlin");
    capitalCities.put("Norway", "Oslo");
    capitalCities.put("USA", "Washington DC");
    System.out.println(capitalCities);
  }
}
	
```
	
**Access an Item**
	
To access a value in the HashMap, use the ```get()``` method and refer to its key:
	
```Java
	
capitalCities.get("England");
	
```
	
**Remove an Item**
	
To remove an item, use the ```remove()``` method and refer to the key:
	
```java
	
capitalCities.remove("England");
	
```
	
To remove all items, use the ```clear()``` method:
	
```java
	
capitalCities.clear();
	
```
	
**HashMap Size**
	
To find out how many items there are, use the ```size()``` method:
	
```java
	
capitalCities.size();
	
```
	
**Loop Through a HashMap**
	
Loop through the items of a HashMap with a for-each loop.

Note: Use the keySet() method if you only want the keys, and use the values() method if you only want the values:
	
```java
	
// Print keys
for (String i : capitalCities.keySet()) {
  System.out.println(i);
}
	
```
	
```java
	
// Print values
for (String i : capitalCities.values()) {
  System.out.println(i);
}
	
```
	
```java
	
// Print keys and values
for (String i : capitalCities.keySet()) {
  System.out.println("key: " + i + " value: " + capitalCities.get(i));
}
	
```
	
**Other Types**
	
Keys and values in a HashMap are actually objects. In the examples above, we used objects of type "String". Remember that a String in Java is an object (not a primitive type). To use other types, such as int, you must specify an equivalent wrapper class: Integer. For other primitive types, use: Boolean for boolean, Character for char, Double for double, etc:
	
```java
	
// Import the HashMap class
import java.util.HashMap;

public class Main {
  public static void main(String[] args) {

    // Create a HashMap object called people
    HashMap<String, Integer> people = new HashMap<String, Integer>();


    // Add keys and values (Name, Age)
    people.put("John", 32);
    people.put("Steve", 30);
    people.put("Angie", 33);

    for (String i : people.keySet()) {
      System.out.println("key: " + i + " value: " + people.get(i));
    }
  }
}
	
```

#### <a name="chapter11part3"></a>Chapter 12 - Part 3: HashSet

- Represents a set of elements (similar to Algebra)
  - Does not allow repetitions
  - Elements have no position
  - Accessing, inserting and removing elements is fast
  - Offers efficient set operations: intersection, union, difference.
  
- Main implementations:
  - HashSet: faster (O(1) operations on hash table) and unordered
  - TreeSet: slower (O(log(n)) operations in red-black tree) and sorted by object compareTo (or Comparator)
  - LinkedHashSet: intermediate speed and elements in the order they are added

**Some important methods**

- add(obj), remove(obj), contains(obj)
  - Based on equals and hashCode
  - If equals and hashCode do not exist, pointer comparison is used

- clear()

- size()

- RemoveIf(predicate)

- addAll(other): union: adds the elements of the other set to the set, without repetition

- retainAll(other): intersection: removes elements not contained in other from the set

- removeAll(other): difference: removes elements contained in other from the set
	
A HashSet is a collection of items where every item is unique, and it is found in the ```java.util``` package:
	
Example: Create a HashSet object called cars that will store strings:
	
```java
	
import java.util.HashSet; // Import the HashSet class

HashSet<String> cars = new HashSet<String>();
	
```
	
**Add Items**
	
The HashSet class has many useful methods. For example, to add items to it, use the ```add()``` method:
	
```java
	
// Import the HashSet class
import java.util.HashSet;

public class Main {
  public static void main(String[] args) {
    HashSet<String> cars = new HashSet<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    cars.add("BMW");
    cars.add("Mazda");
    System.out.println(cars);
  }
}
	
```
	
Note: In the example above, even though BMW is added twice it only appears once in the set because every item in a set has to be unique.
	
**Check If an Item Exists**
	
To check whether an item exists in a HashSet, use the ```contains()``` method:
	
```java
	
cars.contains("Mazda");
	
```
	
**Remove an Item**
	
To remove an item, use the ```remove()``` method:
	
```java
	
cars.remove("Volvo");
	
```
	
To remove all items, use the ```clear()``` method:
	
```java
	
cars.clear();
	
```
	
**HashSet Size**

To find out how many items there are, use the ```size``` method:
	
```java
	
cars.size();
	
```
	
**Loop Through a HashSet**
	
Loop through the items of an HashSet with a for-each loop:
	
```java
	
for (String i : cars) {
  System.out.println(i);
}
	
```
	
**Union**
	
```java
	
package application;
	
import java.util.Arrays;
import java.util.Set;
import java.util.TreeSet;
	
public class Program {
	
	public static void main(String[] args) {
	
		Set<Integer> a = new TreeSet<>(Arrays.asList(0,2,4,5,6,8,10));
		Set<Integer> b = new TreeSet<>(Arrays.asList(5,6,7,8,9,10));
	
		//union
		Set<Integer> c = new TreeSet<>(a);
		c.addAll(b);
		System.out.println(c); // [0, 2, 4, 5, 6, 7, 8, 9, 10]
	}
}
	
```
	
**intersection**
	
```java
	
import java.util.Arrays;
import java.util.Set;
import java.util.TreeSet;
	
public class Program {
	
	public static void main(String[] args) {
	
		Set<Integer> a = new TreeSet<>(Arrays.asList(0,2,4,5,6,8,10));
		Set<Integer> b = new TreeSet<>(Arrays.asList(5,6,7,8,9,10));
	
		//intersection
		Set<Integer> d = new TreeSet<>(a);
		d.retainAll(b);
		System.out.println(d); // [5, 6, 8, 10]
	}
}
	
```
	
**difference**
	
```java
	
import java.util.Arrays;
import java.util.Set;
import java.util.TreeSet;
	
public class Program {
	
	public static void main(String[] args) {
	
		Set<Integer> a = new TreeSet<>(Arrays.asList(0,2,4,5,6,8,10));
		Set<Integer> b = new TreeSet<>(Arrays.asList(5,6,7,8,9,10));
	
		//difference
		Set<Integer> e = new TreeSet<>(a);
		e.removeAll(b);
		System.out.println(e); //[0, 2, 4]
	}
}
	
```
	
**Other Types**
	
Items in an HashSet are actually objects. In the examples above, we created items (objects) of type "String". Remember that a String in Java is an object (not a primitive type). To use other types, such as int, you must specify an equivalent wrapper class: Integer. For other primitive types, use: Boolean for boolean, Character for char, Double for double, etc:
	
```java
	
import java.util.HashSet;

public class Main {
  public static void main(String[] args) {

    // Create a HashSet object called numbers
    HashSet<Integer> numbers = new HashSet<Integer>();

    // Add values to the set
    numbers.add(4);
    numbers.add(7);
    numbers.add(8);

    // Show which numbers between 1 and 10 are in the set
    for(int i = 1; i <= 10; i++) {
      if(numbers.contains(i)) {
        System.out.println(i + " was found in the set.");
      } else {
        System.out.println(i + " was not found in the set.");
      }
    }
  }
}
			  
```


## <a name="chapter12"></a>Chapter 12: Java Date and Time

#### <a name="chapter12part1"></a>Chapter 12 - Part 1: Java Date and Time

**Java Dates**

Java does not have a built-in Date class, but we can import the ```java.time``` package to work with the date and time API. The package includes many date and time classes. For example:

| Class             | Description                                                             |
| :----------------:| :----------------------------------------------------------------------:|
| LocalDate         | Represents a date (year, month, day (yyyy-MM-dd))                       |
| LocalTime         | Represents a time (hour, minute, second and nanoseconds (HH-mm-ss-ns))  |
| LocalDateTime     | Represents both a date and a time (yyyy-MM-dd-HH-mm-ss-ns)              | 
| DateTimeFormatter | Formatter for displaying and parsing date-time objects                  | 

**Display Current Date**

To display the current date, import the ```java.time.LocalDate``` class, and use its ```now()``` method:

```java

import java.time.LocalDate; // import the LocalDate class

public class Main {
  public static void main(String[] args) {
    LocalDate myObj = LocalDate.now(); // Create a date object
    System.out.println(myObj); // Display the current date //2022-11-04 
  }
}

**Display Current Time**

To display the current time (hour, minute, second, and nanoseconds), import the ```java.time.LocalTime``` class, and use its ```now()``` method:

```java

import java.time.LocalTime; // import the LocalTime class

public class Main {
  public static void main(String[] args) {
    LocalTime myObj = LocalTime.now();
    System.out.println(myObj); //14:30:40.994046 
  }
}

```

**Display Current Date and Time**

To display the current date and time, import the ```java.time.LocalDateTime class```, and use its ```now()``` method:

```java

import java.time.LocalDateTime; // import the LocalDateTime class

public class Main {
  public static void main(String[] args) {
    LocalDateTime myObj = LocalDateTime.now();
    System.out.println(myObj); //2022-11-04T14:30:40.994110 
  }
}

```

**Formatting Date and Time**

The "T" in the example above is used to separate the date from the time. You can use the ```DateTimeFormatter``` class with the ```ofPattern()``` method in the same package to format or parse date-time objects. The following example will remove both the "T" and nanoseconds from the date-time:

```java

import java.time.LocalDateTime; // Import the LocalDateTime class
import java.time.format.DateTimeFormatter; // Import the DateTimeFormatter class

public class Main {
  public static void main(String[] args) {
    LocalDateTime myDateObj = LocalDateTime.now();
    System.out.println("Before formatting: " + myDateObj); //Before Formatting: 2022-11-04T14:30:40.995494 
    DateTimeFormatter myFormatObj = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss");

    String formattedDate = myDateObj.format(myFormatObj);
    System.out.println("After formatting: " + formattedDate); //After Formatting: 04-11-2022 14:30:40 
  }
}

```

The ```ofPattern()``` method accepts all sorts of values, if you want to display the date and time in a different format. For example:

| Value          | Example            |
| :-------------:| :-----------------:|
| yyyy-MM-dd     | "1988-09-29"       |
| dd/MM/yyyy     | "29/09/1988"       |
| dd-MMM-yyyy    | "29-Sep-1988"      | 
| E, MMM dd yyyy | "Thu, Sep 29 1988" |

## <a name="chapter13"></a>Chapter 13: Java Enums

#### <a name="chapter13part1"></a>Chapter 12 - Part 1: Java Enums

It is a special type that serves to literally specify a set of related constants

Keyword in Java: ```enum```

Advantage: better semantics, more readable code and supported by compiler

Example: life cycle of a request.

```java

package entities.enums;

public enum OrderStatus {

	PENDING_PAYMENT,
	PROCESSING,
	SHIPPED,
	DELIVERED;
}

```

```java

package entities;

import java.util.Date;

import entities.enums.OrderStatus;

public class Order {

	private Integer id;
	private Date moment;
	private OrderStatus status;
	
	public Order() {
	}

	public Order(Integer id, Date moment, OrderStatus status) {
		this.id = id;
		this.moment = moment;
		this.status = status;
	}

	public Integer getId() {
		return id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public Date getMoment() {
		return moment;
	}

	public void setMoment(Date moment) {
		this.moment = moment;
	}

	public OrderStatus getStatus() {
		return status;
	}

	public void setStatus(OrderStatus status) {
		this.status = status;
	}

	@Override
	public String toString() {
		return "Order [id=" + id + ", moment=" + moment + ", status=" + status + "]";
	}
}

```

```java

package application;

import java.util.Date;

import entities.Order;
import entities.enums.OrderStatus;

public class Program {

	public static void main(String[] args) {

		Order order = new Order(1080, new Date(), OrderStatus.PENDING_PAYMENT);
		
		System.out.println(order);
		
		OrderStatus os1 = OrderStatus.DELIVERED;
		
		OrderStatus os2 = OrderStatus.valueOf("DELIVERED");
		
		System.out.println(os1);
		System.out.println(os2);
	}
}

```

**Convertion String to enum**

```java

OrderStatus os1 = OrderStatus.DELIVERED;

OrderStatus os2 = OrderStatus.valueOf("DELIVERED");

```

UML Annotation

<br>

<div align="center"><img src="img/enum-w797-h251.png" width=428 height=179><br><sub>Fig 39 - Enum UML representation - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

## <a name="chapter14"></a>Chapter 14: Java Interfaces

#### <a name="chapter14part1"></a>Chapter 14 - Part 1: Java Interfaces

As of Java 8, interfaces can have "default methods" or "defend methods"

Interface is a type that defines a set of operations that a class must implement.

The interface establishes a contract that the class must comply with.

- For what interfaces?
  - To create loosely coupled and flexible systems.

```java

interface Shape {
	double area();
	double perimeter();
}

```

Another way to achieve **abstraction** in Java, is with interfaces.

An ```interface``` is a completely **"abstract class"** that is used to group related methods with empty bodies:

```java

// interface
interface Animal {
  public void animalSound(); // interface method (does not have a body)
  public void run(); // interface method (does not have a body)
}

```

To access the interface methods, the interface must be "implemented" (kinda like inherited) by another class with the ```implements``` keyword (instead of ```extends```). The body of the interface method is provided by the "implement" class:

```java

// Interface
interface Animal {
  public void animalSound(); // interface method (does not have a body)
  public void sleep(); // interface method (does not have a body)
}

// Pig "implements" the Animal interface
class Pig implements Animal {
  public void animalSound() {
    // The body of animalSound() is provided here
    System.out.println("The pig says: wee wee");
  }
  public void sleep() {
    // The body of sleep() is provided here
    System.out.println("Zzz");
  }
}

class Main {
  public static void main(String[] args) {
    Pig myPig = new Pig();  // Create a Pig object
    myPig.animalSound();
    myPig.sleep();
  }
}

```

Notes on Interfaces:

- Like abstract classes, interfaces cannot be used to create objects (in the example above, it is not possible to create an "Animal" object in the MyMainClass)
- Interface methods do not have a body - the body is provided by the "implement" class
- On implementation of an interface, you must override all of its methods
- Interface methods are by default ```abstract``` and ```public```
- Interface attributes are by default ```public```, ```static``` and ```final```
- An interface cannot contain a constructor (as it cannot be used to create objects)

Why And When To Use Interfaces?

1) To achieve security - hide certain details and only show the important details of an object (interface).

2) Java does not support "multiple inheritance" (a class can only inherit from one superclass). However, it can be achieved with interfaces, because the class can **implement** multiple interfaces. **Note**: To implement multiple interfaces, separate them with a comma (see example below).

**Multiple Interfaces**

To implement multiple interfaces, separate them with a comma:

```java

interface FirstInterface {
  public void myMethod(); // interface method
}

interface SecondInterface {
  public void myOtherMethod(); // interface method
}

class DemoClass implements FirstInterface, SecondInterface {
  public void myMethod() {
    System.out.println("Some text..");
  }
  public void myOtherMethod() {
    System.out.println("Some other text...");
  }
}

class Main {
  public static void main(String[] args) {
    DemoClass myObj = new DemoClass();
    myObj.myMethod();
    myObj.myOtherMethod();
  }
}

```

Exercise: A Brazilian car rental company charges an hourly rate for rentals of up to 12 hours. However, if the duration of the lease exceeds 12 hours, the lease will be charged based on a daily rate. In addition to the lease amount, it is added to the price the tax amount according to the country's rules which, in the case of Brazil, is 20% for values up to 100.00, or 15% for values above 100.00. Make one program that reads the lease data (car model, start and end time of lease), as well as the hourly rate and the daily rental rate. The program must then generate the payment note (containing lease amount, tax and total payment amount) and enter the data on the screen. see the examples.

<br>

<div align="center"><img src="img/interfaces1-w494-h669.png" width=494 height=669><br><sub>Fig 40 - Exercise Interface - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Class CarRental

```java

package model.entities;

import java.time.LocalDateTime;

public class CarRental {

	private LocalDateTime start;
	private LocalDateTime finish;
	
	private Vehicle vehicle;
	private Invoice invoice;
	
	public CarRental() {
	}

	public CarRental(LocalDateTime start, LocalDateTime finish, Vehicle vehicle) {
		this.start = start;
		this.finish = finish;
		this.vehicle = vehicle;
	}

	public LocalDateTime getStart() {
		return start;
	}

	public void setStart(LocalDateTime start) {
		this.start = start;
	}

	public LocalDateTime getFinish() {
		return finish;
	}

	public void setFinish(LocalDateTime finish) {
		this.finish = finish;
	}

	public Vehicle getVehicle() {
		return vehicle;
	}

	public void setVehicle(Vehicle vehicle) {
		this.vehicle = vehicle;
	}

	public Invoice getInvoice() {
		return invoice;
	}

	public void setInvoice(Invoice invoice) {
		this.invoice = invoice;
	}
}

```

Class Invoice

```java

package model.entities;

public class Invoice {

	private Double basicPayment;
	private Double tax;
	
	public Invoice() {
	}

	public Invoice(Double basicPayment, Double tax) {
		this.basicPayment = basicPayment;
		this.tax = tax;
	}

	public Double getBasicPayment() {
		return basicPayment;
	}

	public void setBasicPayment(Double basicPayment) {
		this.basicPayment = basicPayment;
	}

	public Double getTax() {
		return tax;
	}

	public void setTax(Double tax) {
		this.tax = tax;
	}
	
	public Double getTotalPayment() {
		return getBasicPayment() + getTax();
	}
}

```

Class Vehicle

```java

package model.entities;

public class Vehicle {

	private String model;
	
	public Vehicle() {
	}

	public Vehicle(String model) {
		this.model = model;
	}

	public String getModel() {
		return model;
	}

	public void setModel(String model) {
		this.model = model;
	}
}

```

Class RentalService

```java

package model.services;

import java.time.Duration;

import model.entities.CarRental;
import model.entities.Invoice;

public class RentalService {

	private Double pricePerDay;
	private Double pricePerHour;
	
	private TaxService taxService;

	public RentalService(Double pricePerDay, Double pricePerHour, TaxService taxService) {
		this.pricePerDay = pricePerDay;
		this.pricePerHour = pricePerHour;
		this.taxService = taxService;
	}
	
	public void processInvoice(CarRental carRental) {
		
		double minutes = Duration.between(carRental.getStart(), carRental.getFinish()).toMinutes();		
		double hours = minutes / 60.0;
		
		double basicPayment;
		if (hours <= 12.0) {
			basicPayment = pricePerHour * Math.ceil(hours);
		}
		else {
			basicPayment = pricePerDay * Math.ceil(hours / 24);
		}

		double tax = taxService.tax(basicPayment);

		carRental.setInvoice(new Invoice(basicPayment, tax));
	}
}

```

Class TaxService

```java

package model.services;

public interface TaxService {

	double tax(double amount);
}

```

Class BrazilTaxService

```java

package model.services;

public class BrazilTaxService implements TaxService {

	public double tax(double amount) {
		if (amount <= 100.0) {
			return amount * 0.2;
		}
		else {
			return amount * 0.15;
		}
	}
}

```

<br>

<div align="center"><img src="img/interfaces2-w636-h869.png" width=636 height=869><br><sub>Fig 40 - Exercise Interface - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Program

```java

package application;

import java.text.ParseException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.Locale;
import java.util.Scanner;

import model.entities.CarRental;
import model.entities.Vehicle;
import model.services.BrazilTaxService;
import model.services.RentalService;

public class Program {

	public static void main(String[] args) throws ParseException {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		DateTimeFormatter fmt =  DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
		
		System.out.println("Entre com os dados do aluguel");
		System.out.print("Modelo do carro: ");
		String carModel = sc.nextLine();
		System.out.print("Retirada (dd/MM/yyyy HH:mm): ");
		LocalDateTime start = LocalDateTime.parse(sc.nextLine(), fmt);
		System.out.print("Retorno (dd/MM/yyyy HH:mm): ");
		LocalDateTime finish = LocalDateTime.parse(sc.nextLine(), fmt);
		
		CarRental cr = new CarRental(start, finish, new Vehicle(carModel));

		System.out.print("Entre com o preço por hora: ");
		double pricePerHour = sc.nextDouble();
		System.out.print("Entre com o preço por dia: ");
		double pricePerDay = sc.nextDouble();
		
		RentalService rentalService = new RentalService(pricePerDay, pricePerHour, new BrazilTaxService());
		
		rentalService.processInvoice(cr);

		System.out.println("FATURA:");
		System.out.println("Pagamento basico: " + String.format("%.2f", cr.getInvoice().getBasicPayment()));
		System.out.println("Imposto: " + String.format("%.2f", cr.getInvoice().getTax()));
		System.out.println("Pagamento total: " + String.format("%.2f", cr.getInvoice().getTotalPayment()));
		
		sc.close();
	}
}

```

#### <a name="chapter14part2"></a>Chapter 14 - Part 2: Dependency Injection and Inversion of Control

When we have a direct association we have:
- Strong Coupling
- The RentalService class knows the concrete dependency
- If the concrete class changes, you need to change the RentalService class

<br>

<div align="center"><img src="img/interfaces3-w792-h366.png" width=792 height=366><br><sub>Fig 40 - Interfaces - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

When we implement a interface in our solution:
- weak coupling
- The RentalService class doesn't know the concrete dependency
- If the concrete class changes, the RentalService class doesn't change anything

<br>

<div align="center"><img src="img/interfaces4-w903-h410.png" width=903 height=410><br><sub>Fig 40 - Interfaces - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

**Dependency injection via constructor**

<br>

<div align="center"><img src="img/interfaces5-w1052-h449.png" width=1052 height=449><br><sub>Fig 40 - Interfaces - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

**Inversion of control**
- Development pattern that consists of removing from class a responsibility to instantiate your dependencies. The Class RentalService don't have to instanciate the type of TaxService, just the abstraction, Tax Service

**dependency injection**
- It is a way of performing inversion of control: an external component instantiates the dependency (In the exercise, the main Program, which is then injected into the "parent" object (The Parent was the RentalService). It might be implemented in several ways:
  - Constructor
  - Instantiation class (builder/factory)
  - Container / framework

#### <a name="chapter14part3"></a>Chapter 14 - Part 3: Inheritance vs Interfaces

**Common aspects between inheritance and interfaces**

- relationship is-one
- generalization/specialization
- Polymorphism

**Main Differences**

- inheritance = reuse (attributes and methods)
- interfaces = contract to be fulfilled

<br>

<div align="center"><img src="img/interfaces6-w952-h310.png" width=952 height=310><br><sub>Fig 40 - Interfaces - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

You can implement inheritance with interfaces, folow this case

Exercise: What if I need to implement Shape as an interface, but I also want to define a common reusable structure for all figures?

<br>

<div align="center"><img src="img/interfaces7-w993-h400.png" width=993 height=400><br><sub>Fig 40 - Interfaces - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

Class Colour

```java

package model.enums;

public enum Color {
	BLACK,
	WHITE;
}

```

Class AbstractShape

```java

package model.entities;

import model.enums.Color;

public abstract class AbstractShape implements Shape {

	private Color color;

	public AbstractShape(Color color) {
		this.color = color;
	}

	public Color getColor() {
		return color;
	}

	public void setColor(Color color) {
		this.color = color;
	}
}

```

Class Shape

```java

package model.entities;

public interface Shape {

	double area();
}

```

Class Circle

```java

package model.entities;

import model.enums.Color;

public class Circle extends AbstractShape {

	private Double radius;

	public Circle(Color color, Double radius) {
		super(color);
		this.radius = radius;
	}

	public Double getRadius() {
		return radius;
	}

	public void setRadius(Double radius) {
		this.radius = radius;
	}

	@Override
	public double area() {
		return Math.PI * radius * radius;
	}
}

```

Class Rectangle

```java

package model.entities;

import model.enums.Color;

public class Rectangle extends AbstractShape {

	private Double width;
	private Double height;

	public Rectangle(Color color, Double width, Double height) {
		super(color);
		this.width = width;
		this.height = height;
	}

	public Double getWidth() {
		return width;
	}

	public void setWidth(Double width) {
		this.width = width;
	}

	public Double getHeight() {
		return height;
	}

	public void setHeight(Double height) {
		this.height = height;
	}

	@Override
	public double area() {
		return width * height;
	}
}

```

Program

```java

package application;

import model.entities.AbstractShape;
import model.entities.Circle;
import model.entities.Rectangle;
import model.enums.Color;

public class Program {

	public static void main(String[] args) {

		AbstractShape s1 = new Circle(Color.BLACK, 2.0);
		AbstractShape s2 = new Rectangle(Color.WHITE, 3.0, 4.0);
		
		System.out.println("Circle color: " + s1.getColor());
		System.out.println("Circle area: " + String.format("%.3f", s1.area()));
		System.out.println("Rectangle color: " + s2.getColor());
		System.out.println("Rectangle area: " + String.format("%.3f", s2.area()));
	}
}

```

#### <a name="chapter14part4"></a>Chapter 14 - Part 4: Multiple Inheritance and Interfaces

Multiple inheritance can generate the diamond problem: a ambiguity caused by existence of the same method in more than one superclass.

Multiple inheritance is not allowed in most languages!

<br>

<div align="center"><img src="img/interfaces8-w578-h443.png" width=578 height=443><br><sub>Fig 40 - Interfaces - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

**However, a class can implement more from an interface**

<br>

<div align="center"><img src="img/interfaces9-w633-h323.png" width=633 height=323><br><sub>Fig 40 - Interfaces - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

OBS: This is NOT multiple inheritance, because THERE IS NO REUSE in the relationship between ComboDevice and the Scanner and Printer interfaces. ComboDevide does not inherit, but yes implements the interfaces (fulfills the contract).

Class Device

```java

package devices;

public abstract class Device {

	public String serialNumber;

	public Device(String serialNumber) {
		this.serialNumber = serialNumber;
	}
	
	public String getSerialNumber() {
		return serialNumber;
	}

	public void setSerialNumber(String serialNumber) {
		this.serialNumber = serialNumber;
	}

	public abstract void processDoc(String doc);
}

```

Class ComboDevice

```java

package devices;

public class ComboDevice extends Device implements Scanner, Printer {

	public ComboDevice(String serialNumber) {
		super(serialNumber);
	}

	@Override
	public void print(String doc) {
		System.out.println("Combo printing: " + doc);
	}

	@Override
	public String scan() {
		return "Combo scan result";
	}

	@Override
	public void processDoc(String doc) {
		System.out.println("Combo processing: " + doc);
	}
}

```

Class Printer

```java

package devices;

public interface Printer {

	void print(String doc);
}

```

Class Scanner

```java

package devices;

public interface Scanner {

	String scan();
}

```

Class ConcretePrinter

```Java

package devices;

public class ConcretePrinter extends Device implements Printer {

	public ConcretePrinter(String serialNumber) {
		super(serialNumber);
	}

	@Override
	public void processDoc(String doc) {
		System.out.println("Printer processing: " + doc);
	}

	@Override
	public void print(String doc) {
		System.out.println("Printing: " + doc);
	}
}

```

Class ConcreteScanner

```java

package devices;

public class ConcreteScanner extends Device implements Scanner {

	public ConcreteScanner(String serialNumber) {
		super(serialNumber);
	}

	@Override
	public void processDoc(String doc) {
		System.out.println("Scanner processing: " + doc);
	}

	@Override
	public String scan() {
		return "Scanned content";
	}
}

```

Program

```java

package application;

import devices.ComboDevice;
import devices.ConcretePrinter;
import devices.ConcreteScanner;

public class Program {

	public static void main(String[] args) {

		ConcretePrinter p = new ConcretePrinter("1080");
		p.processDoc("My Letter");
		p.print("My Letter");

		System.out.println();
		ConcreteScanner s = new ConcreteScanner("2003");
		s.processDoc("My Email");
		System.out.println("Scan result: " + s.scan());
		
		System.out.println();
		ComboDevice c = new ComboDevice("2081");
		c.processDoc("My dissertation");
		c.print("My dissertation");
		System.out.println("Scan result: " + c.scan());
	}
}

```

#### <a name="chapter14part5"></a>Chapter 14 - Part 5: Comparable Interface

The Comparable interface is used to compare an object of the same class with an instance of that class, it provides ordering of data for objects of the user-defined class. The class has to implement the java.lang.Comparable interface to compare its instance, it provides the compareTo method that takes a parameter of the object of that class.

Example: Write a program to read a file containing names of people (one name per line), storing them in a list. Then sort the data in this list and show them neatly on the screen. Note: the file path can be informed "hardcode".

Maria Brown
Alex Green
Bob Grey
Anna White
Alex Black
Eduardo Rose
Willian Red
Marta Blue
Alex Brown

```java

package hello;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Program {
	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
		String path = "C:\\temp\\in.txt";
		try (BufferedReader br = new BufferedReader(new FileReader(path))) {
			String name = br.readLine();
			while (name != null) {
				list.add(name);
				name = br.readLine();
			}
			Collections.sort(list);
			for (String s : list) {
				System.out.println(s);
			}
		} catch (IOException e) {
			System.out.println("Error: " + e.getMessage());
		}
	}
}


/*

output

Alex Black
Alex Brown
Alex Green
Anna White
Bob Grey
Eduardo Rose
Maria Brown
Marta Blue
Willian Red

*/

```

Example:  Make a program to read a file containing employees (name and salary) in the .csv format, storing them in a list. Then sort the list by name and show the result on the screen. Note: the file path can be informed "hardcode".

Maria Brown,4300.00
Alex Green,3100.00
Bob Grey,3100.00
Anna White,3500.00
Alex Black,2450.00
Eduardo Rose,4390.00
Willian Red,2900.00
Marta Blue,6100.00
Alex Brown,5000.00



```java

package hello;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import entities.Employee;

public class Program {
	public static void main(String[] args) {
		List<Employee> list = new ArrayList<>();
		String path = "C:\\temp\\in.txt";
		try (BufferedReader br = new BufferedReader(new FileReader(path))) {
			String employeeCsv = br.readLine();
			while (employeeCsv != null) {
				String[] fields = employeeCsv.split(",");
				list.add(new Employee(fields[0], Double.parseDouble(fields[1])));
				employeeCsv = br.readLine();
			}
			Collections.sort(list);
			for (Employee emp : list) {
				System.out.println(emp.getName() + ", " + emp.getSalary());
			}
		} catch (IOException e) {
			System.out.println("Error: " + e.getMessage());
		}
	}
}

/*
 * 
 * output
 * 
Alex Black, 2450.0
Alex Brown, 5000.0
Alex Green, 3100.0
Anna White, 3500.0
Bob Grey, 3100.0
Eduardo Rose, 4390.0
Maria Brown, 4300.0
Marta Blue, 6100.0
Willian Red, 2900.0
 */

```

```java

package entities;

public class Employee implements Comparable<Employee> {
	private String name;
	private Double salary;

	public Employee(String name, Double salary) {
		this.name = name;
		this.salary = salary;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Double getSalary() {
		return salary;
	}

	public void setSalary(Double salary) {
		this.salary = salary;
	}

	@Override
	public int compareTo(Employee other) {
		return name.compareTo(other.getName()); //you are comparing with name with .getName(). If was salary, use .getSalary()
	}
}

```

**Using Comparable Interface**

- In this method, we are going to implement the Comparable interface from java.lang Package in the Pair class.
- The Comparable interface contains the method compareTo to decide the order of the elements.
- Override the compareTo method in the Pair class.
- Create an array of Pairs and populate the array.
- Use the Arrays.sort() function to sort the array.

**Example 1**

Given an array of Pairs consisting of two fields of type string and integer. you have to sort the array in ascending Lexicographical order and if two strings are the same sort it based on their integer value.

**Sample I/O:**

```

Input:  { {"abc", 3}, {"a", 4}, {"bc", 5}, {"a", 2} }
Output:  { {"a", 2}, {"a", 4}, {"abc", 3}, {"bc", 5} }

Input:  { {"efg", 1}, {"gfg", 1}, {"cba", 1}, {"zaa", 1} }
Output:  { {"cba", 1}, {"efg", 1}, {"gfg", 1}, {"zaa", 1} }

```

```java

import java.io.*;
import java.util.*;

class Pair implements Comparable<Pair> {
	String x;
	int y;

	public Pair(String x, int y)
	{
		this.x = x;
		this.y = y;
	}

	public String toString()
	{
		return "(" + x + "," + y + ")";
	}

	@Override public int compareTo(Pair a)
	{
		// if the string are not equal
		if (this.x.compareTo(a.x) != 0) {
			return this.x.compareTo(a.x);
		}
		else {
			// we compare int values
			// if the strings are equal
			return this.y - a.y;
		}
	}
}

public class GFG {
	public static void main(String[] args)
	{

		int n = 4;
		Pair arr[] = new Pair[n];

		arr[0] = new Pair("abc", 3);
		arr[1] = new Pair("a", 4);
		arr[2] = new Pair("bc", 5);
		arr[3] = new Pair("a", 2);

		// Sorting the array
		Arrays.sort(arr);

		// printing the
		// Pair array
		print(arr);
	}

	public static void print(Pair[] arr)
	{
		for (int i = 0; i < arr.length; i++) {
			System.out.println(arr[i]);
		}
	}
}

```

```
Before Sorting:
(abc, 3);
(a, 4);
(bc, 5);
(a, 2);

After Sorting:
(a,2)
(a,4)
(abc,3)
(bc,5)
```

Note: if two strings are the same then the comparison is done based on the value.

**Example 2**

Given an array of Pairs consisting of two strings with first and last names. you have to sort the array in ascending Lexicographical order of the first name and if two strings are the same sort it based on their last name.

**Sample I/O:**

```
Input:  { {"raj", "kashup"}, {"rahul", "singh"}, {"reshmi", "dubey"}, {"rahul", "jetli"} }
Output:  { {"rahul", "jetli"}, {"rahul", "singh"}, {"raj", "kashup"}, {"reshmi", "dubey"} }

Input:  { {"abc", "last"}, {"pklz", "yelp"}, {"rpng", "note"}, {"ppza", "xyz"} }
Output:  { {"abc", "last"}, {"pklz", "yelp"}, {"ppza", "xyz"}, {"rpng", "note"} }
```

```java


import java.io.*;
import java.util.*;
 
class Pair implements Comparable<Pair> {
    String firstName;
    String lastName;
 
    public Pair(String x, String y)
    {
        this.firstName = x;
        this.lastName = y;
    }
 
    public String toString()
    {
        return "( " + firstName + " , " + lastName + " )";
    }
 
    @Override public int compareTo(Pair a)
    {
        // if the string are not equal
        if (this.firstName.compareTo(a.firstName) != 0) {
            return this.firstName.compareTo(a.firstName);
        }
        else {
            // we compare lastName if firstNames are equal
            return this.lastName.compareTo(a.lastName);
        }
    }
}
 
public class GFG {
    public static void main(String[] args)
    {
 
        int n = 4;
        Pair arr[] = new Pair[n];
        arr[0] = new Pair("raj", "kashup");
        arr[1] = new Pair("rahul", "singh");
        arr[2] = new Pair("reshmi", "dubey");
        arr[3] = new Pair("rahul", "jetli");
 
        // Sorting the array
        Arrays.sort(arr);
 
        // printing the
        // Pair array
        print(arr);
    }
 
    public static void print(Pair[] arr)
    {
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}

```

**output**

```
Before Sorting:
( raj , kashup )
( rahul , singh )
( reshmi , dubey )
( rahul , jetli )


After Sorting:
( rahul , jetli )
( rahul , singh )
( raj , kashup )
( reshmi , dubey )
```

#### <a name="chapter14part6"></a>Chapter 14 - Part 6: Default methods

-  As of Java 8, interfaces can contain concrete methods.

- The basic intent is to provide default implementation for methods, so to avoid:
  - repetition of implementation in every class that implements the interface
  - the need to create abstract classes to provide implementation reuse

- Other advantages:
  - Maintain backward compatibility with existing systems
  - Allow "functional interfaces" (which must contain only one method) can provide other reusable standard operations

Example: Make a program to read an amount and the duration in months of a loan. Inform the amount to be paid after the deadline for the loan, in accordance with Brazilian interest rate rules. The calculation rule for Brazilian interest is standard compound interest of 2% per month.

<br>

<div align="center"><img src="img/interfaces10-w840-h323.png" width=840 height=323><br><sub>Fig 40 - Interfaces - (<a href='https://www.udemy.com/course/java-curso-completo/'>Work by  Nelio Alves</a>) </sub></div>

<br>

class BrazilInterestService

```java

package services;

public class BrazilInterestService implements InterestService {

	private double interestRate;

	public BrazilInterestService(double interestRate) {
		this.interestRate = interestRate;
	}

	@Override
	public double getInterestRate() {
		return interestRate;
	}
}

```

class InterestService

```java

package services;

import java.security.InvalidParameterException;

public interface InterestService {

	double getInterestRate();

	default double payment(double amount, int months) {
		if (months < 1) {
			throw new InvalidParameterException("Months must be greater than zero");
		}
		return amount * Math.pow(1.0 + getInterestRate() / 100.0, months);
	}
}

```

class UsaInterestService

```java

package services;

public class UsaInterestService implements InterestService {

	private double interestRate;

	public UsaInterestService(double interestRate) {
		this.interestRate = interestRate;
	}

	@Override
	public double getInterestRate() {
		return interestRate;
	}
}

```

Program

```java

package application;

import java.util.Locale;
import java.util.Scanner;

import services.BrazilInterestService;
import services.InterestService;

public class Program {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		System.out.print("Amount: ");
		double amount = sc.nextDouble();
		System.out.print("Months: ");
		int months = sc.nextInt();
		
		InterestService is = new BrazilInterestService(2.0);
		double payment = is.payment(amount, months);
		
		System.out.println("Payment after " + months + " months:");
		System.out.println(String.format("%.2f", payment));
		
		sc.close();
	}
}

```


In Java 8+: 
- interfaces can now provide reuse
- now we have a form of multiple inheritance
  - But the compiler complains if there is more than one method with the same signature, forcing you to overwrite it
- Interfaces are still quite different from abstract classes. interfaces they do not have features such as constructors and attributes.

## <a name="chapter15"></a>Chapter 15: Java Exceptions

#### <a name="chapter15part1"></a>Chapter 15 - Part 1: Java Exceptions

**Exceptions**

-  An exception is any error condition or behavior unexpected encountered by a running program

- In Java, an exception is an object inherited from the class:
  - java.lang.Exception - compiler forces to handle or propagate
  - java.lang.RuntimeException - compiler does not force to handle or propagate

- When thrown, an exception is propagated down the call stack of running methods, until it is captured (handled) or the program is terminated

<br>

<div align="center"><img src="img/exceptions-w720-h405.png" width=720 height=405><br><sub>Fig 50 - Exceptions in Java - (<a href='https://medium.com/interviewnoodle/exception-in-java-89a0b41e0c45'>Work by Deepti Swain</a>) </sub></div>

<br>

Error subclass is not handled, but Exception subclass need to be handled

**Why Exceptions?**

The exception handling model allows errors to be dealt with consistently and flexibly, using best practices

Benefits:
  - Delega a lógica do erro para a classe responsável por conhecer as regras que podem ocasionar o erro
  - Handles in an organized (including hierarchical) way exceptions of different types
  - The exception can load any data

#### <a name="chapter15part2"></a>Chapter 15 - Part 2: Try-Catch-Finally

The ```try``` statement allows you to define a block of code to be tested for errors while it is being executed.

The ```catch``` statement allows you to define a block of code to be executed, if an error occurs in the try block.

The ```try``` and ```catch``` keywords come in pairs:

```java

try {
  //  Block of code to try
}
catch(Exception e) {
  //  Block of code to handle errors
}

```

Consider the following example:

```java

public class Main {
  public static void main(String[ ] args) {
    int[] myNumbers = {1, 2, 3};
    System.out.println(myNumbers[10]); // error!
  }
}

```

The output will be something like this:

```
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 10
        at Main.main(Main.java:4)
```

If an error occurs, we can use ```try...catch``` to catch the error and execute some code to handle it:

```java

public class Main {
  public static void main(String[ ] args) {
    try {
      int[] myNumbers = {1, 2, 3};
      System.out.println(myNumbers[10]);
    } catch (Exception e) {
      System.out.println("Something went wrong.");
    }
  }
}

```

The output will be:

```
Something went wrong.
```

The ```finally``` statement lets you execute code, after ```try...catch```, regardless of the result:

```Java

public class Main {
  public static void main(String[] args) {
    try {
      int[] myNumbers = {1, 2, 3};
      System.out.println(myNumbers[10]);
    } catch (Exception e) {
      System.out.println("Something went wrong.");
    } finally {
      System.out.println("The 'try catch' is finished.");
    }
  }
}

```

```
Something went wrong.
The 'try catch' is finished.
```

Another Example:

```java

import java.util.InputMismatchException;
import java.util.Scanner;

public class Program {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		try {
			String[] vect = sc.nextLine().split(" ");
			int position = sc.nextInt();
			System.out.println(vect[position]);
		} catch (ArrayIndexOutOfBoundsException e) {
			System.out.println("Invalid position!");
		} catch (InputMismatchException e) {
			System.out.println("Input error");
		}
		System.out.println("End of program");
		sc.close();
	}
}

```

#### <a name="chapter15part3"></a>Chapter 15 - Part 3: Stack Trace

```java

import java.util.InputMismatchException;
import java.util.Scanner;

public class Program {
	public static void main(String[] args) {
		method1();
		System.out.println("End of program");
	}

	public static void method1() {
		System.out.println("***METHOD1 START***");
		method2();
		System.out.println("***METHOD1 END***");
	}

	public static void method2() {
		System.out.println("***METHOD2 START***");
		Scanner sc = new Scanner(System.in);
		try {
			String[] vect = sc.nextLine().split(" ");
			int position = sc.nextInt();
			System.out.println(vect[position]);
		} catch (ArrayIndexOutOfBoundsException e) {
			System.out.println("Invalid position!");
			e.printStackTrace();
			sc.next();
		} catch (InputMismatchException e) {
			System.out.println("Input error");
		}
		sc.close();
		System.out.println("***METHOD2 END***");
	}
}

```



with the ```printStackTrace```, we can print the sequence of methods

```
***METHOD1 START***
***METHOD2 START***
Alex Maria Bob
5
Invalid position!
java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length 3
	at hello.Program.method2(Program.java:24)
	at hello.Program.method1(Program.java:14)
	at hello.Program.main(Program.java:8)
```

#### <a name="chapter15part4"></a>Chapter 15 - Part 4: Custom Exceptions


The ```throw``` statement allows you to create a custom error.

The ```throw``` statement is used together with an **exception type**. There are many exception types available in Java: ```ArithmeticException```, ```FileNotFoundException```, ```ArrayIndexOutOfBoundsException```, ```SecurityException```, etc:

Example: Throw an exception if age is below 18 (print "Access denied"). If age is 18 or older, print "Access granted":

```java

public class Main {
  static void checkAge(int age) {
    if (age < 18) {
      throw new ArithmeticException("Access denied - You must be at least 18 years old.");
    }
    else {
      System.out.println("Access granted - You are old enough!");
    }
  }

  public static void main(String[] args) {
    checkAge(15); // Set age to 15 (which is below 18...)
  }
}

```

The output will be:

```
Exception in thread "main" java.lang.ArithmeticException: Access denied - You must be at least 18 years old.
        at Main.checkAge(Main.java:4)
        at Main.main(Main.java:12)
```

If age was 20, you would not get an exception:

```
checkAge(20);
```

The output will be:

```
Access granted - You are old enough!
```

## <a name="chapter16"></a>Chapter 16: Java File Handling

#### <a name="chapter16part1"></a>Chapter 16 - Part 1: Java File Handling

**Java File Handling**

The ```File``` class from the ```java.io``` package, allows us to work with files.

To use the ```File``` class, create an object of the class, and specify the filename or directory name:

```java

import java.io.File;  // Import the File class

File myObj = new File("filename.txt"); // Specify the filename

```

The ```File``` class has many useful methods for creating and getting information about files. For example:

| Method            | Type      | Description                                    |
| :----------------:| :--------:|:---------------------------------------------: |
| canRead()         | Boolean   | Tests whether the file is readable or not      |
| canWrite()        | Boolean   | Tests whether the file is writable or not      |
| createNewFile()   | Boolean   | Creates an empty file                          |
| delete()          | Boolean   | Deletes a file                                 |
| exists()          | Boolean   | Tests whether the file exists                  |
| getName()         | String    | Returns the name of the file                   |
| getAbsolutePath() | String    | Returns the absolute pathname of the file      |
| length()          | Long      | Returns the size of the file in bytes          |
| list()            | String[]  | Returns an array of the files in the directory |
| mkdir()           | Boolean   | Creates a directory                            |

#### <a name="chapter16part2"></a>Chapter 16 - Part 2: Java Create and Write To Files

**Create a File**

To create a file in Java, you can use the ```createNewFile()``` method. This method returns a boolean value: ```true``` if the file was successfully created, and ```false``` if the file already exists. Note that the method is enclosed in a ```try...catch``` block. This is necessary because it throws an ```IOException``` if an error occurs (if the file cannot be created for some reason):

```java

import java.io.File;  // Import the File class
import java.io.IOException;  // Import the IOException class to handle errors

public class CreateFile {
  public static void main(String[] args) {
    try {
      File myObj = new File("filename.txt");
      if (myObj.createNewFile()) {
        System.out.println("File created: " + myObj.getName());
      } else {
        System.out.println("File already exists.");
      }
    } catch (IOException e) {
      System.out.println("An error occurred.");
      e.printStackTrace();
    }
  }
}

```

The output will be:

```
File created: filename.txt
```

To create a file in a specific directory (requires permission), specify the path of the file and use double backslashes to escape the "\" character (for Windows). On Mac and Linux you can just write the path, like: /Users/name/filename.txt

```java

File myObj = new File("C:\\Users\\MyName\\filename.txt");

```

**Write To a File**

In the following example, we use the ```FileWriter``` class together with its ```write()``` method to write some text to the file we created in the example above. Note that when you are done writing to the file, you should close it with the ```close()``` method:

```java

import java.io.FileWriter;   // Import the FileWriter class
import java.io.IOException;  // Import the IOException class to handle errors

public class WriteToFile {
  public static void main(String[] args) {
    try {
      FileWriter myWriter = new FileWriter("filename.txt");
      myWriter.write("Files in Java might be tricky, but it is fun enough!");
      myWriter.close();
      System.out.println("Successfully wrote to the file.");
    } catch (IOException e) {
      System.out.println("An error occurred.");
      e.printStackTrace();
    }
  }
}

```

The output will be:

```
Successfully wrote to the file.
```

#### <a name="chapter16part3"></a>Chapter 16 - Part 3: Java Read Files

**Read a File**

In the previous chapter, you learned how to create and write to a file.

In the following example, we use the ```Scanner``` class to read the contents of the text file we created in the previous chapter:

```java

import java.io.File;  // Import the File class
import java.io.FileNotFoundException;  // Import this class to handle errors
import java.util.Scanner; // Import the Scanner class to read text files

public class ReadFile {
  public static void main(String[] args) {
    try {
      File myObj = new File("filename.txt");
      Scanner myReader = new Scanner(myObj);
      while (myReader.hasNextLine()) {
        String data = myReader.nextLine();
        System.out.println(data);
      }
      myReader.close();
    } catch (FileNotFoundException e) {
      System.out.println("An error occurred.");
      e.printStackTrace();
    }
  }
}

```

The output will be:

```
Files in Java might be tricky, but it is fun enough!
```

**Get File Information**

To get more information about a ```file```, use any of the File methods:

```java

import java.io.File;  // Import the File class

public class GetFileInfo { 
  public static void main(String[] args) {
    File myObj = new File("filename.txt");
    if (myObj.exists()) {
      System.out.println("File name: " + myObj.getName());
      System.out.println("Absolute path: " + myObj.getAbsolutePath());
      System.out.println("Writeable: " + myObj.canWrite());
      System.out.println("Readable " + myObj.canRead());
      System.out.println("File size in bytes " + myObj.length());
    } else {
      System.out.println("The file does not exist.");
    }
  }
}

```

The output will be:

```
File name: filename.txt
Absolute path: C:\Users\MyName\filename.txt
Writeable: true
Readable: true
File size in bytes: 0
```

OBS: Note: There are many available classes in the Java API that can be used to read and write files in Java: ```FileReader, BufferedReader, Files, Scanner, FileInputStream, FileWriter, BufferedWriter, FileOutputStream```, etc. Which one to use depends on the Java version you're working with and whether you need to read bytes or characters, and the size of the file/lines etc.

#### <a name="chapter16part4"></a>Chapter 16 - Part 4: Java Delete Files

**Delete a File**

To delete a file in Java, use the ```delete()``` method:

```java

import java.io.File;  // Import the File class

public class DeleteFile {
  public static void main(String[] args) { 
    File myObj = new File("filename.txt"); 
    if (myObj.delete()) { 
      System.out.println("Deleted the file: " + myObj.getName());
    } else {
      System.out.println("Failed to delete the file.");
    } 
  } 
}

```

The output will be:

```
Deleted the file: filename.txt
```

**Delete a Folder**

You can also delete a folder. However, it must be empty:

```java

import java.io.File; 

public class DeleteFolder {
  public static void main(String[] args) { 
    File myObj = new File("C:\\Users\\MyName\\Test"); 
    if (myObj.delete()) { 
      System.out.println("Deleted the folder: " + myObj.getName());
    } else {
      System.out.println("Failed to delete the folder.");
    } 
  } 
}

```

The output will be:

```
Deleted the folder: Test
```
	

	
<!-- URL's -->
